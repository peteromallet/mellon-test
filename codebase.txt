
================================================================================
FILE: config.py
================================================================================

import configparser
import logging
import os

class Config:
    def __init__(self):
        self.config = configparser.ConfigParser()
        self.config.read('config.ini')

        self.server = {
            'host': self.config.get('server', 'host', fallback='127.0.0.1'),
            'port': self.config.getint('server', 'port', fallback=8080),
            'cors': self.config.getboolean('server', 'cors', fallback=False),
            'cors_route': self.config.get('server', 'cors_route', fallback='*'),
        }

        self.app = {
            'global_seed': self.config.getint('app', 'global_seed', fallback=42),
        }

        self.log = {
            'level': getattr(logging, self.config.get('logging', 'level', fallback='INFO').upper()),
        }

        self.hf = {
            'token': self.config.get('huggingface', 'token', fallback=None),
            'cache_dir': self.config.get('huggingface', 'cache_dir', fallback=None),
            'online_status': self.config.get('huggingface', 'online_status', fallback='Connect if needed'),
        }

        self.paths = {
            'data': self.config.get('paths', 'data', fallback='data'),
            'temp': self.config.get('paths', 'temp', fallback='data/temp'),
        }

        for path, value in self.paths.items():
            if not os.path.isabs(value):
                value = os.path.join(os.path.dirname(__file__), value)
                self.paths[path] = value

            if not os.path.exists(value):
                os.makedirs(value)

        self.environ = self.config['environ'] if 'environ' in self.config else {}
        for key, value in self.environ.items():
            self.environ[key] = self.config.get('environ', key, fallback=None)

config = Config()


================================================================================
FILE: main.py
================================================================================

import logging
import os
from config import config
import torch # warm up since we are going to use it anyway

# initialize logging
logging.basicConfig(level=config.log['level'], format="%(asctime)s [%(levelname)s] %(message)s", datefmt="%Y%m%d %H.%M.%S")
logger = logging.getLogger('mellon')

# random seed generation
# import numpy as np
#import random
# torch.cuda.manual_seed(0)
# torch.cuda.manual_seed_all(0)
# torch.backends.cudnn.deterministic = True
# torch.backends.cudnn.benchmark = False
# np.random.seed(0)
# random.seed(0)
# os.environ['PYTHONHASHSEED'] = str(0)
# os.environ['CUBLAS_WORKSPACE_CONFIG'] = ':4096:8'
# torch.use_deterministic_algorithms(True)

# huggingface cache directory
if config.hf['cache_dir']:
    os.environ['HF_HOME'] = config.hf['cache_dir']

# load modules
from modules import MODULE_MAP

# start web server
from mellon.server import web_server #WebServer
#web_server = WebServer(MODULE_MAP, **config.server)

# welcome message
logger.info(f"""\x1b[33;20m
╔══════════════════════╗
║  Welcome to Mellon!  ║
╚══════════════════════╝\x1b[0m
Speak Friend and Enter: http://{config.server['host']}:{config.server['port']}""")

# Engage!
web_server.run()



================================================================================
FILE: mellon/NodeBase.py
================================================================================

import logging
logger = logging.getLogger('mellon')
from modules import MODULE_MAP
import torch
import time
from utils.memory_manager import memory_flush, memory_manager
from mellon.server import web_server
import nanoid
import numpy as np

def get_module_params(module_name, class_name):
    params = MODULE_MAP[module_name][class_name]['params'] if module_name in MODULE_MAP and class_name in MODULE_MAP[module_name] else {}
    return { p: params[p]['default'] if 'default' in params[p] else None
            for p in params if not 'display' in params[p] or (params[p]['display'] != 'output' and params[p]['display'] != 'ui') }

def get_module_output(module_name, class_name):
    params = MODULE_MAP[module_name][class_name]['params'] if module_name in MODULE_MAP and class_name in MODULE_MAP[module_name] else {}
    return { p: None for p in params if 'display' in params[p] and params[p]['display'] == 'output' }

def filter_params(params, args):
    return { key: args[key] for key in args if key in params }

def has_changed(params, args):
    return any(params.get(key) != args.get(key) for key in args if key in params)

def are_different(a, b):
    # quick identity check
    if a is b:
        return False

    # check if the types are different
    if type(a) != type(b):
        return True

    # check custom hash, this value is king
    if hasattr(a, "_MELLON_HASH") and hasattr(b, "_MELLON_HASH"):
       return hasattr(a, "_MELLON_HASH") != hasattr(b, "_MELLON_HASH")
    
    # common attributes
    if hasattr(a, 'shape'):
        if a.shape != b.shape:
            return True
    if hasattr(a, 'dtype'):
        if not hasattr(b, 'dtype') or a.dtype != b.dtype:
            return True

    # quick image comparison
    if hasattr(a, 'size'):
        if a.size != b.size:
            return True
    if hasattr(a, 'mode'):
        if a.mode != b.mode:
            return True

    # deep PIL images comparison
    if hasattr(a, 'getdata') and hasattr(a, 'width') and hasattr(a, 'height'):
        # compare small images with tobytes(), possibly unnecessary optimization
        if a.width*a.height < 32768:
            return a.tobytes() != b.tobytes()
        return not np.array_equal(np.asarray(a), np.asarray(b))

    # trimesh comparison
    if hasattr(a, 'vertices') and hasattr(a.vertices, 'shape'):
        if are_different(a.vertices, b.vertices):
            return True
        if hasattr(a, 'visual') and hasattr(a.visual, 'material') and hasattr(a.visual.material, 'image'):
            if are_different(a.visual.material.image, b.visual.material.image):
                return True
        if hasattr(a, 'faces') and hasattr(a.faces, 'shape'):
            if are_different(a.faces, b.faces):
                return True
        # we assume that the mesh is the same if the vertices, faces and material are the same
        # TODO: check if this is correct
        return False

    # compare numpy arrays
    if isinstance(a, np.ndarray):
        return not np.array_equal(a, b)

    # compare tensors
    if isinstance(a, torch.Tensor):
        return not torch.equal(a, b)

    # iterate list, tuple, dict
    if isinstance(a, (list, tuple)):
        if len(a) != len(b):
            return True
        return any(are_different(x, y) for x, y in zip(a, b))
    if isinstance(a, dict):
        if a.keys() != b.keys():
            return True
        return any(are_different(a[k], b[k]) for k in a)

    if hasattr(a, 'to_dict'):
        x = a.to_dict()
        y = b.to_dict()
        return any(are_different(x[k], y[k]) for k in x)

    if hasattr(a, '__dict__') and hasattr(b, '__dict__'):
        if a.__dict__ != b.__dict__:
            return True

    if a != b:
        return True

    return False

class NodeBase():
    CALLBACK = 'execute'
    FORCE_UNLOAD = True

    def __init__(self, node_id=None):
        self.node_id = node_id
        self.module_name = self.__class__.__module__.split('.')[-1]
        if 'custom.' in self.__class__.__module__:
            self.module_name = self.module_name + '.custom'
        self.class_name = self.__class__.__name__
        self.params = {}
        self.output = get_module_output(self.module_name, self.class_name)
        
        self._client_id = None
        self._pipe_interrupt = False
        self._mm_model_ids = []
        self._execution_time = 0

    def __call__(self, **kwargs):
        self._pipe_interrupt = False

        # if the node_id is not set, the class was called by the user and it's not part of a workflow,
        # we execute the method directly
        if not self.node_id:
            params = { key: kwargs[key] for key in kwargs if not key.startswith('__') }
            return getattr(self, self.CALLBACK)(**params)

        values = self._validate_params(kwargs)

        execution_time = time.time()

        if self._has_changed(values) or self._is_output_empty():
            self.params.update(values)

            # delete previously loaded models
            # TODO: delete a model only if something changed about it
            if self._mm_model_ids:
                memory_manager.delete_model(self._mm_model_ids, unload=self.FORCE_UNLOAD)
                self._mm_model_ids = []

            try:
                params = { key: self.params[key] for key in self.params if not key.startswith('__') }
                output = getattr(self, self.CALLBACK)(**params)
            except Exception as e:
                self.params = {}
                self.output = get_module_output(self.module_name, self.class_name)
                memory_flush(gc_collect=True)
                raise e

            if isinstance(output, dict):
                # Overwrite output values only for existing keys
                #self.output.update({k: output[k] for k in self.output if k in output})
                self.output = output
            else:
                # If only a single value is returned, assign it to the first output
                first_key = next(iter(self.output))
                self.output[first_key] = output

        self._execution_time = time.time() - execution_time

        # for good measure, flush the memory
        memory_flush()

        return self.output

    def __del__(self):
        del self.params, self.output # TODO: check if this actually works with cuda

        if self._mm_model_ids:
            memory_manager.delete_model(self._mm_model_ids, unload=self.FORCE_UNLOAD)

        memory_flush(gc_collect=True)

    def _validate_params(self, values):
        # get the parameters schema for the module/class
        schema = MODULE_MAP[self.module_name][self.class_name]['params'] if self.module_name in MODULE_MAP and self.class_name in MODULE_MAP[self.module_name] else {}

        # get the default values for the parameters
        defaults = get_module_params(self.module_name, self.class_name)

        # filter out any input args that are not valid parameters and exclude the special fields starting with __
        values = { key: values[key] for key in values if key in defaults and not key.startswith('__') }

        # ensure the values are of the correct type
        for key in values:
            if 'type' in schema[key]:
                # type can be a list, used to allow multiple types with input handles (a helper for the UI)
                # the main type is the first one in the list
                type = (schema[key]['type'][0] if isinstance(schema[key]['type'], list) else schema[key]['type']).lower()

                if type.startswith('int'):
                    values[key] = int(values[key]) if not isinstance(values[key], list) else [int(v) for v in values[key]]
                elif type == 'float':
                    values[key] = float(values[key]) if not isinstance(values[key], list) else [float(v) for v in values[key]]
                elif type.startswith('bool'):
                    values[key] = bool(values[key]) if not isinstance(values[key], list) else [bool(v) for v in values[key]]
                elif type.startswith('str'):
                    values[key] = str(values[key] or '') if not isinstance(values[key], list) else [str(v or '') for v in values[key]]

        # we perform a second pass for cross parameter validation when calling the postProcess function
        for key in values:
            # ensure the value is a valid option (mostly for dropdowns)
            if 'options' in schema[key] and not ('no_validation' in schema[key] and schema[key]['no_validation']):
                options = schema[key]['options']

                # options can be in the format: [ 1, 2, 3 ] or { '1': { }, '2': { }, '3': { } }
                if isinstance(options, list):
                    val = [values[key]] if not isinstance(values[key], list) else values[key]
                    if any(v not in options for v in val):
                        raise ValueError(f"Invalid value for {key}: {values[key]}")
                elif isinstance(options, dict):
                    val = [values[key]] if not isinstance(values[key], list) else values[key]
                    if any(v not in options for v in val):
                        raise ValueError(f"Invalid value for {key}: {values[key]}")
                else:
                    raise ValueError(f"Invalid options for {key}: {options}")

            # call the postProcess function if present
            if 'postProcess' in schema[key]:
                # we pass the value and the entire dict for cross parameter validation
                values[key] = schema[key]['postProcess'](values[key], values)

        # update the default values with the validated values
        defaults.update(values)

        return defaults

    def _has_changed(self, values):
        return any(
            key not in self.params or
            are_different(self.params.get(key), values.get(key))
            for key in values
        )
    
    def _is_output_empty(self):
        return all(value is None for value in self.output.values())
    
    def pipe_callback(self, pipe, step_index, timestep, kwargs):
        import asyncio
        if self.node_id:
            try:
                progress = int((step_index + 1) / pipe._num_timesteps * 100)
                asyncio.run_coroutine_threadsafe(
                    web_server.client_queue.put({
                        "client_id": self._client_id,
                        "data": {
                            "type": "progress",
                            "nodeId": self.node_id,
                            "progress": progress
                        }
                    }), 
                    web_server.event_loop
                )
            except Exception as e:
                logger.warning(f"Error queuing progress update: {str(e)}")

            # interrupt callback
            if self._pipe_interrupt:
                pipe._interrupt = True

        return kwargs
    
    def mm_add(self, model, model_id=None, device=None, priority=2):
        # if the node_id is not set, the class was called directly and we skip the memory manager
        # it's up to the caller to manage the model
        if not self.node_id:
            return model

        if memory_manager.is_cached(model_id):
            self.mm_update(model_id, model=model, priority=priority)
            return model_id

        model_id = f'{self.node_id}.{model_id}' if model_id else f'{self.node_id}.{nanoid.generate(size=8)}'
        device = device if device else str(model.device)

        self._mm_model_ids.append(model_id)
        return memory_manager.add_model(model, model_id, device=device, priority=priority)

    def mm_get(self, model_id):
        model_id = model_id if isinstance(model_id, str) else model_id._mm_id if hasattr(model_id, '_mm_id') else None
        return memory_manager.get_model(model_id) if model_id else None

    def mm_load(self, model_id, device):
        model_id = model_id if isinstance(model_id, str) else model_id._mm_id if hasattr(model_id, '_mm_id') else None
        return memory_manager.load_model(model_id, device) if model_id else None

    def mm_unload(self, model_id):
        model_id = model_id if isinstance(model_id, str) else model_id._mm_id if hasattr(model_id, '_mm_id') else None
        return memory_manager.unload_model(model_id) if model_id else None

    def mm_update(self, model_id, model=None, priority=None, unload=True):
        model_id = model_id if isinstance(model_id, str) else model_id._mm_id if hasattr(model_id, '_mm_id') else None
        return memory_manager.update_model(model_id, model=model, priority=priority, unload=unload) if model_id else None
    
    def mm_inference(self, func, device, exclude=None, no_grad=False):
        exclude_list = []
        if exclude:
            exclude = [exclude] if not isinstance(exclude, list) else exclude
            for model in exclude:
                if isinstance(model, str):
                    exclude_list.append(model)
                elif hasattr(model, '_mm_id'):
                    exclude_list.append(model._mm_id)

        while True:
            try:
                with torch.inference_mode() if not no_grad else torch.no_grad():
                    return func()
            except torch.OutOfMemoryError as e:
                if memory_manager.unload_next(device, exclude=exclude):
                    continue
                else:
                    raise e
    
    def mm_flash_load(self, model, model_id=None, device='cpu', priority=3):
        model_id = f'{self.node_id}.{model_id}' if model_id else f'{self.node_id}.{nanoid.generate(size=8)}'
        device = device if device else str(model.device)

        return memory_manager.flash_load(model, model_id, device=device, priority=priority)


================================================================================
FILE: mellon/server.py
================================================================================

import logging
logger = logging.getLogger('mellon')
from aiohttp import web, WSMsgType
from aiohttp_cors import setup as cors_setup, ResourceOptions
import json
import nanoid
import io
import base64
import re
from importlib import import_module
import asyncio
import traceback
from utils.memory_manager import memory_flush
from copy import deepcopy
import random
import signal
import time
import os
import gc
from pathlib import Path
import tempfile

def are_different(old_output, new_output):
    """Compare two outputs to determine if they are different."""
    if old_output is None or new_output is None:
        return old_output is not new_output
    if isinstance(old_output, dict) and isinstance(new_output, dict):
        if old_output.keys() != new_output.keys():
            return True
        return any(are_different(old_output[k], new_output[k]) for k in old_output)
    if isinstance(old_output, (list, tuple)) and isinstance(new_output, (list, tuple)):
        if len(old_output) != len(new_output):
            return True
        return any(are_different(o, n) for o, n in zip(old_output, new_output))
    return old_output != new_output

class WebServer:
    def __init__(self, module_map: dict, host: str = "0.0.0.0", port: int = 8080, cors: bool = False, cors_route: str = "*"):
        self.module_map = module_map
        self.node_store = {}
        self.queue = asyncio.Queue()
        self.queue_task = None
        self.host = host
        self.port = port
        self.ws_clients = {}
        self.app = web.Application()
        self.event_loop = None

        self.client_queue = asyncio.Queue()
        self.client_task = None

        self.app.add_routes([web.get('/', self.index),
                             web.get('/nodes', self.nodes),
                             web.get('/view/{format}/{node}/{key}/{index}', self.view),
                             web.get('/view/{format}/{node}/{key}', self.view),
                             web.get('/custom_component/{module}/{component}', self.custom_component),
                             web.get('/custom_assets/{module}/{file_path}', self.custom_assets),
                             web.get('/files', self.list_files),
                             web.post('/data/files', self.upload_file),
                             web.get('/data/files/{filename}', self.get_file),
                             web.delete('/data/files/{filename}', self.delete_file),
                             web.post('/graph', self.graph),
                             web.post('/nodeExecute', self.node_execute),                             
                             web.delete('/clearNodeCache', self.clear_node_cache),
                             web.static('/assets', 'web/assets'),
                             web.get('/favicon.ico', self.favicon),
                             web.get('/ws', self.websocket_handler)])

        if cors:
            cors = cors_setup(self.app, defaults={
                cors_route: ResourceOptions(
                    allow_credentials=True,
                    expose_headers="*",
                    allow_headers="*",
                )
            })

            for route in list(self.app.router.routes()):
                cors.add(route)

    def run(self):
        async def shutdown():
            if hasattr(self, 'is_shutting_down') and self.is_shutting_down:
                return
            self.is_shutting_down = True
            
            logger.info("Received shutdown signal. Namárië!")
            self.shutdown_event.set()

            # Cancel all running tasks except the current one
            tasks = [t for t in asyncio.all_tasks() if t is not asyncio.current_task()]
            for task in tasks:
                task.cancel()

            #try:
                # Wait for all tasks to finish
            await asyncio.gather(*tasks, return_exceptions=True)
            #except asyncio.CancelledError:
                #pass  # Ignore cancelled error during shutdown

            # Close all websocket connections
            for ws in list(self.ws_clients.values()):
                try:
                    await ws.close(code=1000, message=b'Server shutting down')
                except Exception:
                    pass  # Ignore any websocket closing errors
            self.ws_clients.clear()

        async def start_app():
            self.shutdown_event = asyncio.Event()
            self.event_loop = asyncio.get_event_loop()
            self.is_shutting_down = False

            # Set up signal handlers
            def signal_handler():
                if not self.is_shutting_down:
                    asyncio.create_task(shutdown())

            try:
                for sig in (signal.SIGINT, signal.SIGTERM):
                    self.event_loop.add_signal_handler(sig, signal_handler)
            except NotImplementedError:
                # For Windows compatibility
                pass

            runner = web.AppRunner(self.app, client_max_size=1024**4)
            await runner.setup()
            site = web.TCPSite(runner, self.host, self.port)

            # Start background tasks
            self.queue_task = asyncio.create_task(self.process_queue())
            self.client_task = asyncio.create_task(self.process_client_messages())

            await site.start()

            try:
                await self.shutdown_event.wait()
            finally:
                await shutdown()
                await runner.cleanup()

        try:
            asyncio.run(start_app())
        except KeyboardInterrupt:
            # On Windows, asyncio.run() may not handle KeyboardInterrupt properly
            pass
        except asyncio.CancelledError:
            pass  # Ignore cancelled error during shutdown

    async def process_client_messages(self):
        while True:
            message = await self.client_queue.get()
            try:
                await self.ws_clients[message["client_id"]].send_json(message["data"])
            except Exception as e:
                logger.error(f"Error sending client message: {str(e)}")
            finally:
                self.client_queue.task_done()

    async def process_queue(self):
        while True:
            item = await self.queue.get()
            try:
                if "kwargs" in item:
                    await self.node_execute_single(item)
                else:
                    await self.graph_execution(item)
            except Exception as e:
                logger.error(f"Error processing queue task: {str(e)}")
                logger.error(f"Error occurred in {traceback.format_exc()}")
                await self.broadcast({
                    "type": "error",
                    "error": "An unexpected error occurred while processing the graph"
                })
            finally:
                self.queue.task_done()

    async def index(self, request):
        response = web.FileResponse('web/index.html')
        response.headers["Cache-Control"] = "no-cache"
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "0"
        return response

    async def favicon(self, request):
        return web.FileResponse('web/favicon.ico')

    """
    HTTP API
    """

    async def custom_component(self, request):
        module = request.match_info.get('module')
        component = request.match_info.get('component')

        path = component.split('/')
        if len(path) > 1:
            module = path[0]
            component = path[1]

        #if module not in self.module_map:
        #    raise web.HTTPNotFound(text=f"Module {module} not found")

        response = web.FileResponse(f'custom/{module}/web/{component}.js')
        response.headers["Content-Type"] = "application/javascript"
        response.headers["Cache-Control"] = "no-cache"
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "0"
        return response

    async def custom_assets(self, request):
        module = request.match_info.get('module')
        file_path = request.match_info.get('file_path')

        #if module not in self.module_map:
        #    raise web.HTTPNotFound(text=f"Module {module} not found")

        return web.FileResponse(f'custom/{module}/web/assets/{file_path}')

    async def nodes(self, request):
        nodes = {}
        for module_name, actions in self.module_map.items():
            for action_name, action in actions.items():
                params = {}
                groups = {}
                if 'params' in action:
                    params = deepcopy(action['params'])

                    for p in params:
                        # remove attributes that are not needed by the client
                        if 'postProcess' in params[p]:
                            del params[p]['postProcess']

                nodes[f"{module_name}-{action_name}"] = {
                    "label": action.get('label', f"{module_name}: {action_name}"),
                    "module": module_name,
                    "action": action_name,
                    "category": self.slugify(action.get('category', 'default')),
                    "execution_type": action.get('execution_type', 'workflow'),
                    "params": params,
                    "groups": groups,
                }
                if 'style' in action:
                    nodes[f"{module_name}-{action_name}"]["style"] = action['style']
                if 'resizable' in action:
                    nodes[f"{module_name}-{action_name}"]["resizable"] = action['resizable']
                if 'type' in action:
                    nodes[f"{module_name}-{action_name}"]["type"] = action['type']

        return web.json_response(nodes)
    
    async def view(self, request):
        allowed_formats = ['webp', 'png', 'jpeg', 'glb', 'text']

        format = request.match_info.get('format', 'webp').lower()
        if format not in allowed_formats:
            raise web.HTTPNotFound(text=f"Invalid format: {format}")

        nodeId = request.match_info.get('node')
        key = request.match_info.get('key')
        node = self.node_store.get(nodeId)

        if node is None:
            raise web.HTTPNotFound(text=f"Node {nodeId} not found")
        if key not in node.output:
            raise web.HTTPNotFound(text=f"Key {key} not found in node {nodeId}")   
        
        value = node.output[key]
        if value is None:
            raise web.HTTPNotFound(text=f"No data found for {key}")
        
        if not isinstance(value, list):
            value = [value]

        index = int(request.match_info.get("index", 0))
        if index < 0 or index >= len(value):
            raise web.HTTPNotFound(text=f"Index {index} out of bounds for {key}")
        
        # get additional request parameters
        quality = int(request.rel_url.query.get("quality", 100))
        quality = max(0, min(100, quality))
        scale = float(request.rel_url.query.get("scale", 1))
        scale = max(0.01, min(2, scale))
        filename = request.rel_url.query.get("filename", f"{key}_{index}.{format}")

        value = value[index]
        if scale != 1:
            from PIL.Image import Resampling
            width = int(value.width * scale)
            height = int(value.height * scale)
            value = value.resize((max(width, 1), max(height, 1)), resample=Resampling.BICUBIC)

        # return the value as image
        if format == "webp" or format == "png" or format == "jpeg":
            byte_arr = io.BytesIO()
            value.save(byte_arr, format=format.upper(), quality=quality)
            byte_arr = byte_arr.getvalue()
            return web.Response(
                body=byte_arr,
                content_type="image/webp",
                headers={
                    "Content-Disposition": f"inline; filename={filename}",
                    "Content-Length": str(len(byte_arr)),
                    "Cache-Control": "max-age=31536000, immutable",
                }
            )
        elif format == "glb":
            byte_arr = io.BytesIO()
            byte_arr.write(value)
            byte_arr = byte_arr.getvalue()
            return web.Response(
                body=byte_arr,
                content_type="model/glb",
                headers={
                    "Content-Disposition": f"inline; filename={key}.glb",
                    "Content-Length": str(len(byte_arr)),
                    "Cache-Control": "max-age=31536000, immutable",
                }
            )
        elif format == "text":
            return web.json_response({ "data": value })

    async def clear_node_cache(self, request):
        data = await request.json()
        nodeId = []

        if "nodeId" in data:
            nodeId = data["nodeId"] if isinstance(data["nodeId"], list) else [data["nodeId"]]
        else:
            nodeId = list(self.node_store.keys())

        for node in nodeId:
            if node in self.node_store:
                self.node_store[node] = None
                del self.node_store[node]

        memory_flush(gc_collect=True)

        return web.json_response({
            "type": "cacheCleared",
            "nodeId": nodeId
        })

    async def graph(self, request):
        graph = await request.json()
        await self.queue.put(graph)
        return web.json_response({
            "type": "graphQueued",
            "sid": graph["sid"]
        })

    async def node_execute(self, request):
        data = await request.json()
        await self.queue.put(data)
        return web.json_response({
            "type": "nodeQueued",
            "sid": data["sid"],
        })

    async def node_execute_single(self, data):
        sid = data["sid"]
        module = data["module"]
        action = data["action"]
        kwargs = data["kwargs"]
        node = data["node"]

        if module not in self.module_map:
            raise ValueError("Invalid module")
        if action not in self.module_map[module]:
            raise ValueError("Invalid action")

        if module.endswith(".custom"):
            module = import_module(f"custom.{module.replace('.custom', '')}.{module.replace('.custom', '')}")
        else:
            module = import_module(f"modules.{module}.{module}")
        action = getattr(module, action)

        if not callable(action):
            raise ValueError("Action is not callable")

        node = action()
        node._client_id = sid

        result = {}

        try:
            result = await self.event_loop.run_in_executor(None, lambda: node(**kwargs))
        except Exception as e:
            logger.error(f"Error executing node {module}.{action}: {str(e)}")
            raise e

        await self.client_queue.put({
            "client_id": sid,
            "data": {
                "type": "single_executed",
                "nodeId": node,
                "module": module,
                "action": action,
                "result": result,
            }
        })

    async def graph_execution(self, graph):
        sid = graph["sid"]
        nodes = graph["nodes"]
        paths = graph["paths"]
        
        print(f"\n=== Starting graph execution with SID: {sid} ===")
        print(f"Number of nodes: {len(nodes)}")
        print(f"Number of paths: {len(paths)}")

        randomized_fields = {}
        for path_index, path in enumerate(paths):
            print(f"\n--- Processing path {path_index + 1}/{len(paths)} ---")
            for node in path:
                module_name = nodes[node]["module"]
                action_name = nodes[node]["action"]
                print(f"\nExecuting node: {node}")
                print(f"Module: {module_name}, Action: {action_name}")
                logger.debug(f"Executing node {module_name}.{action_name}")

                # Store old output for comparison
                old_output = deepcopy(self.node_store[node].output) if node in self.node_store else None
                print(f"Previous output exists: {old_output is not None}")

                params = nodes[node]["params"]
                print(f"Parameters: {params}")
                ui_fields = {}
                args = {}
                for p in params:
                    source_id = params[p].get("sourceId")
                    source_key = params[p].get("sourceKey")
                    print(f"\nProcessing parameter: {p}")
                    print(f"Source ID: {source_id}, Source Key: {source_key}")

                    if "display" in params[p] and params[p]["display"] == "ui":
                        print(f"UI field detected: {p} with type {params[p]['type']}")
                        # store ui fields that need to be sent back to the client
                        if params[p]["type"] == "image" or params[p]["type"] == "3d" or params[p]["type"] == "text":
                            ui_fields[p] = { "source": source_key, "type": params[p]["type"] }
                    else:
                        # handle list values (spawn input fields)
                        # if p ends with [d+], it means that the field is part of a list
                        if source_id and re.match(r".*\[\d+\]$", p):
                            print(f"List field detected: {p}")
                            spawn_key = re.sub(r"\[\d+\]$", "", p)
                            if not args.get(spawn_key):
                                args[spawn_key] = []
                            elif not isinstance(args[spawn_key], list):
                                args[spawn_key] = [args[spawn_key]]

                            args[spawn_key].append(self.node_store[source_id].output[source_key])
                        else:
                            # if there is a source id, it means that the value comes from a pipeline,
                            # so we follow the connection to the source node and get the associated value
                            # Otherwise we use the value in the params
                            args[p] = self.node_store[source_id].output[source_key] if source_id else params[p].get("value")
                            print(f"Regular field: {p} = {args[p]}")

                print(f"\nFinal arguments for node execution: {args}")
                print(f"UI fields to update: {ui_fields}")

                # check if there is a field with the name __random__<param>
                # randomize the field unless it has been already randomized
                for key in args:
                    if key.startswith('__random__') and args[key] is True:
                        print(f"\nRandomizing field: {key}")
                        if node not in randomized_fields:
                            randomized_fields[node] = []
                        if key in randomized_fields[node]:
                            print(f"Field {key} already randomized, skipping")
                            continue
                        randomized_fields[node].append(key)

                        random_field = key.split('__random__')[1]
                        args[random_field] = random.randint(0, (1<<53)-1) # TODO: allow min/max values
                        params[random_field]["value"] = args[random_field]
                        print(f"New random value for {random_field}: {args[random_field]}")
                        await self.client_queue.put({
                            "client_id": sid,
                            "data": {
                                "type": "updateValues",
                                "nodeId": node,
                                "key": random_field,
                                "value": args[random_field]
                            }
                        })

                if module_name not in self.module_map:
                    raise ValueError("Invalid module")
                if action_name not in self.module_map[module_name]:
                    raise ValueError("Invalid action")

                # import the module and get the action
                if module_name.endswith(".custom"):
                    print(f"\nImporting custom module: {module_name}")
                    module = import_module(f"custom.{module_name.replace('.custom', '')}.{module_name.replace('.custom', '')}")
                else:
                    print(f"\nImporting standard module: {module_name}")
                    module = import_module(f"modules.{module_name}.{module_name}")
                action = getattr(module, action_name)

                # if the node is not in the node store, initialize it
                if node not in self.node_store:
                    print(f"Initializing new node in store: {node}")
                    self.node_store[node] = action(node)

                self.node_store[node]._client_id = sid

                if not callable(self.node_store[node]):
                    raise TypeError(f"The class `{module_name}.{action_name}` is not callable. Ensure that the class has a __call__ method or extend it from `NodeBase`.")

                # initialize the progress bar
                print("\nStarting node execution...")
                await self.client_queue.put({
                    "client_id": sid,
                    "data": {
                        "type": "progress",
                        "nodeId": node,
                        "progress": -1
                    }
                })

                try:
                    def execute_node():
                        try:
                            return self.node_store[node](**args)
                        except StopIteration:
                            return None
                            
                    result = await self.event_loop.run_in_executor(None, execute_node)
                    print(f"Node execution completed with result type: {type(result)}")
                except Exception as e:
                    print(f"Error executing node: {str(e)}")
                    logger.error(f"Error executing node {module_name}.{action_name}: {str(e)}")
                    raise e

                # Get execution type and compare outputs for continuous nodes
                exec_type = self.module_map[module_name][action_name].get("execution_type", "workflow")
                print(f"\nExecution type: {exec_type}")
                if exec_type == "continuous":
                    new_output = self.node_store[node].output
                    if not are_different(old_output, new_output):
                        # If identical output, skip sending updates but still mark as executed
                        print("Output unchanged, skipping updates")
                        logger.debug(f"Skipping updates for node {node} - output unchanged")
                        execution_time = self.node_store[node]._execution_time if hasattr(self.node_store[node], '_execution_time') else 0
                        await self.client_queue.put({
                            "client_id": sid,
                            "data": {
                                "type": "executed",
                                "nodeId": node,
                                "time": f"{execution_time:.2f}",
                            }
                        })
                        continue

                execution_time = self.node_store[node]._execution_time if hasattr(self.node_store[node], '_execution_time') else 0
                print(f"Execution time: {execution_time:.2f}s")

                await self.client_queue.put({
                    "client_id": sid,
                    "data": {
                        "type": "executed",
                        "nodeId": node,
                        "time": f"{execution_time:.2f}",
                    }
                })

                logger.debug(f"Node {module_name}.{action_name} executed in {execution_time:.3f}s")

                for key in ui_fields:
                    print(f"\nProcessing UI field: {key}")
                    source = ui_fields[key]["source"]
                    source_value = self.node_store[node].output[source]
                    length = len(source_value) if isinstance(source_value, list) else 1
                    format = ui_fields[key]["type"]
                    if format == "image":
                        format = 'webp'
                    elif format == "3d":
                        format = 'glb'
                    elif format == "video":
                        format = 'mp4'
                    else:
                        format = 'text'
                    print(f"Format: {format}, Length: {length}")
                    data = []
                    if format == 'text':
                        data = {
                            "url": f"/view/{format}/{node}/{source}/{0}?t={time.time()}",
                            "value": source_value
                        }
                    else:
                        for i in range(length):
                            if format == 'image':
                                if length > 1:
                                    scale = 0.5 if source_value[i].width > 1024 or source_value[i].height > 1024 else 1
                                else:
                                    scale = 0.5 if source_value[i].width > 2048 or source_value[i].height > 2048 else 1
                                url = f"/view/{format}/{node}/{source}/{i}?scale={scale}&t={time.time()}"
                                data.append({
                                    "url": url,
                                    "width": source_value[i].width,
                                    "height": source_value[i].height
                                })
                            else:
                                url = f"/view/{format}/{node}/{source}/{i}?t={time.time()}"
                                data.append({
                                    "url": url,
                                })

                    print(f"Sending UI update for {key}")
                    await self.client_queue.put({
                        "client_id": sid,
                        "data": {
                            "type": ui_fields[key]["type"],
                            "key": key,
                            "nodeId": node,
                            "data": data
                        }
                    })

                await asyncio.sleep(0)
                print(f"\n=== Completed node {node} ===")

        print("\n=== Graph execution completed ===")

    async def list_files(self, request):
        # Get the requested path from query params, default to data/files
        path = request.query.get('path', '')
        if not path:
            path = os.path.join('data', 'files')
        
        # Ensure the path exists and create if it doesn't
        os.makedirs(path, exist_ok=True)

        # Security check - ensure path is within allowed directory
        try:
            requested_path = Path(path).resolve()
            base_path = Path('data/files').resolve()
            if not str(requested_path).startswith(str(base_path)) and path != 'data/files':
                raise web.HTTPForbidden(text="Access to this directory is not allowed")
        except (ValueError, RuntimeError):
            raise web.HTTPBadRequest(text="Invalid path")

        try:
            # List directory contents
            entries = []
            with os.scandir(path) as it:
                for entry in it:
                    entries.append({
                        'name': entry.name,
                        'isDirectory': entry.is_dir(),
                        'path': os.path.join(path, entry.name).replace('\\', '/')
                    })
            
            # Sort directories first, then files, both alphabetically
            entries.sort(key=lambda x: (not x['isDirectory'], x['name'].lower()))
            
            return web.json_response({
                'files': entries,
                'currentPath': path.replace('\\', '/')
            })
        except Exception as e:
            raise web.HTTPInternalServerError(text=str(e))

    async def upload_file(self, request):
        """Handle file uploads to data/files directory."""
        temp_file = None
        try:
            reader = await request.multipart()
            
            file_field = await reader.next()
            if file_field is None or file_field.name != 'file':
                raise web.HTTPBadRequest(text="No valid file provided")
            
            filename = file_field.filename
            if not filename:
                raise web.HTTPBadRequest(text="No filename provided")
            
            save_path = os.path.join(os.getcwd(), 'data', 'files')
            os.makedirs(save_path, exist_ok=True)
            
            # Create a temporary file first
            fd, temp_path = tempfile.mkstemp(dir=save_path)
            temp_file = os.fdopen(fd, 'wb')
            
            size = 0
            try:
                while True:
                    chunk = await file_field.read_chunk(size=8*1024*1024)
                    if not chunk:
                        break
                    size += len(chunk)
                    temp_file.write(chunk)
                    if size % (64*1024*1024) == 0:
                        temp_file.flush()
                        os.fsync(temp_file.fileno())
                temp_file.flush()
                os.fsync(temp_file.fileno())
            finally:
                temp_file.close()
            
            # Get custom filename if provided
            custom_filename = None
            next_field = await reader.next()
            if next_field and next_field.name == 'filename':
                custom_filename = await next_field.text()
            
            # Generate final filename with proper extension
            base_filename = custom_filename or filename
            original_name, original_ext = os.path.splitext(filename)
            
            if custom_filename:
                custom_name, custom_ext = os.path.splitext(custom_filename)
                # If custom filename has no extension, use original file's extension
                if not custom_ext:
                    base_filename = custom_name + original_ext
            
            # Generate unique filename by adding counter if needed
            counter = 1
            final_filename = base_filename
            while os.path.exists(os.path.join(save_path, final_filename)):
                name, ext = os.path.splitext(base_filename)
                final_filename = f"{name}_{counter}{ext}"
                counter += 1
            
            final_path = os.path.join(save_path, final_filename)
            
            # Atomically move the temporary file to its final location
            os.rename(temp_path, final_path)
            
            return web.Response(text=final_filename)
            
        except Exception as e:
            # Clean up temporary file if something went wrong
            if temp_file:
                temp_file.close()
                if os.path.exists(temp_path):
                    try:
                        os.remove(temp_path)
                    except Exception:
                        pass
            raise web.HTTPInternalServerError(text=str(e))

    async def get_file(self, request):
        """Serve files from data/files directory."""
        try:
            filename = request.match_info['filename']
            file_path = os.path.join(os.getcwd(), 'data', 'files', filename)
            
            logger.info(f"Attempting to serve file: {file_path}")
            
            if not os.path.exists(file_path):
                logger.error(f"File not found: {file_path}")
                raise web.HTTPNotFound(text=f"File not found: {filename}")
            
            # Check if file is readable
            if not os.access(file_path, os.R_OK):
                logger.error(f"File not readable: {file_path}")
                raise web.HTTPForbidden(text=f"File not readable: {filename}")
                
            file_size = os.path.getsize(file_path)
            logger.info(f"File exists and is readable. Size: {file_size} bytes")

            # For MP4 files, use direct file reading instead of FileResponse
            if filename.lower().endswith('.mp4'):
                with open(file_path, 'rb') as f:
                    data = f.read()
                
                response = web.Response(
                    body=data,
                    content_type='video/mp4',
                    headers={
                        "Content-Length": str(file_size),
                        "Accept-Ranges": "bytes",
                        "Cache-Control": "no-cache, no-store, must-revalidate",
                        "Pragma": "no-cache",
                        "Expires": "0"
                    }
                )
                logger.info("Serving MP4 file directly")
                return response
            
            # For all other files, use FileResponse
            response = web.FileResponse(file_path)
            response.headers["Cache-Control"] = "no-cache, no-store, must-revalidate"
            response.headers["Pragma"] = "no-cache"
            response.headers["Expires"] = "0"
            response.headers["Content-Length"] = str(file_size)
            
            logger.info(f"Serving file with headers: {dict(response.headers)}")
            return response
            
        except web.HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error serving file: {str(e)}")
            raise web.HTTPInternalServerError(text=str(e))

    async def delete_file(self, request):
        """Delete files from data/files directory."""
        try:
            filename = request.match_info['filename']
            file_path = os.path.join(os.getcwd(), 'data', 'files', filename)
            
            if not os.path.exists(file_path):
                raise web.HTTPNotFound(text=f"File not found: {filename}")
            
            os.remove(file_path)
            return web.Response(text=f"File {filename} deleted successfully")
            
        except web.HTTPException:
            raise
        except Exception as e:
            logger.error(f"Error deleting file: {str(e)}")
            raise web.HTTPInternalServerError(text=str(e))

    """
    WebSocket API
    """

    async def websocket_handler(self, request):
        ws = web.WebSocketResponse()
        await ws.prepare(request)
        sid = request.query.get("sid")
        logger.info(f"WebSocket connection with sid {sid}")
        if sid:
            if sid in self.ws_clients:
                del self.ws_clients[sid]
        else:
            # if the client does not provide a session id, we create one for them one
            sid = nanoid.generate(size=10)

        self.ws_clients[sid] = ws
        await ws.send_json({"type": "welcome", "sid": sid})

        async for msg in ws:
            if msg.type == WSMsgType.TEXT:
                data = json.loads(msg.data)

                try:
                    if data["type"] == "ping":
                        await ws.send_json({"type": "pong"})
                    elif data["type"] == "close":
                        await ws.close()
                        break
                        """
                    elif data["type"] == "module":
                        module_name = data["module"]
                        action_name = data["action"]
                        params = data["data"] if "data" in data else {}

                        if module_name not in self.module_map or action_name not in self.module_map[module_name]:
                            raise ValueError("Invalid module or action")

                        module = import_module(f"modules.{module_name}.{module_name}")
                        action = getattr(module, action_name)
                        result = await action(**params)
                        await ws.send_json({"type": "result", "result": result})

                    elif data["type"] == "graph":
                        graph = data["graph"]
                        for node in graph["nodes"]:
                            module_name = node["module"]
                            action_name = node["action"]
                            params = node["params"]
                            module = import_module(f"modules.{module_name}.{module_name}")
                            action = getattr(module, action_name)
                            result = await action(**params)
                            await ws.send_json({"type": "result", "result": result})
                        """
                    else:
                        raise ValueError("Invalid message type")

                #except KeyError as e:
                #    await ws.send_json({"type": "error", "message": f"Missing required field: {str(e)}"})
                #except ValueError as e:
                #    await ws.send_json({"type": "error", "message": str(e)})
                except Exception as e:
                    logger.error(f"Unexpected error: {str(e)}")
                    await ws.send_json({"type": "error", "message": "An unexpected error occurred"})

            elif msg.type == WSMsgType.ERROR:
                logger.error(f'WebSocket connection closed with exception {ws.exception()}')

        del self.ws_clients[sid]
        logger.info(f'WebSocket connection {sid} closed')

        return ws

    async def broadcast(self, message, client_id=None):
        if client_id:
            if client_id not in self.ws_clients:
                return
            ws_clients = [client_id] if not isinstance(client_id, list) else client_id
        else:
            ws_clients = self.ws_clients

        for client in ws_clients:
            await self.ws_clients[client].send_json(message)


    """
    Helper functions
    """
    def to_base64(self, type, value):
        if type == "image":
            img_byte_arr = io.BytesIO()
            value.save(img_byte_arr, format='WEBP', quality=100)
            img_byte_arr = img_byte_arr.getvalue()
            return base64.b64encode(img_byte_arr).decode('utf-8')
        elif type == "3d":
            glb_byte_arr = io.BytesIO()
            glb_byte_arr.write(value)
            glb_byte_arr = glb_byte_arr.getvalue()
            return base64.b64encode(glb_byte_arr).decode('utf-8')

    def slugify(self, text):
        return re.sub(r'[^\w\s-]', '', text).strip().replace(' ', '-')

from modules import MODULE_MAP
from config import config

web_server = WebServer(MODULE_MAP, **config.server)


================================================================================
FILE: modules/Text/Text.py
================================================================================

from mellon.NodeBase import NodeBase
import torch
import gc
import os
import time
import csv
import glob
import uuid
import numpy as np
from PIL import Image, ImageDraw, ImageFont
from torch.cuda import max_memory_allocated, synchronize
from diffusers import FlowMatchEulerDiscreteScheduler, AutoencoderKL, FluxPriorReduxPipeline
from diffusers.models.transformers.transformer_flux import FluxTransformer2DModel
from diffusers.pipelines.flux.pipeline_flux import FluxPipeline
from diffusers.utils import load_image
from transformers import CLIPTextModel, CLIPTokenizer, T5EncoderModel, T5TokenizerFast
from functools import wraps
from typing import List, Dict, Tuple, Optional
from huggingface_hub import login

##
# Other Node classes remain as before
##
class Text(NodeBase):
    def execute(self, text_field):
        return text_field

class Text2(NodeBase):
    def execute(self, text_field):
        return text_field

class DisplayText(NodeBase):
    def execute(self, text_in, text_in_2, video_display):
        print(text_in+text_in_2)
        return {"text_out": text_in + text_in_2, "video_out": "data.mp4"}

class LoadAudio(NodeBase):
    def execute(self, audio_file):
        return audio_file

class Timeline(NodeBase):
    def execute(self, audio_file, timestamps):
        return {"audio_file_out": audio_file, "timestamps_out": timestamps}

class FluxTravelBase:
    """
    Utility class containing shared functionality for FluxTravel nodes.
    All methods are class methods to avoid initialization issues.
    """
    @classmethod
    def timing_decorator(cls, func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start = time.time()
            result = func(*args, **kwargs)
            duration = time.time() - start
            print(f"{func.__name__}: {duration:.2f}s")
            return result
        return wrapper

    @classmethod
    def add_timing_to_pipeline(cls, pipe):
        if hasattr(pipe, 'encode_image'):
            pipe.encode_image = cls.timing_decorator(pipe.encode_image)
        if hasattr(pipe, 'encode_prompt'):
            pipe.encode_prompt = cls.timing_decorator(pipe.encode_prompt)
        if hasattr(pipe, 'vae_encode'):
            pipe.vae_encode = cls.timing_decorator(pipe.vae_encode)
        return pipe

    @staticmethod
    def setup_pipeline():
        """
        Sets up the pipeline objects (FluxPipeline, prior, etc.).
        """
        dtype = torch.bfloat16
        bfl_repo = "black-forest-labs/FLUX.1-schnell"
        revision = "refs/pr/1"

        scheduler = FlowMatchEulerDiscreteScheduler.from_pretrained(
            bfl_repo, subfolder="scheduler", revision=revision
        )
        text_encoder = CLIPTextModel.from_pretrained(
            "openai/clip-vit-large-patch14", torch_dtype=dtype
        )
        tokenizer = CLIPTokenizer.from_pretrained(
            "openai/clip-vit-large-patch14", torch_dtype=dtype
        )
        text_encoder_2 = T5EncoderModel.from_pretrained(
            bfl_repo, subfolder="text_encoder_2", torch_dtype=dtype, revision=revision
        )
        tokenizer_2 = T5TokenizerFast.from_pretrained(
            bfl_repo, subfolder="tokenizer_2", torch_dtype=dtype, revision=revision
        )
        vae = AutoencoderKL.from_pretrained(
            bfl_repo, subfolder="vae", torch_dtype=dtype, revision=revision
        )
        transformer = FluxTransformer2DModel.from_pretrained(
            bfl_repo, subfolder="transformer", torch_dtype=dtype, revision=revision
        )

        pipe = FluxPipeline(
            scheduler=scheduler,
            text_encoder=text_encoder,
            tokenizer=tokenizer,
            text_encoder_2=None,
            tokenizer_2=tokenizer_2,
            vae=vae,
            transformer=None,
        )
        pipe.text_encoder_2 = text_encoder_2
        pipe.transformer = transformer
        pipe.enable_model_cpu_offload()

        pipe = FluxTravelBase.add_timing_to_pipeline(pipe)

        # Also load the Redux pipeline
        repo_redux = "black-forest-labs/FLUX.1-Redux-dev"
        pipe_prior_redux = FluxPriorReduxPipeline.from_pretrained(repo_redux, torch_dtype=dtype)
        pipe_prior_redux = FluxTravelBase.add_timing_to_pipeline(pipe_prior_redux)

        return pipe, pipe_prior_redux, dtype

    @staticmethod
    def slerp(val, low, high, eps=1e-6):
        """
        Spherical linear interpolation.
        """
        low_norm = low / (torch.norm(low, dim=-1, keepdim=True) + eps)
        high_norm = high / (torch.norm(high, dim=-1, keepdim=True) + eps)
        dot = (low_norm * high_norm).sum(-1, keepdim=True)
        dot = torch.clamp(dot, -1.0, 1.0)
        omega = torch.acos(dot)
        so = torch.sin(omega)
        return torch.where(
            so < eps,
            (1.0 - val) * low + val * high,
            ((torch.sin((1.0 - val) * omega) / so) * low +
             (torch.sin(val * omega) / so) * high)
        )

    @classmethod
    def blend_embeddings(cls, embeddings: List[Tuple[torch.Tensor, float]], blend_mode: str = 'linear') -> torch.Tensor:
        """
        Blend multiple embeddings according to strengths.
        """
        if blend_mode == 'linear':
            total = sum(strength for _, strength in embeddings)
            return sum(emb * (strength / total) for emb, strength in embeddings)
        elif blend_mode == 'slerp':
            # If only two embeddings, do a single slerp
            if len(embeddings) == 2:
                emb1, strength1 = embeddings[0]
                emb2, strength2 = embeddings[1]
                total = strength1 + strength2
                val = strength2 / total
                return cls.slerp(val, emb1, emb2)
            else:
                # Fallback if 3+ embeddings with slerp
                total = sum(strength for _, strength in embeddings)
                strengths = [strength / total for _, strength in embeddings]
                val1 = strengths[1] / (strengths[0] + strengths[1])
                intermediate = cls.slerp(val1, embeddings[0][0], embeddings[1][0])
                val2 = strengths[2]
                return cls.slerp(val2, intermediate, embeddings[2][0])
        else:
            raise ValueError(f"Unknown blend mode: {blend_mode}")

    @staticmethod
    def linear_interpolate(x1, y1, x2, y2, x):
        if abs(x2 - x1) < 1e-9:
            return y1
        ratio = (x - x1) / (x2 - x1)
        return y1 + ratio * (y2 - y1)

    @classmethod
    def generate_strength_data(cls, image_names, timestamps, fps, peak_strength,
                               low_strength, blend_amount):
        """
        Generate a list of dictionaries: each dict has frame #, time, and
        an array of strengths for each image.
        """
        N = len(image_names)
        boundaries = []

        # Calculate left/right boundaries for each image
        for i in range(N):
            if i == 0:
                lb = timestamps[0]
                rb = timestamps[0] + blend_amount * (timestamps[1] - timestamps[0]) if N > 1 else timestamps[0]
            elif i < N - 1:
                lb = timestamps[i] - blend_amount * (timestamps[i] - timestamps[i - 1])
                rb = timestamps[i] + blend_amount * (timestamps[i + 1] - timestamps[i])
            else:
                # Last image
                lb = timestamps[i] - blend_amount * (timestamps[i] - timestamps[i - 1])
                rb = timestamps[i]
            boundaries.append((lb, rb))

        final_timestamp = timestamps[-1]
        total_frames = int(np.ceil(final_timestamp * fps)) + 1

        data = []
        for frame_idx in range(total_frames):
            t = frame_idx / fps
            strengths_for_frame = []
            for i in range(N):
                lb, rb = boundaries[i]
                peak_time = timestamps[i]

                if i == N - 1 and abs(t - final_timestamp) < 1e-9:
                    strengths_for_frame.append(peak_strength)
                    continue

                # Outside active window
                if t < lb or t > rb:
                    strengths_for_frame.append(0.0)
                    continue

                if i == 0:
                    # First image
                    if t <= peak_time:
                        strengths_for_frame.append(peak_strength)
                    else:
                        val = cls.linear_interpolate(peak_time, peak_strength, rb, low_strength, t)
                        strengths_for_frame.append(val)
                elif i == N - 1:
                    # Last image
                    if t <= peak_time:
                        val = cls.linear_interpolate(lb, low_strength, peak_time, peak_strength, t)
                        strengths_for_frame.append(val)
                    else:
                        ramp_down_end = max(final_timestamp - 1.0/fps, peak_time)
                        if t < ramp_down_end:
                            val = cls.linear_interpolate(peak_time, peak_strength, ramp_down_end, low_strength, t)
                            strengths_for_frame.append(val)
                        else:
                            strengths_for_frame.append(low_strength)
                else:
                    # Intermediate images
                    if t <= peak_time:
                        val = cls.linear_interpolate(lb, low_strength, peak_time, peak_strength, t)
                    else:
                        val = cls.linear_interpolate(peak_time, peak_strength, rb, low_strength, t)
                    strengths_for_frame.append(val)

            # Round to 3 decimals
            strengths_for_frame = [float(f"{s:.3f}") for s in strengths_for_frame]
            data.append({
                'frame': frame_idx,
                'time': float(f"{t:.3f}"),
                'strengths': strengths_for_frame
            })

        return data

    @classmethod
    def process_image_batch(cls, image_paths: List[str],
                            pipe,
                            pipe_prior_redux,
                            frames_per_transition: List[int],
                            height: int = 720,
                            width: int = 720,
                            noise_blend_amount: float = 0.1,
                            num_inference_steps: int = 4,
                            guidance_scale: float = 1.5,
                            seed: int = 12345,
                            info_mode: bool = False,
                            low_strength: float = 0.0,
                            peak_strength: float = 1.0,
                            blend_mode: str = 'linear',
                            csv_only: bool = False,
                            blend_amount: float = 1.0):
        """
        Original approach: piecewise interpolation between consecutive images,
        given a fixed number of frames_per_transition between them.
        """
        generator = torch.Generator(device=pipe.device).manual_seed(seed)
        print(f"\nEncoding {len(image_paths)} images...")
        encoded_images = {}
        source_images = {}

        # Encode each image with the "Redux" pipeline
        for img_path in image_paths:
            img_name = os.path.basename(img_path)
            img = load_image(img_path)
            source_images[img_name] = img
            if not csv_only:
                base_output = pipe_prior_redux(
                    img,
                    prompt_embeds_scale=1.0,
                    pooled_prompt_embeds_scale=1.0
                )
                encoded_images[img_name] = {
                    'prompt_embeds': base_output['prompt_embeds'],
                    'pooled_prompt_embeds': base_output['pooled_prompt_embeds']
                }

        results = []
        generation_times = []
        frame_info = [] if info_mode or csv_only else None
        frame_number = 0

        # Generate frames for each pair
        for i in range(len(image_paths) - 1):
            img1_name = os.path.basename(image_paths[i])
            img2_name = os.path.basename(image_paths[i + 1])
            num_frames = frames_per_transition[i] if i < len(frames_per_transition) else frames_per_transition[-1]

            if not csv_only:
                print(f"\nGenerating {num_frames} frames between {img1_name} and {img2_name}")

            previous_latents = None
            for j in range(num_frames):
                # OLD Cosine-based interpolation:
                progress = j / (num_frames - 1) if num_frames > 1 else 0.0
                adjusted_progress = progress ** (1 / blend_amount)
                cos_progress = (1 - np.cos(adjusted_progress * np.pi)) / 2

                strength1 = (1 - cos_progress) * (peak_strength - low_strength) + low_strength
                strength2 = cos_progress * (peak_strength - low_strength) + low_strength
                total = strength1 + strength2
                strength1 /= total
                strength2 /= total

                if frame_info is not None:
                    active_images_paths = [image_paths[i], image_paths[i+1]]
                    active_strengths = [strength1, strength2]

                if not csv_only:
                    # Combine embeddings
                    prompt_embeds_list = [
                        (encoded_images[img1_name]['prompt_embeds'], strength1),
                        (encoded_images[img2_name]['prompt_embeds'], strength2)
                    ]
                    pooled_embeds_list = [
                        (encoded_images[img1_name]['pooled_prompt_embeds'], strength1),
                        (encoded_images[img2_name]['pooled_prompt_embeds'], strength2)
                    ]
                    combined_output = {
                        'prompt_embeds': cls.blend_embeddings(prompt_embeds_list, blend_mode),
                        'pooled_prompt_embeds': cls.blend_embeddings(pooled_embeds_list, blend_mode)
                    }

                    # Prepare latents
                    if previous_latents is None:
                        latents, _ = pipe.prepare_latents(
                            batch_size=1,
                            num_channels_latents=pipe.transformer.config.in_channels // 4,
                            height=height,
                            width=width,
                            dtype=pipe.dtype,
                            device=pipe.device,
                            generator=generator
                        )
                        batch_size, seq_len, hidden_dim = latents.shape
                        latents = latents.view(batch_size, seq_len, -1)
                    else:
                        new_latents, _ = pipe.prepare_latents(
                            batch_size=1,
                            num_channels_latents=pipe.transformer.config.in_channels // 4,
                            height=height,
                            width=width,
                            dtype=pipe.dtype,
                            device=pipe.device,
                            generator=generator
                        )
                        new_latents = new_latents.view(batch_size, seq_len, -1)
                        if noise_blend_amount is not None:
                            latents = (1 - noise_blend_amount) * previous_latents + noise_blend_amount * new_latents
                        else:
                            latents = previous_latents

                    previous_latents = latents

                    t_start = time.time()
                    image = pipe(
                        width=width,
                        height=height,
                        num_inference_steps=num_inference_steps,
                        guidance_scale=guidance_scale,
                        latents=latents,
                        **combined_output,
                    ).images[0]
                    gen_time = time.time() - t_start

                    if info_mode:
                        image = cls.add_frame_info(
                            image,
                            frame_number,
                            [source_images[os.path.basename(img_path)] for img_path in active_images_paths],
                            active_strengths
                        )

                    results.append(image)
                    generation_times.append(gen_time)

                if frame_info is not None:
                    frame_info_dict = {'frame': frame_number}
                    frame_info_dict[f'image_{i+1}_redux_strength'] = strength1
                    frame_info_dict[f'image_{i+2}_redux_strength'] = strength2
                    frame_info.append(frame_info_dict)

                frame_number += 1
                synchronize()
                gc.collect()
                torch.cuda.empty_cache()
                if not csv_only:
                    print(f"  Frame {j+1}/{num_frames}", end="\r")
            if not csv_only:
                print()  # new line

        return results, generation_times, frame_info

    @classmethod
    def process_timestamped_images(cls,
                                   image_paths: List[str],
                                   timestamps: List[float],
                                   fps: float,
                                   pipe,
                                   pipe_prior_redux,
                                   height: int = 720,
                                   width: int = 720,
                                   noise_blend_amount: float = 0.1,
                                   steps: int = 4,
                                   guidance_scale: float = 1.5,
                                   seed: int = 12345,
                                   info_mode: bool = False,
                                   low_strength: float = 0.0,
                                   peak_strength: float = 1.0,
                                   blend_mode: str = 'linear',
                                   csv_only: bool = False,
                                   blend_amount: float = 1.0):
        """
        Uses the new snippet-based curve to determine strengths for each image,
        given specific timestamps (in seconds).
        """
        if len(image_paths) != len(timestamps):
            raise ValueError("Number of images must match number of timestamps")
        if len(image_paths) < 2:
            raise ValueError("Need at least 2 images to create sequence")
        if not all(timestamps[i] < timestamps[i+1] for i in range(len(timestamps)-1)):
            raise ValueError("Timestamps must be in ascending order")

        generator = torch.Generator(device=pipe.device).manual_seed(seed)

        print(f"\nEncoding {len(image_paths)} images (timestamped logic)...")
        encoded_images = {}
        source_images = {}
        for img_path in image_paths:
            img_name = os.path.basename(img_path)
            img = load_image(img_path)
            source_images[img_name] = img
            if not csv_only:
                base_output = pipe_prior_redux(
                    img,
                    prompt_embeds_scale=1.0,
                    pooled_prompt_embeds_scale=1.0
                )
                encoded_images[img_name] = {
                    'prompt_embeds': base_output['prompt_embeds'],
                    'pooled_prompt_embeds': base_output['pooled_prompt_embeds']
                }

        results = []
        generation_times = []
        frame_info = [] if info_mode or csv_only else None

        # Strength data for each frame
        image_names_for_snippet = [os.path.basename(p) for p in image_paths]
        strength_data = cls.generate_strength_data(
            image_names_for_snippet,
            timestamps,
            fps,
            peak_strength,
            low_strength,
            blend_amount
        )

        previous_latents = None
        for frame_item in strength_data:
            frame_idx = frame_item['frame']
            strengths = frame_item['strengths']

            if frame_info is not None:
                info_dict = {'frame': frame_idx}
                for i, s in enumerate(strengths):
                    info_dict[f'image_{i+1}_redux_strength'] = s
                frame_info.append(info_dict)

            if csv_only:
                continue

            # Weighted sum of embeddings
            total_strength = sum(strengths)
            if total_strength < 1e-9:
                # All zero => produce random latents / skip
                combined_prompt_embeds = None
                combined_pooled_embeds = None
            else:
                emb_sum = None
                pooled_sum = None
                for i, val in enumerate(strengths):
                    if val <= 0.0:
                        continue
                    img_name = os.path.basename(image_paths[i])
                    w = val / total_strength
                    if emb_sum is None:
                        emb_sum = encoded_images[img_name]['prompt_embeds'] * w
                        pooled_sum = encoded_images[img_name]['pooled_prompt_embeds'] * w
                    else:
                        emb_sum = emb_sum + encoded_images[img_name]['prompt_embeds'] * w
                        pooled_sum = pooled_sum + encoded_images[img_name]['pooled_prompt_embeds'] * w

                combined_prompt_embeds = emb_sum
                combined_pooled_embeds = pooled_sum

            # Prepare latents
            if previous_latents is None:
                latents, _ = pipe.prepare_latents(
                    batch_size=1,
                    num_channels_latents=pipe.transformer.config.in_channels // 4,
                    height=height,
                    width=width,
                    dtype=pipe.dtype,
                    device=pipe.device,
                    generator=generator
                )
                batch_size, seq_len, hidden_dim = latents.shape
                latents = latents.view(batch_size, seq_len, -1)
            else:
                new_latents, _ = pipe.prepare_latents(
                    batch_size=1,
                    num_channels_latents=pipe.transformer.config.in_channels // 4,
                    height=height,
                    width=width,
                    dtype=pipe.dtype,
                    device=pipe.device,
                    generator=generator
                )
                new_latents = new_latents.view(batch_size, seq_len, -1)
                if noise_blend_amount is not None:
                    latents = (1 - noise_blend_amount) * previous_latents + noise_blend_amount * new_latents
                else:
                    latents = previous_latents

            previous_latents = latents

            if combined_prompt_embeds is None:
                combined_output = {}
            else:
                combined_output = {
                    'prompt_embeds': combined_prompt_embeds,
                    'pooled_prompt_embeds': combined_pooled_embeds
                }

            t_start = time.time()
            image = pipe(
                width=width,
                height=height,
                num_inference_steps=steps,
                guidance_scale=guidance_scale,
                latents=latents,
                **combined_output,
            ).images[0]
            gen_time = time.time() - t_start
            generation_times.append(gen_time)

            if info_mode:
                active_img_paths = image_paths
                active_strengths = strengths
                image = cls.add_frame_info(
                    image,
                    frame_idx,
                    [source_images[os.path.basename(p)] for p in active_img_paths],
                    active_strengths
                )

            results.append(image)

            synchronize()
            gc.collect()
            torch.cuda.empty_cache()

        return results, generation_times, frame_info

    @staticmethod
    def create_interpolation_video(results,
                                   output_path='interpolation.mp4',
                                   fps=12,
                                   resize_width=512,
                                   resize_height=512,
                                   audio_path=None,
                                   start_time=None,
                                   end_time=None,
                                   skip_frame_save=False,
                                   frame_info=None):
        """
        Create a video from a sequence of images; optionally attach audio.
        """
        import subprocess

        output_dir = os.path.splitext(output_path)[0] + "_frames"
        if not skip_frame_save:
            if os.path.exists(output_dir):
                import shutil
                shutil.rmtree(output_dir)
            os.makedirs(output_dir)

            print(f"\nSaving frames to {output_dir}/")
            for i, img in enumerate(results):
                img = img.resize((resize_width, resize_height), Image.Resampling.LANCZOS)
                frame_path = os.path.join(output_dir, f"frame_{i:04d}.png")
                img.save(frame_path)
                print(f"  Frame {i+1}/{len(results)}", end="\r")
            print()

            # Optionally save frame info to CSV
            if frame_info:
                csv_path = os.path.splitext(output_path)[0] + "_frame_info.csv"
                image_keys = set()
                for info in frame_info:
                    for key in info.keys():
                        if key.startswith('image_') and key.endswith('_redux_strength'):
                            image_keys.add(key)
                sorted_image_keys = sorted(image_keys)
                fieldnames = ['frame'] + [f'image_{key.split("_")[1]}' for key in sorted_image_keys]

                with open(csv_path, 'w', newline='') as f:
                    writer = csv.DictWriter(f, fieldnames=fieldnames)
                    writer.writeheader()
                    for info in frame_info:
                        row = {'frame': info['frame']}
                        for key in sorted_image_keys:
                            image_num = key.split('_')[1]
                            row[f'image_{image_num}'] = info.get(key, 0.0)
                        writer.writerow(row)

                print(f"Frame information saved to {csv_path}")

        # Build the video (via ffmpeg)
        try:
            current_dir = os.getcwd()
            os.chdir(output_dir)
            output_path_abs = os.path.abspath(os.path.join(current_dir, output_path))
            audio_path_abs = os.path.abspath(os.path.join(current_dir, audio_path)) if audio_path else None

            temp_video_path = f"{output_path_abs}.{uuid.uuid4()}.temp.mp4" if audio_path else None
            initial_output = temp_video_path if audio_path else output_path_abs

            ffmpeg_cmd = [
                "ffmpeg", "-y",
                "-framerate", str(fps),
                "-i", "frame_%04d.png",
                "-c:v", "libx264",
                "-preset", "medium",
                "-crf", "23",
                "-pix_fmt", "yuv420p",
                initial_output
            ]

            print(f"\nCreating video {output_path}")
            result = subprocess.run(ffmpeg_cmd, capture_output=True, text=True)
            if result.returncode != 0:
                print("\nError creating video:")
                print("STDOUT:", result.stdout)
                print("STDERR:", result.stderr)
                raise subprocess.CalledProcessError(result.returncode, ffmpeg_cmd, result.stdout, result.stderr)

            # If we have audio, we need to run a second ffmpeg pass
            if audio_path:
                if not os.path.exists(audio_path_abs):
                    raise FileNotFoundError(f"Audio file not found: {audio_path_abs}")

                # Trim audio if needed
                probe_cmd = [
                    "ffprobe",
                    "-v", "error",
                    "-show_entries", "format=duration",
                    "-of", "default=noprint_wrappers=1:nokey=1",
                    audio_path_abs
                ]
                try:
                    audio_duration = float(subprocess.check_output(probe_cmd, text=True).strip())
                except (subprocess.CalledProcessError, ValueError):
                    audio_duration = None

                video_duration = len(results) / fps
                if start_time is not None and audio_duration is not None:
                    if start_time >= audio_duration:
                        raise ValueError(f"Start time {start_time}s is beyond audio duration {audio_duration}s")
                if end_time is not None and audio_duration is not None:
                    if end_time > audio_duration:
                        print(f"\nWarning: End time {end_time}s is beyond audio duration {audio_duration}s")
                        print("Audio will be shorter than video")

                audio_filter = []
                if start_time is not None or end_time is not None:
                    trim_args = []
                    if start_time is not None:
                        trim_args.append(f"start={start_time}")
                    if end_time is not None:
                        trim_args.append(f"end={end_time}")
                    audio_filter.append(f"atrim={':'.join(trim_args)}")
                    audio_filter.append("asetpts=PTS-STARTPTS")

                filter_str = ",".join(audio_filter) if audio_filter else None
                audio_cmd = [
                    "ffmpeg", "-y",
                    "-i", temp_video_path,
                    "-i", audio_path_abs
                ]
                if filter_str:
                    audio_cmd.extend(["-af", filter_str])
                audio_cmd.extend([
                    "-c:v", "copy",
                    "-c:a", "aac",
                    output_path_abs
                ])

                print("\nAdding audio to video")
                result = subprocess.run(audio_cmd, capture_output=True, text=True)
                if os.path.exists(temp_video_path):
                    os.remove(temp_video_path)

                if result.returncode != 0:
                    print("\nError adding audio:")
                    print("STDOUT:", result.stdout)
                    print("STDERR:", result.stderr)
                    raise subprocess.CalledProcessError(result.returncode, audio_cmd, result.stdout, result.stderr)

                if audio_duration is not None:
                    print(f"\nVideo duration: {video_duration:.2f}s")
                    print(f"Original audio duration: {audio_duration:.2f}s")
                    if start_time is not None or end_time is not None:
                        trimmed_duration = (end_time or audio_duration) - (start_time or 0)
                        print(f"Trimmed audio duration: {trimmed_duration:.2f}s")

            os.chdir(current_dir)
            print(f"Video saved successfully to {output_path}")

        except subprocess.CalledProcessError as e:
            print("\nFFmpeg error:")
            print("STDOUT:", e.stdout)
            print("STDERR:", e.stderr)
            raise
        except FileNotFoundError:
            print("\nError: ffmpeg not found. Please install ffmpeg to create videos.")
            print(f"The individual frames have been saved to {output_dir}.")

    @staticmethod
    def get_sorted_images(image_dir: str, sort_method: str = 'alpha') -> List[str]:
        """
        Get sorted list of image paths from a directory by name, numeric, or time.
        """
        image_paths = glob.glob(os.path.join(image_dir, "*.jpg")) + \
                      glob.glob(os.path.join(image_dir, "*.png"))
        if not image_paths:
            raise ValueError(f"No JPG/PNG images found in {image_dir}")

        if sort_method == 'alpha':
            return sorted(image_paths)
        elif sort_method == 'numeric':
            import re
            def natural_keys(text):
                return [int(c) if c.isdigit() else c.lower() for c in re.split('([0-9]+)', text)]
            return sorted(image_paths, key=natural_keys)
        elif sort_method == 'time':
            return sorted(image_paths, key=lambda x: os.path.getctime(x))
        else:
            raise ValueError(f"Unknown sort method: {sort_method}")

    @staticmethod
    def add_frame_info(image: Image.Image, frame_number: int,
                       images: List[Image.Image], strengths: List[float]) -> Image.Image:
        """
        Add frame information including source images and their strengths below the main image.
        """
        main_width = image.width
        main_height = image.height
        thumb_size = main_height // 4
        info_height = thumb_size + 150

        new_img = Image.new('RGB', (main_width, main_height + info_height), 'black')
        new_img.paste(image, (0, 0))
        draw = ImageDraw.Draw(new_img)

        try:
            font = ImageFont.truetype("/System/Library/Fonts/Helvetica.ttc", 72)
            small_font = ImageFont.truetype("/System/Library/Fonts/Helvetica.ttc", 48)
            tiny_font = ImageFont.truetype("/System/Library/Fonts/Helvetica.ttc", 36)
        except:
            # Fallback if the system font is not found
            font = ImageFont.load_default()
            small_font = font
            tiny_font = font

        text = f"Frame {frame_number}"
        text_bbox = draw.textbbox((0, 0), text, font=font)
        text_width = text_bbox[2] - text_bbox[0]
        margin = 20
        draw.rectangle([(margin, margin), (text_width + margin*3, text_bbox[3] + margin*2)], fill='black')
        draw.text((margin*2, margin), text, font=font, fill='white')

        # Create thumbnails
        thumbs = []
        for source_img in images:
            thumb = source_img.copy()
            thumb.thumbnail((thumb_size, thumb_size), Image.Resampling.LANCZOS)
            thumbs.append(thumb)

        spacing = 20
        total_width = sum(thumb.width for thumb in thumbs) + spacing * (len(thumbs) - 1)
        start_x = (main_width - total_width) // 2
        y_pos = main_height + 20

        if len(images) == 2:
            labels = ["Current", "Next"]
        else:
            labels = [f"Img #{i+1}" for i in range(len(images))]

        current_x = start_x
        for i, (thumb, strength, label) in enumerate(zip(thumbs, strengths, labels)):
            label_bbox = draw.textbbox((0, 0), label, font=tiny_font)
            label_width = label_bbox[2] - label_bbox[0]
            label_x = current_x + (thumb.width - label_width) // 2
            draw.text((label_x, y_pos), label, font=tiny_font, fill='white')

            new_img.paste(thumb, (current_x, y_pos + 30))

            str_text = f"Strength: {strength:.3f}"
            text_bbox = draw.textbbox((0, 0), str_text, font=small_font)
            text_width = text_bbox[2] - text_bbox[0]
            text_x = current_x + (thumb.width - text_width) // 2
            text_y = y_pos + thumb.height + 40
            draw.text((text_x, text_y), str_text, font=small_font, fill='white')

            current_x += thumb.width + spacing

        return new_img

    @staticmethod
    def parse_frames_list(frames_str: str) -> List[int]:
        """
        Parse frames string into list of frame counts.
        Accepts either a single number or comma-separated list.
        """
        try:
            parts = frames_str.split(',')
            if len(parts) == 1:
                return [int(parts[0])]
            else:
                return [int(x) for x in parts]
        except ValueError:
            raise ValueError("frames_per_image must be an integer or comma-separated list of integers")

    @staticmethod
    def determine_output_size(first_image_path: str, size_option: str) -> Tuple[int, int]:
        """
        Determine output dimensions based on first image aspect ratio and size selection.
        Returns (width, height) tuple.

        Note: Flux requires dimensions to be multiples of 8.
        The size value represents the minimum dimension - the larger dimension
        will be scaled proportionally while maintaining aspect ratio.
        """
        from PIL import Image

        # Define base sizes for each option - all should be multiples of 8
        # These values represent the MINIMUM dimension
        SIZE_MAP = {
            "Small (512px)": 512,    # e.g. 512x720 for 2:3
            "Medium (720px)": 704,    # e.g. 704x1024 for 2:3
            "Large (1024px)": 896,    # e.g. 896x1280 for 2:3
        }
        min_size = SIZE_MAP[size_option]

        # Read first image dimensions
        with Image.open(first_image_path) as img:
            orig_width, orig_height = img.size
            aspect_ratio = orig_width / orig_height

        def make_multiple_of_8(dim: int) -> int:
            """Ensure dimension is a multiple of 8"""
            return (dim // 8) * 8

        # Instead of using the aspect ratio categories, we'll now just use
        # the aspect ratio directly to determine dimensions
        if aspect_ratio > 1:  # Wider than tall
            # Height becomes the minimum size
            height = min_size
            width = make_multiple_of_8(int(height * aspect_ratio))
        else:  # Taller than wide or square
            # Width becomes the minimum size
            width = min_size
            height = make_multiple_of_8(int(width / aspect_ratio))

        return (width, height)


#############################################################################
# Example specialized node class updated with your 4 requirements:
#############################################################################

class FluxTravelPrecise(NodeBase):
    """
    A node that expects a dict with 'audioFile' and 'timestamps' keys, e.g.:
      {
        'audioFile': '0210.MP3',
        'timestamps': [
           {'id': 'j45tre29f', 'time': '174.4210', 'image': None},
           {'id': 'disycad77', 'time': '314.8415', 'image': 'disycad77_Pantheon-Roma-dallalto.jpg'},
           {'id': 'imal920au', 'time': '542.2481', 'image': 'imal920au_Pantheon-Roma-dallalto.jpg'}
        ]
      }

    It will:
      1) Drop any timestamps that have no image
      2) Crop audio & timestamps so they begin at the first image
      3) Pass the pruned/shifted arrays to process_timestamped_images
      4) Then create_interpolation_video, trimming audio accordingly
    """

    def execute(self, data: Dict, fps: float, steps: int, size: str):
        """
        data: Dict with 'audioFile' and 'timestamps' as described
        fps: frames per second
        steps: diffusion steps
        size: size option for output dimensions
        """
        # -----------------------
        # 1) Drop timestamps with no image
        # -----------------------
        raw_list = data.get('timestamps', [])
        # Filter out entries that have 'image': None (or empty)
        filtered = [entry for entry in raw_list if entry.get('image')]

        if not filtered:
            raise ValueError("No timestamps have valid images!")

        # -----------------------
        # Convert times to float, sort ascending (just in case).
        # -----------------------
        for entry in filtered:
            entry['time'] = float(entry['time'])
        filtered.sort(key=lambda x: x['time'])

        # -----------------------
        # 2) Crop so the first timestamp is at t=0
        #    If the first image is at e.g. 1.0s, we remove that from all times
        #    and from the audio start.
        # -----------------------
        first_time = filtered[0]['time']
        # Shift so first time is 0
        for entry in filtered:
            entry['time'] -= first_time

        # We'll also set the audio start_time to `first_time`
        audio_file = data.get('audioFile', None)
        if audio_file:
            audio_file = os.path.join("/data/files", audio_file)

        # -----------------------
        # Build arrays for process_timestamped_images
        # -----------------------
        image_paths = []
        times = []
        for entry in filtered:
            # If your actual images also reside in /data/files, do:
            img_path = os.path.join("/data/files", entry['image'])
            image_paths.append(img_path)
            times.append(entry['time'])

        # Determine output dimensions based on first image
        width, height = FluxTravelBase.determine_output_size(image_paths[0], size)

        # -----------------------
        # 3) Pass these to process_timestamped_images
        # -----------------------
        pipe, pipe_prior_redux, _ = FluxTravelBase.setup_pipeline()

        print("Passing image_paths, times to process_timestamped_images:")
        print("image_paths=", image_paths)
        print("times=", times)
        print(f"Output dimensions: {width}x{height}")

        results, generation_times, frame_info = FluxTravelBase.process_timestamped_images(
            image_paths=image_paths,
            timestamps=times,
            fps=fps,
            pipe=pipe,
            pipe_prior_redux=pipe_prior_redux,
            steps=steps,
            info_mode=False,
            csv_only=False,
            height=height,
            width=width,
            blend_amount=1.1,
        )

        # -----------------------
        # 4) Create interpolation video
        #    We'll trim the audio from start_time=first_time onward,
        #    so everything lines up. We'll let end_time=None so it doesn't
        #    forcibly cut the end of the audio.
        # -----------------------
        output_path = f"/data/files/{uuid.uuid4()}.mp4"
        FluxTravelBase.create_interpolation_video(
            results,
            output_path=output_path,
            fps=fps,
            audio_path=audio_file,
            start_time=first_time,  # This is how we crop the audio start
            end_time=None,
            skip_frame_save=False,
            frame_info=frame_info,
            resize_width=width,
            resize_height=height
        )

        return {"output_path": output_path}


class FluxTravelLoose(NodeBase):
    """
    A node that expects just a list of images (and possibly frames per image)
    and does a simpler "loose" interpolation without strict timestamps.
    """
    def execute(self, images, frames_per_image, fps, sort_by, audio_file, size):
        # If images is a directory path, call FluxTravelBase.get_sorted_images()
        if isinstance(images, str) and os.path.isdir(images):
            image_paths = FluxTravelBase.get_sorted_images(images, sort_method=sort_by)
        elif isinstance(images, list):
            image_paths = images
        else:
            raise ValueError("Parameter 'images' must be either a directory path or a list of file paths")

        if not image_paths:
            raise ValueError("No images found!")

        # Determine output dimensions based on first image
        width, height = FluxTravelBase.determine_output_size(image_paths[0], size)
        print(f"Output dimensions: {width}x{height}")

        # Setup pipeline
        pipe, pipe_prior_redux, _ = FluxTravelBase.setup_pipeline()

        # Convert frames_per_image to list (in case user provides multiple segments)
        frames_list = FluxTravelBase.parse_frames_list(str(frames_per_image))

        # Use the older piecewise logic
        results, generation_times, frame_info = FluxTravelBase.process_image_batch(
            image_paths=image_paths,
            pipe=pipe,
            pipe_prior_redux=pipe_prior_redux,
            frames_per_transition=frames_list,
            height=height,
            width=width,
            noise_blend_amount=0.0,
            csv_only=False
        )

        # Create video
        output_path = f"/data/files/{uuid.uuid4()}.mp4"
        FluxTravelBase.create_interpolation_video(
            results,
            output_path=output_path,
            fps=fps,
            audio_path=audio_file,
            frame_info=frame_info,
            resize_width=width,
            resize_height=height
        )
        return {"output_path": output_path}

class PlayVideo(NodeBase):
    def execute(self, video_file, video_out=None):
        # Debug: log the received video_file value    
        print('PlayVideo: Received video_file:', video_file)
      
        return {"file_to_play": video_file}
    


'''
class DisplayText(NodeBase):
    def execute(self, text_in, text_in_2):
        return {"text_out": text_in + text_in_2}
'''

================================================================================
FILE: modules/Text/__init__.py
================================================================================

MODULE_MAP = {
    "Text": {
        "label": "Text",
        "description": "Text",    
        "category": "text",
        "type": "tool",
        "execution_type": "continuous",
        "params": {
            "text": {
                "label": "Text (Continuous)",
                "type": "string",
                "display": "output",
            },
            "text_field": {
                "label": "Text Field",
                "type": "string",
                "display": "textarea",
            }
        }
    },
    "Text2": {
        "label": "Text (Button)",
        "description": "Text",
        "category": "text",        
        "type": "tool",
        "execution_type": "button",
        "params": {
            "text": {
                "label": "Text",
                "type": "string",
                "display": "output",
            },
            "text_field": {
                "label": "Text Field",
                "type": "string",
                "display": "textarea",
            }
        }
    },

    "DisplayText": {
        "label": "Display Text",
        "description": "Display text",
        "category": "text",
        "type": "tool",
        "params": {
            "text_in": {
                "label": "Text Input",
                "type": "string",
                "display": "input",
            },
            "text_in_2": {
                "label": "Text Input",
                "type": "string",
                "display": "input",
            },
            
            "text_display": {
                "label": "Text",
                "type": "text",
                "display": "ui",
                "source": "text_out",
            },
            "video_display": {
                "label": "Video",
                "type": "text",
                "display": "ui_video",                
                "source": "video_out",
            }
        }
    },
    "Timeline": {
        "label": "Timeline",
        "description": "Timeline",
        "category": "text",
        "type": "tool",
        "execution_type": "button",
        "params": {
            "audio_file": {
                "label": "Audio File",
                "type": "audio",
                "display": "input",
                },
            "timestamps": {
                "label": "Timestamps",
                "type": "timeline",
                "display": "ui_timeline",
            },
            "timestamps_out": {
                "label": "Timeline",
                "type": "timeline",
                "source": "timestamps",
                "display": "output",
                
            }
        }
    },
    "LoadAudio": {
        "label": "Load Audio",
        "description": "Load audio",
        "category": "text",
        "execution_type": "button",
        "params": {
            "audio_file": {
                "label": "Audio File",
                "type": "audio",
                "display": "filebrowser",
            },
            "audio_file_out": {
                "label": "Audio File",
                "type": "audio",
                "display": "output",
            }
        }
    },
    "FluxTravelPrecise": {
        "label": "Flux Travel (Precise)",
        "description": "Flux Travel",
        "type": "tool",
        "category": "text",
        "execution_type": "button",
        "params": {
            "timestamps": {
                "label": "Timestamps",
                "type": "timeline",
                "display": "input"
            },
            "fps": {
                "label": "FPS",
                "type": "number",
                "default": 30,                
                'min': 1,
                'max': 100,
            },
            "steps": {
                "label": "Steps",
                "type": "number",
                "default": 4,                
                'min': 1,
                'max': 10,
            },
            "size": {
                "label": "Size",
                "type": "dropdown",
                "options": ["Small (512px)", "Medium (720px)", "Large (1024px)"],
                "default": "Medium (720px)",
            },
            "video_out": {
                "label": "Video",
                "type": "video",
                "display": "output",
            }
        }
    },
    "FluxTravelLoose": {
        "label": "Flux Travel (Loose)",
        "description": "Flux Travel",
        "type": "tool",
        "category": "text",
        "execution_type": "button",
        "params": {
            "images": {
                "label": "Images",
                "type": "image",
                "display": "input",
            },            
            "audio_file": {
                "label": "Audio File",
                "type": "audio",
                "display": "input",
            },
            "frames_per_image": {
                "label": "Number of Frames",
                "type": "number",
                "default": 16,                
                'min': 1,
                'max': 100,
            },
            "fps": {
                "label": "FPS",
                "type": "number",
                "default": 30,
                'min': 1,
                'max': 60,
            },
            "sort_by": {
                "label": "Sort By",
                "type": "dropdown",                                
                "options": ["timestamp", "image_name"],
            },
            "size": {
                "label": "Size",
                "type": "dropdown",
                "options": ["Small (512px)", "Medium (720px)", "Large (1024px)"],
                "default": "Medium (720px)",
            },
            "video_out": {
                "label": "Video",
                "type": "video",
                "display": "output",
            }
        }
    },
    "PlayVideo": {
        "label": "Play Video",
        "description": "Play video",
        "type": "tool",
        "category": "text",
        "execution_type": "button",
        "params": {
            "video_file": {
                "label": "Video File",
                "type": "string",
                "display": "input",
            },
            "video_out": {
                "label": "Video",
                "type": "string",                
                "display": "ui_video",                          
                "source": "file_to_play",
            }
        }
    }
}

================================================================================
FILE: client/src/App.tsx
================================================================================

import { useEffect } from 'react';
import { 
  ReactFlow,
  Background,
  Controls,
  NodeOrigin,
  Viewport,
  Connection,
  Edge,
  EdgeMouseHandler,
  IsValidConnection
} from '@xyflow/react';
import { shallow } from 'zustand/shallow';
import { useNodeState, NodeState, CustomNodeType, getLocalStorageKey } from './stores/nodeStore';
import { useNodeRegistryState, NodeRegistryState } from './stores/nodeRegistryStore';
import { useWebsocketState, WebsocketState } from './stores/websocketStore';

import { nanoid } from 'nanoid';

import config from '../config';
import CustomNode from './components/CustomNode';

import '@xyflow/react/dist/base.css';
import './app.css';

const nodeTypes = {
  custom: CustomNode,
};

const selectNodeState = (state: NodeState) => ({
  nodes: state.nodes,
  edges: state.edges,
  onNodesChange: state.onNodesChange,
  onEdgesChange: state.onEdgesChange,
  onEdgeDoubleClick: state.onEdgeDoubleClick,
  onConnect: state.onConnect,
  addNode: state.addNode,
  getParam: state.getParam,
  loadWorkflowFromStorage: state.loadWorkflowFromStorage,
  mode: state.mode,
  viewport: state.viewport,
  setViewport: state.setViewport,
});

const selectNodeRegistryState = (state: NodeRegistryState) => ({
  nodeRegistry: state.nodeRegistry,
  updateNodeRegistry: state.updateNodeRegistry,
});

const selectWebsocketState = (state: WebsocketState) => ({
  connect: state.connect,
});

const nodeOrigin: NodeOrigin = [0, 0];

export default function App() {
  const {
    nodes,
    edges,
    onNodesChange,
    onEdgesChange,
    onEdgeDoubleClick,
    onConnect,
    addNode,
    getParam,
    loadWorkflowFromStorage,
    mode,
    viewport,
    setViewport,
  } = useNodeState(selectNodeState, shallow);
  const { nodeRegistry, updateNodeRegistry } = useNodeRegistryState(selectNodeRegistryState, shallow);
  const { connect: connectWebsocket } = useWebsocketState(selectWebsocketState, shallow);
  
  useEffect(() => {
    // Load workflow from localStorage and initialize other services
    loadWorkflowFromStorage();
    updateNodeRegistry();
    connectWebsocket('ws://' + config.serverAddress + '/ws');
  }, []);

  // Save viewport position when it changes
  const onMoveEnd = (_: MouseEvent | TouchEvent | null, viewport: Viewport) => {
    setViewport(viewport);
  };
  
  // Handle drag & drop of workflow JSON
  const onWorkflowDrop = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    const file = event.dataTransfer.files[0];
    if (file?.type !== 'application/json') return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const flow = JSON.parse(e.target?.result as string);
      // Set default type if not present
      if (!flow.type) {
        flow.type = 'workflow';
      }

      // Store the workflow in the appropriate localStorage key
      const key = getLocalStorageKey(flow.type);
      
      // Ensure we preserve the viewport from the loaded file
      const storedData = JSON.parse(localStorage.getItem(key) || '{}');
      const newData = {
        ...flow,
        viewport: flow.viewport || storedData.viewport
      };
      localStorage.setItem(key, JSON.stringify(newData));
      
      // Now load it through the store which will handle setting the mode
      loadWorkflowFromStorage(flow.type);
    };
    reader.readAsText(file);
  };

  // Handle drag and drop
  const onDragOver = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    event.dataTransfer.dropEffect = 'move';
  };

  const onDrop = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();

    // Handle workflow JSON file drop
    if (event.dataTransfer.files.length > 0) {
      onWorkflowDrop(event);
      return;
    }

    // Handle node drop
    const nodeKey = event.dataTransfer.getData('text/plain');
    if (!nodeKey || !nodeRegistry[nodeKey]) return;

    const node = nodeRegistry[nodeKey];

    // Get the position of the drop
    const reactFlowBounds = event.currentTarget.getBoundingClientRect();
    const position = {
      x: event.clientX - reactFlowBounds.left,
      y: event.clientY - reactFlowBounds.top,
    };

    addNode({
      id: nodeKey + '-' + Math.random().toString(36).substr(2, 9),
      type: 'custom',
      position,
      data: {
        ...node,
        execution_type: node.execution_type ?? 'workflow',  // Ensure execution_type is always defined
        params: node.params ?? {},  // Ensure params is always defined
      },
    });
  };

  const isValidConnection = (connection: Connection) => {
    return true;
  };

  const handleEdgeDoubleClick: EdgeMouseHandler = (event, edge) => {
    onEdgeDoubleClick(edge.id);
  };

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onEdgeDoubleClick={handleEdgeDoubleClick}
      onConnect={onConnect}
      onDrop={onDrop}
      onDragOver={onDragOver}
      onMoveEnd={onMoveEnd}
      isValidConnection={isValidConnection as IsValidConnection}
      nodeTypes={nodeTypes}
      nodeOrigin={nodeOrigin}
      viewport={viewport}
      fitView={!viewport}
      minZoom={0.1}
      maxZoom={2}
      proOptions={{ hideAttribution: true }}
    >
      <Background />
      <Controls />
    </ReactFlow>
  );
}


================================================================================
FILE: client/src/main.tsx
================================================================================

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import { ReactFlowProvider } from '@xyflow/react'

import { createTheme, ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import "@fontsource/jetbrains-mono/latin-400.css";
import "@fontsource/jetbrains-mono/latin-700.css";
import "@fontsource/inter/latin-400.css";
import "@fontsource/inter/latin-500.css";
import "@fontsource/inter/latin-600.css";

import { WebSocketProvider } from './components/WebsocketContext';
import { useNodeState } from './stores/nodeStore';
import { shallow } from 'zustand/shallow';
import { getThemeOptions } from './theme/themeConfig';
import { ThemeInjector } from './theme/ThemeInjector';

import App from './App.tsx'
import Box from '@mui/material/Box';
import ToolBar from './components/ToolBar.tsx';
import ActionBar from './components/ActionBar.tsx';

function ThemedApp() {
  const { mode } = useNodeState(state => ({ mode: state.mode }), shallow);
  const theme = createTheme(getThemeOptions(mode));

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <ThemeInjector />
      <ReactFlowProvider>
        <Box sx={{
          display: 'flex',
          flexDirection: 'column',
          height: '100vh',
          width: '100vw',
          overflow: 'hidden',
        }}>
          <ActionBar />
          <Box sx={{
            display: 'flex',
            flex: 1,
            minHeight: 0,
            height: '100%',
          }}>
            <ToolBar />
            <Box sx={{ flex: 1, height: '100%' }}>
              <WebSocketProvider>
                <App />          
              </WebSocketProvider>
            </Box>
          </Box>
        </Box>
      </ReactFlowProvider>
    </ThemeProvider>
  );
}

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <ThemedApp />
  </StrictMode>
)


================================================================================
FILE: client/src/components/ActionBar.tsx
================================================================================

import { useCallback } from 'react'
import { useReactFlow } from '@xyflow/react'
import { useTheme } from '@mui/material/styles'
import Box from '@mui/material/Box'
import Typography from '@mui/material/Typography'
import Button from '@mui/material/Button'
import Stack from '@mui/material/Stack'
import { shallow } from 'zustand/shallow'
import { NodeState, useNodeState } from '../stores/nodeStore'
import { WebsocketState, useWebsocketState } from '../stores/websocketStore'
import config from '../../config';

// Icons
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import GetAppIcon from '@mui/icons-material/GetApp';
import InsertDriveFileOutlinedIcon from '@mui/icons-material/InsertDriveFileOutlined';
import SvgIcon from '@mui/material/SvgIcon'

export default function AppToolbar() {
  const { setNodes, setEdges, toObject, setViewport } = useReactFlow();
  const theme = useTheme()
  const { exportGraph, mode } = useNodeState(
    (state: NodeState) => ({ 
      exportGraph: state.exportGraph,
      mode: state.mode,
    }), 
    shallow
  );
  const { sid, isConnected } = useWebsocketState((state: WebsocketState) => ({ sid: state.sid, isConnected: state.isConnected }), shallow);

  const onRun = async () => {
    if (!isConnected) {
      console.error('Not connected to WebSocket server');
      return;
    }

    const graphData = exportGraph(sid ?? '');

    console.info(graphData);

    try {
      await fetch('http://' + config.serverAddress + '/graph', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(graphData),
      });
    } catch (error) {
      console.error('Error connecting to API server:', error);
    }
  }

  const onExport = useCallback(() => {
    const flow = toObject();
    const jsonString = JSON.stringify({
      ...flow,
      type: mode
    }, null, 2);

    // Create blob and download
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    
    // For tools, include the date in the filename
    const filename = mode === 'workflow' 
      ? 'workflow.json'
      : `tool-${new Date().toISOString().split('T')[0]}.json`;
      
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [toObject, mode]);

  const onNew = useCallback(() => {
    // Clear the nodes and edges
    setNodes([]);
    setEdges([]);
    
    // Clear localStorage for current mode
    const key = mode === 'workflow' ? 'workflow' : 'tool';
    localStorage.removeItem(key);
    
    const defaultViewport = { x: 0, y: 0, zoom: 1 };
    localStorage.setItem(key, JSON.stringify({ type: mode, nodes: [], edges: [], viewport: defaultViewport }));
    setViewport(defaultViewport);
  }, [setNodes, setEdges, mode]);

  return (
    <Box sx={{
      backgroundColor: theme.palette.background.paper,
      padding: 1,
      borderBottom: `1px solid ${theme.palette.divider}`,
    }}>
      <Stack
        direction="row"
        spacing={0}
        sx={{ justifyContent: "space-between", alignItems: "center" }}
      >
        <Stack
          direction="row"
          spacing={0}
          sx={{ justifyContent: "space-between", alignItems: "center" }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center', ml: 3 }}>
            <SvgIcon>
              <svg viewBox="0 0 28 12" style={{ width: '40px', height: '100%', marginRight: '4px' }} xmlSpace="preserve" xmlns="http://www.w3.org/2000/svg">
                <path style={{ fill: `${theme.palette.primary.main}` }} d="M1.815 11.95c0-.08.421-.784.936-1.565 1.217-1.848 2.4-5.662 2.161-6.965-.29-1.577-1.831-1.974-3.759-.97-1.334.696-1.513.496-.524-.578C1.682.725 3.286.007 4.807 0 6.57-.008 7.485 1.07 7.149 2.866c-.07.373-.077.665-.052.682.026.018.683-.505 1.368-1.122C10.205.861 11.458.232 13.026.266c2.323.054 2.982 1.899 3.153 2.636l.233 1.008 1.067-1.027C19.471.963 21.347.29 22.372.233c1.025-.058 1.686.18 2.376.915 1.69 1.801 1.441 4.275-.753 7.237-.963 1.3-1.166 1.726-.822 1.724.56.082 2.803-.211 3.602-.475.801-.262 1.16-.602 1.22-.507.047.072-.253.528-.4.695-.388.431-1.228 1.447-3.416 1.87-1.432.276-3.066.272-7.87.011-5.772-.312-8.614-.405-13.131.207-.75.101-1.364.12-1.364.041zM7.704 9.96c5.39-.463 5.243-.537 5.872-1.863 1.538-3.246-.245-6.387-3.297-5.802-1.09.209-2.7 1.904-4.049 4.262a522.55 522.55 0 0 1-1.532 2.666c-.286.489-.418.888-.296.886.123 0 1.609-.004 3.302-.149zm14.219-.594c.924-.558 1.842-2.346 1.842-3.592 0-1.864-1.516-3.591-3.15-3.591-1.511 0-2.565.904-4.441 3.81-.958 1.483-1.918 2.724-2.028 2.877-.328.462.122.959 4.76 1.064 1.702.038 2.42-.209 3.017-.568z"/>
              </svg>
            </SvgIcon>
          </Box>

          <Box sx={{ mr: 3 }}>
            <Typography variant="h6" sx={{ fontSize: '20px', padding: '0px 4px' }}>
              Mellon
            </Typography>
          </Box>

          <Box>
            <Button
              variant="text"
              startIcon={<InsertDriveFileOutlinedIcon />}
              onClick={onNew}
              sx={{ mr: 1 }}
            >
              New
            </Button>
            <Button
              variant="text"
              startIcon={<GetAppIcon />}
              onClick={onExport}
            >
              Export
            </Button>
          </Box>
        </Stack>

        <Box>
          {mode === 'workflow' && (
            <Button
              variant="contained"
              startIcon={<PlayArrowIcon />}
              onClick={onRun}
              disabled={!isConnected}
              sx={{
                background: `linear-gradient(100deg, ${theme.palette.primary.main} 25%, #ff4259 90%)`,
                '&.Mui-disabled': {
                  background: `linear-gradient(100deg, #6a6a6a, #303030)`,
                  color: '#1a1a1a',
                }
              }}
            >
              Run
            </Button>
          )}
        </Box>
        <Box></Box>
      </Stack>
    </Box>
  )
}


================================================================================
FILE: client/src/components/CustomNode.tsx
================================================================================

import { memo } from 'react';
import { NodeProps, NodeResizeControl } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

// MUI components
import { useTheme } from '@mui/material/styles'
import Box from '@mui/material/Box';
import Chip from '@mui/material/Chip';
import Stack from '@mui/material/Stack';
import Button from '@mui/material/Button';

// Icons
import DeleteForeverIcon from '@mui/icons-material/DeleteForever';
import AccessAlarmIcon from '@mui/icons-material/AccessAlarm';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import LinearProgress from '@mui/material/LinearProgress';
import OpenInFullIcon from '@mui/icons-material/OpenInFull';

import config from '../../config';
import { groupParams } from './utils/groupParams';
import { useNodeState, NodeState, CustomNodeType, NodeParams } from '../stores/nodeStore';
import { useWebsocketState } from '../stores/websocketStore';
import NodeContent from './NodeContent';

import { deepEqual } from './utils/deepEqual';

const CustomNode = memo((props: NodeProps<CustomNodeType>) => {
    const theme = useTheme();
    const { setParam, setNodeExecuted, runSubGraph } = useNodeState((state: NodeState) => ({
        setParam: state.setParam,
        setNodeExecuted: state.setNodeExecuted,
        runSubGraph: state.runSubGraph
    }), shallow);

    const { sid } = useWebsocketState((state) => ({
        sid: state.sid
    }), shallow);

    const nodeProgress = useWebsocketState(
        (state) => state.nodeProgress[props.id] || { value: 0, type: 'determinate' },
        shallow
    );

    const onClearCache = async () => {
        const nodeId = props.id;

        try {
            const response = await fetch('http://' + config.serverAddress + '/clearNodeCache', {
                method: 'DELETE',
                body: JSON.stringify({ nodeId }),
            });

            if (response.ok) {
                setNodeExecuted(nodeId, false, 0, 0);
            }
        } catch (error) {
            console.error('Error clearing cache:', error);
        }
    }

    const onRunSubGraph = async () => {
        if (!sid) return;
        await runSubGraph(sid, props.id);
    };

    const nodeId = props.id;
    const nodeTitle = props.data.label;

    // format grouped fields
    const fieldList = groupParams(props.data.params);

    //const nodeContent = Object.entries(fieldList).map(([key, data]) => renderNodeContent(nodeId, key, data, setParam));
    const style = props.data.style || {};

    const updateStore = (param: string, value: any, key?: keyof NodeParams) => {
        setParam(nodeId, param, value, key);
    };

    const resizeControl = (
        <NodeResizeControl style={{ backgroundColor: 'transparent', border: 'none' }} minWidth={200} minHeight={8}>
            <OpenInFullIcon sx={{
                position: 'absolute',
                right: '-6px',
                bottom: '-6px',
                transform: 'rotate(90deg)',
                width: '26px',
                height: '26px',
                backgroundColor: theme.palette.background.default,
                borderRadius: '0',
                padding: '2px',
                color: theme.palette.text.secondary,
            }} />
        </NodeResizeControl>
    );

    return (
        <Box
            id={nodeId}
            className={`${props.data.module}-${props.data.action} category-${props.data.category} module-${props.data.module}`}
            sx={{
                position: 'relative',
                boxShadow: 4,
                outlineOffset: '5px',
                borderRadius: '0',
                minWidth: '200px',
                ...style,
            }}
        >
            {props.data.resizable && resizeControl}

            <Box
                component="header"
                sx={{
                    color: theme.palette.text.primary,
                    padding: 1,
                    borderTopWidth: '6px',
                    borderTopStyle: 'solid',
                    borderTopColor: theme.palette.primary.main,
                    backgroundColor: theme.palette.background.paper,
                    fontSize: '16px',
                    fontWeight: 500,
                    borderBottom: `1px solid ${theme.palette.divider}`,
                }}
            >
                {nodeTitle}
            </Box>
            <Box sx={{
                backgroundColor: theme.palette.background.paper,
                pl: 1, pr: 1, pt: 1, pb: 0,
                '& > .MuiBox-root': {
                    pb: 1.5,
                },
                '& .MuiAccordionDetails-root > .MuiBox-root': {
                    pb: 1.5,
                },
                '& .MuiStack-root > .MuiBox-root': {
                    pb: 1.5,
                },
                '& .numberField > .MuiBox-root': {
                    pb: 0,
                },
                '& .labelled-group': {
                    pb: 0,
                },
            }}
            >
                <NodeContent
                    fields={fieldList}
                    updateStore={updateStore}
                    groups={props.data.groups}
                />
            </Box>
            <Box
                component="footer"
                sx={{
                    p: 0,
                    backgroundColor: theme.palette.background.default,
                }}
            >
                <Box sx={{ width: '100%' }}>
                    <LinearProgress
                        variant={nodeProgress.type === 'indeterminate' ? 'indeterminate' : 'determinate'}
                        color="inherit"
                        value={nodeProgress.value}
                        className={nodeProgress.type === 'disabled' ? 'progress-disabled' : ''}
                        sx={{
                            height: '4px',
                            '&.progress-disabled': {
                                '& .MuiLinearProgress-bar': {
                                    display: 'none',
                                },
                            },
                            '& .MuiLinearProgress-bar1Indeterminate': {
                                background: `repeating-linear-gradient(45deg, ${theme.palette.primary.main} 0, ${theme.palette.primary.main} 20px, ${theme.palette.primary.dark} 20px, ${theme.palette.primary.dark} 40px)`,
                                backgroundSize: '60px 100%',
                                backgroundPosition: '0 0',
                                left: '0', right: '0',
                                animation: 'mellon-progress-ind 1s linear infinite',
                            },
                            '& .MuiLinearProgress-bar1Determinate': {
                                transitionDuration: '80ms',
                                background: `linear-gradient(100deg, ${theme.palette.primary.main} 50%, #ff4259 90%)`,
                            },
                            '& .MuiLinearProgress-bar2Indeterminate': {
                                display: 'none',
                                animation: 'none',
                            },
                         }}
                    />
                </Box>

                <Box sx={{ p: 1 }}>
                    <Stack
                        direction="row"
                        spacing={2}
                        sx={{
                            justifyContent: "space-between",
                            alignItems: "center",
                            pr: props.data.resizable ? 2.5 : 0,
                        }}
                    >
                        <Stack direction="row" spacing={1}>
                            <Chip
                                icon={<DeleteForeverIcon />}
                                label="Cache"
                                title="Clear Cache"
                                onClick={onClearCache}
                                disabled={!props.data.cache}
                                color="secondary"
                                variant="filled"
                                sx={{
                                    height: '24px',
                                    borderRadius: 0.5,
                                    fontSize: '12px',
                                    span: { padding: '0px 8px 0px 10px' },
                                    '& .MuiChip-icon': {
                                        fontSize: '18px',
                                    },
                                }}
                            />
                            {props.data.execution_type === 'button' && (
                                <Button
                                    variant="contained"
                                    size="small"
                                    startIcon={<PlayArrowIcon />}
                                    onClick={onRunSubGraph}
                                    sx={{
                                        height: '24px',
                                        borderRadius: 0.5,
                                        fontSize: '12px',
                                        textTransform: 'none',
                                        minWidth: 0,
                                        padding: '4px 8px',
                                    }}
                                >
                                    Run
                                </Button>
                            )}
                        </Stack>
                        {/* <Chip
                            icon={<MemoryIcon />}
                            label={props.data.memory ? `${props.data.memory}` : '0Mb'}
                            title="Memory Usage"
                            sx={{
                                color: theme.palette.text.secondary,
                                height: '24px',
                                borderRadius: 0.5,
                                fontSize: '12px',
                                span: { padding: '0px 8px 0px 10px' },
                                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                            }}
                        /> */}
                        <Chip
                            icon={<AccessAlarmIcon />}
                            label={props.data.time ? `${props.data.time}s` : '-'}
                            title="Execution Time"
                            sx={{
                                color: theme.palette.text.secondary,
                                height: '24px',
                                borderRadius: 0.5,
                                fontSize: '12px',
                                span: { padding: '0px 8px 0px 10px' },
                                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                                '& .MuiChip-icon': {
                                    fontSize: '18px',
                                    color: theme.palette.text.secondary,
                                },
                            }}
                        />
                    </Stack>
                </Box>
            </Box>
        </Box>
    );
}, (prevProps, nextProps) => {
    if (prevProps.data.time !== nextProps.data.time) {
        return false;
    }
    if (prevProps.data.cache !== nextProps.data.cache) {
        return false;
    }

    // groups properties
    if (!deepEqual(prevProps.data.groups, nextProps.data.groups)) {
        return false;
    }

    const prevParams = prevProps.data.params;
    const nextParams = nextProps.data.params;

    const prevKeys = Object.keys(prevParams);
    const nextKeys = Object.keys(nextParams);

    // Check if the objects have different number of keys
    if (prevKeys.length !== nextKeys.length) {
        return false;
    }

    // Check if all keys match
    if (!prevKeys.every(key => key in nextParams)) {
        return false;
    }

    // Now check the values for each key
    for (const key of prevKeys) {
        const prev = prevParams[key];
        const next = nextParams[key];

        if (!deepEqual(prev.value, next.value) ||
            prev.disabled !== next.disabled ||
            prev.hidden !== next.hidden) {
            return false;
        }
    }

    return true;
});

export default CustomNode;


================================================================================
FILE: client/src/components/CustomNumberInput.tsx
================================================================================

import IconButton from '@mui/material/IconButton';
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';
import InputBase from '@mui/material/InputBase';
import Stack from '@mui/material/Stack';
import Box from '@mui/material/Box';
import Typography from '@mui/material/Typography';
import { useTheme } from '@mui/material/styles';
import { useState, useRef, EventHandler, useCallback, useEffect } from 'react';

// TODO: Someone with React expertise should review this code

const CustomNumberInput = ({
    value,
    label = '',
    dataType = 'int',
    slider = false,
    disabled = false,
    onChange,
    min,
    max,
    step,
    style,
    ...props
}: {
    dataKey: string;
    value: string | number;
    label: string;
    dataType?: string;
    slider?: boolean;
    disabled?: boolean;
    onChange: EventHandler<any>;
    min?: number;
    max?: number;
    step?: number;
    style?: { [key: string]: string };
}) => {
    const theme = useTheme();

    const sx = style || {};

    // we display the slider only if we have both min and max values
    const displaySlider = slider && min !== undefined && max !== undefined;

    // min/max normalization
    min = min !== undefined ? min : -Number.MAX_SAFE_INTEGER;
    max = max !== undefined ? max : Number.MAX_SAFE_INTEGER;
    if (min > max) {
        [min, max] = [max, min];
    }

    const minValue = min;
    const maxValue = max;
    const increment = step !== undefined ? step : (dataType === 'float' ? 0.1 : 1);
    const decimals = dataType === 'float' ? (increment.toString().split('.')[1]?.length || 1) : 0;

    const [inputValue, setInputValue] = useState(String(value || 0));
    const [isEditing, setIsEditing] = useState(false);
    const inputRef = useRef<HTMLDivElement>(null);
    const dragTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const dragStartRef = useRef({ x: 0, value: 0 });
    const isDraggingRef = useRef(false);

    const getBackgroundStyle = (value: number) => {
        if (!displaySlider) return {};

        const sliderPercent = isNaN(Number(value)) ? 0 : ((Number(value) - minValue) / (maxValue - minValue) * 100);
        const baseColor = isDraggingRef.current ? theme.palette.secondary.main : 'rgba(255,255,255,0.25)';
        const hoverColor = theme.palette.secondary.main;

        const gradientStyle = `linear-gradient(to right, ${baseColor} ${sliderPercent}%, rgba(255,255,255,0.1) ${sliderPercent}%)`;

        return {
            background: gradientStyle,
            '&:hover': { background: `linear-gradient(to right, ${hoverColor} ${sliderPercent}%, rgba(255,255,255,0.1) ${sliderPercent}%)` }
        };
    };

    const updateValue = useCallback((value: string | number) => {
        value = Number(value);

        // if the value is invalid, it defaults to the middle of the range
        if (isNaN(value)) {
            value = (maxValue - minValue) / 2;
        }

        const newValue = String(Math.min(maxValue, Math.max(minValue, value)).toFixed(decimals));
        setInputValue(newValue);

        if (!isEditing) {
            onChange(newValue);
        }
    }, [minValue, maxValue, decimals]);

    const handleBlur = useCallback(() => {
        const inputElement = inputRef.current?.querySelector('input');
        setIsEditing(false);

        if (!inputElement) return;

        inputElement.removeEventListener('blur', handleBlur as any);
        inputElement.removeEventListener('keydown', handleKeyDown as any);
        updateValue(inputElement.value);
    }, [updateValue]);

    const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
        const inputElement = inputRef.current?.querySelector('input');

        if (e.key === 'Enter' || e.key === 'Escape') {
            inputElement?.removeEventListener('blur', handleBlur as any);
            inputElement?.removeEventListener('keydown', handleKeyDown as any);

            setIsEditing(false);
            updateValue(inputElement?.value || '');
            inputElement?.blur();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            updateValue(Number(inputElement?.value) + increment);
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            updateValue(Number(inputElement?.value) - increment);
        }
    }, [increment, updateValue]);

    const handleMouseMove = useCallback((e: React.MouseEvent) => {
        clearTimeout(dragTimeoutRef.current as any);

        e.preventDefault();
        e.stopPropagation();

        if (!isDraggingRef.current) {
            isDraggingRef.current = true;
        }

        const inputElement = inputRef.current?.querySelector('input');

        // we are dragging, so we remove the focus from the input
        if (document.activeElement === inputElement) {
            inputElement?.blur();
            setIsEditing(false);
        }

        const delta = e.clientX - dragStartRef.current.x;
        const range = maxValue - minValue;
        const steps = range / increment || 100;
        const valueRange = displaySlider ? steps / 300 * delta : delta;
        const newValue = dragStartRef.current.value + valueRange*increment;

        updateValue(newValue);
        //onChange(normalizedValue);
    }, [minValue, maxValue, increment, updateValue]);

    const handleMouseUp = useCallback((e: React.MouseEvent) => {
        clearTimeout(dragTimeoutRef.current as any);
        const inputElement = inputRef.current?.querySelector('input');

        document.removeEventListener('mousemove', handleMouseMove as any);
        document.removeEventListener('mouseup', handleMouseUp as any);
        //inputElement?.removeEventListener('blur', handleBlur as any);
        //inputElement?.removeEventListener('keydown', handleKeyDown as any);

        if (document.activeElement !== inputElement && !isDraggingRef.current && (e.target as HTMLElement).closest('button') === null) {
            // give the focus to the input, unless we are clicking on a left/right button
            inputElement?.focus();
            inputElement?.addEventListener('blur', handleBlur as any);
            inputElement?.addEventListener('keydown', handleKeyDown as any);
            setIsEditing(true);
        } else {
            inputElement?.blur();
            setIsEditing(false);
        }

        isDraggingRef.current = false;
    }, [handleBlur, handleKeyDown]);

    const handleMouseDown = (e: React.MouseEvent) => {
        // Only handle left mouse button
        if (e.button !== 0) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        const inputElement = inputRef.current?.querySelector('input');

        // If the input is already focused, act like a standard text field
        // this allows to edit the value by just typing
        if (document.activeElement === inputElement) return;

        (document.activeElement as HTMLElement)?.blur();

        e.preventDefault();
        e.stopPropagation();

        dragStartRef.current = { x: e.clientX, value: Number(inputValue) };

        // we wait 200ms before entering dragging mode
        // a quick click will just focus the input without starting the drag
        dragTimeoutRef.current = setTimeout(() => {
            inputElement?.blur();
            isDraggingRef.current = true;
        }, 200);

        document.addEventListener('mousemove', handleMouseMove as any);
        document.addEventListener('mouseup', handleMouseUp as any);
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        //const value = e.target.value;
        setInputValue(e.target.value);
        //onChange(value);
    };

    useEffect(() => {
        setInputValue(String(value));
    }, [value]);

    useEffect(() => {
        return () => {
            clearTimeout(dragTimeoutRef.current as any);
            document.removeEventListener('mousemove', handleMouseMove as any);
            document.removeEventListener('mouseup', handleMouseUp as any);

            const inputElement = inputRef.current?.querySelector('input');
            if (inputElement) {
                inputElement.removeEventListener('blur', handleBlur as any);
                inputElement.removeEventListener('keydown', handleKeyDown as any);
            }
        };
    }, [handleMouseMove, handleMouseUp, handleBlur, handleKeyDown]);

    const field = (
        <Stack
            data-key={props.dataKey}
            direction="row"
            spacing={0.5}
            className={`nodrag customNumberInput${disabled ? ' mellon-disabled' : ''}`}
            onMouseDown={handleMouseDown}
            sx={{
                mb: 0,
                p: 0.5,
                width: '100%',
                justifyContent: 'space-between', alignItems: 'center',
                ...getBackgroundStyle(Number(inputValue)),
                borderRadius: 1,
                overflow: 'hidden',
                userSelect: 'none',
                cursor: 'default',
                outline: isEditing ? `2px solid ${theme.palette.primary.main}` : 'none',
                ...sx,
            }}
        >
            <IconButton
                size="small"
                disableRipple // ripple effect is buggy
                onClick={() => updateValue(Number(inputValue) - increment)}
                sx={{
                    borderRadius: 1,
                    opacity: Number(inputValue) <= minValue ? 0.4 : 1,
                    '&:hover': { background: Number(inputValue) <= minValue ? '' : 'rgba(255,255,255,0.15)' }
                }}
            >
                <ChevronLeftIcon fontSize="small" />
            </IconButton>
            <Box sx={{ maxWidth: '50%'}}>
                <Typography sx={{ fontSize: '14px', textOverflow: 'ellipsis', overflow: 'hidden', whiteSpace: 'nowrap' }} title={label}>{label}</Typography>
            </Box>
            <InputBase
                ref={inputRef}
                value={inputValue}
                onChange={handleChange}
                size="small"
                sx={{ flexGrow: 1 }}
                slotProps={{
                    input: {
                        sx: { textAlign: 'right', padding: 0, cursor: 'default' },
                    },
                }}
            />
            <IconButton
                size="small"
                disableRipple
                onClick={() => updateValue(Number(inputValue) + increment)}
                sx={{
                    borderRadius: 1,
                    opacity: Number(inputValue) >= maxValue ? 0.4 : 1,
                    '&:hover': { background: Number(inputValue) >= maxValue ? '' : 'rgba(255,255,255,0.15)' }
                }}
            >
                <ChevronRightIcon fontSize="small" />
            </IconButton>
        </Stack>
    );

    return field;
};

export default CustomNumberInput;

================================================================================
FILE: client/src/components/NodeContent.tsx
================================================================================

import { memo } from "react";
import { NodeParams } from "../stores/nodeStore";
import { deepEqual } from './utils/deepEqual';

// MUI
import { SxProps, Theme } from "@mui/material/styles";

// Custom fields
import AccordionField from "./fields/AccordionField";
import GroupField from "./fields/GroupField";
import HandleField from './fields/HandleField';
import TextField from './fields/TextField';
import ToggleField from "./fields/ToggleField";
import AutocompleteField from "./fields/AutocompleteField";
import SelectField from "./fields/SelectField";
import IconToggleField from "./fields/IconToggleField";
import NumberField from "./fields/NumberField";
import RangeField from "./fields/RangeField";
import TextareaField from "./fields/TextareaField";
import TagsField from "./fields/TagsField";
import CustomField from "./fields/CustomField";
import UIDropdownIcon from "./fields/UIDropdownIcon";
import UIImageField from "./fields/UIImageField";
import UIThreeField from "./fields/UIThreeField";
import FileBrowserField from "./fields/FileBrowserField";
import UITextField from "./fields/UITextField";
import PomsSimpleTimeline from "./fields/PomsSimpleTimeline";
import UIVideoPlayer from "./fields/UIVideoPlayer";

// These are the props sent to the fields
export type FieldProps = {
    fieldKey: string;
    label?: string;
    fieldType?: string;
    value?: any;
    options?: any;
    dataType?: string;
    style?: SxProps<Theme>;
    disabled?: boolean;
    hidden?: boolean;
    open?: boolean;
    no_validation?: boolean;
    icon?: 'random' | 'none';
    min?: number;
    max?: number;
    step?: number;
    source?: string;
    fileType?: 'image' | 'audio' | 'video' | 'text' | 'any';
    updateStore?: (param: string, value: any, key?: keyof NodeParams) => void;
    onChangeAction?: { action: string, target?: any };
}

export type GroupProps = {
    fieldKey: string;
    fields: Record<string, NodeParams>;
    updateStore: (param: string, value: any, key?: keyof NodeParams) => void;
    label?: string;
    open?: boolean;
    direction?: 'row' | 'column';
    disabled?: boolean;
    hidden?: boolean;
    style?: SxProps<Theme>;
}

type NodeContentProps = {
    fields: NodeParams;
    updateStore: (param: string, value: any, key?: keyof NodeParams, group?: string) => void;
    groups?: { [key: string]: { disabled?: boolean, hidden?: boolean, open?: boolean } };
    parentDisabled?: boolean; // avoid disabling fields when the parent group is already disabled
}

const NodeContent = (props: NodeContentProps) => {
    //const renderField = (key: string, data: any) => {
    return Object.entries(props.fields).map(([key, data]: [string, any]) => {
        const displayData = (data.display || '').toLowerCase();
        const disabled = props.parentDisabled ? false : data.disabled || false;
        const hidden = data.hidden || false;
        const sxStyle = data.style || {};
        const label = data.label || key;
        
        // Log when we're rendering a timeline field
        if (displayData === 'ui_timeline' || getFieldType(displayData, data.type, data) === 'ui_timeline') {
            console.log('NodeContent: Rendering timeline field', { 
                key, 
                value: data.value, 
                type: data.type,
                display: displayData
            });
        }

        if (displayData === 'group') {
            const group = props.groups?.[key];
            const groupDisabled = group ? (group.disabled !== undefined ? group.disabled : disabled) : false;
            const groupHidden = group ? (group.hidden !== undefined ? group.hidden : hidden) : false;

            return (
                <GroupField
                    key={key}
                    fieldKey={key}
                    label={data.label}
                    direction={data.direction}
                    disabled={groupDisabled}
                    hidden={groupHidden}
                    style={sxStyle}
                    updateStore={props.updateStore}
                    fields={data.params}
                />
            )
        }
        
        if (displayData === 'collapse') {
            const group = props.groups?.[key];
            const open = group ? (group.open !== undefined ? group.open : data.open) : false;
            const groupDisabled = group ? (group.disabled !== undefined ? group.disabled : disabled) : false;
            const groupHidden = group ? (group.hidden !== undefined ? group.hidden : hidden) : false;

            return (
                <AccordionField
                    key={key}
                    fieldKey={key}
                    open={open}
                    label={data.label}
                    disabled={groupDisabled}
                    hidden={groupHidden}
                    style={sxStyle}
                    updateStore={props.updateStore}
                    fields={data.params}
                />
            )
        }

        // Data type can be an array, the array is mostly used for input handles to allow connection to multiple types
        // For node processing we only use the first type, that becomes the main type
        // TODO: should we use an "allowedTypes" property instead?
        const dataType = (Array.isArray(data.type) && data.type.length > 0 ? data.type[0] : data.type || 'string').toLowerCase();

        const fieldType = getFieldType(displayData, dataType, data);
        const fieldValue = data.value === undefined ? data.default || '' : data.value;
        const options = data.options || [];
        const no_validation = data.no_validation || false;
        const onChangeAction = typeof data.onChange === 'string' ? { action: data.onChange } : data.onChange || null;

        const fieldProps: FieldProps = {
            fieldKey: key,
            fieldType: fieldType,
            dataType: dataType,
            label: label,
            value: fieldValue,
            style: sxStyle,
            hidden: hidden,
            disabled: disabled,
            options: options,
            no_validation: no_validation,
            updateStore: props.updateStore,
            onChangeAction: onChangeAction,
            icon: data.icon,
            min: data.min,
            max: data.max,
            step: data.step,
            source: data.source,
            fileType: data.fileType,
        }

        return <FieldMemo key={key} {...fieldProps} />;
    });

    //return Object.entries(props.fields).map(([key, data]: [string, any]) => renderField(key, data));
};

const FieldMemo = memo((props: FieldProps) => {
    // Log when we're rendering a timeline field
    if (props.fieldType === 'ui_timeline') {
        console.log('FieldMemo: Rendering timeline field', { 
            fieldKey: props.fieldKey, 
            value: props.value,
            updateStore: !!props.updateStore
        });
    }

    switch (props.fieldType) {
        case 'input':
        case 'output':
            return <HandleField {...props} />;
        case 'number':
        case 'slider':
            return <NumberField {...props} />;
        case 'checkbox':
        case 'switch':
            return <ToggleField {...props} />;
        case 'autocomplete':
            return <AutocompleteField {...props} />;
        case 'select':
            return <SelectField {...props} />;
        case 'textarea':
            return <TextareaField {...props} />;
        case 'icontoggle':
            return <IconToggleField {...props} />;
        case 'range':
            return <RangeField {...props} />;
        case 'tags':
            return <TagsField {...props} />;
        case 'custom':
            return <CustomField {...props} />;
        case 'filebrowser':
            return <FileBrowserField {...props} />;
        case 'ui_image':
            return <UIImageField {...props} />;
        case 'ui_dropdownicon':
            return <UIDropdownIcon {...props} />;
        case 'ui_3d':
            return <UIThreeField {...props} />;
        case 'ui_text':
            return <UITextField {...props} />;
        case 'ui_timeline':
            return <PomsSimpleTimeline {...props} />;
        case 'ui_video':
            return <UIVideoPlayer {...props} />;
        default:
            return <TextField {...props} />;
    }
}, (prevProps, nextProps) => {
    return (
        deepEqual(prevProps.value, nextProps.value) &&
        prevProps.disabled === nextProps.disabled &&
        prevProps.hidden === nextProps.hidden
    );
});

const getFieldType = (displayData: string, dataType: string, data: any) => {
    if (displayData === 'input' || displayData === 'output') {
        return displayData;
    }

    if (dataType === 'boolean' || dataType === 'bool') {
        return displayData === 'checkbox' || displayData === 'icontoggle' ? displayData : 'switch';
    }

    if (displayData === 'ui') {
        if (dataType === 'image') {
            return 'ui_image';
        } else if (dataType.toLowerCase() === 'dropdownicon') {
            return 'ui_dropdownicon';
        } else if (dataType.toLowerCase() === '3d') {
            return 'ui_3d';
        } else if (dataType.toLowerCase() === 'text') {
            return 'ui_text';
        } else if (dataType.toLowerCase() === 'video') {
            return 'ui_video';
        }
    }

    if (displayData) {
        return displayData;
    }

    if (data.options && typeof data.options === 'object') {
        return 'select';
    }

    if (dataType === 'int' || dataType === 'integer' || dataType === 'float' || dataType === 'number' ) {
        return displayData === 'slider' ? 'slider' : 'number';
    }

    return 'text';
};

export default NodeContent;

================================================================================
FILE: client/src/components/ToolBar.tsx
================================================================================

import { useMemo, useState } from 'react'

import Box from '@mui/material/Box'
import List from '@mui/material/List'
import ListItem from '@mui/material/ListItem'
import ListItemIcon from '@mui/material/ListItemIcon'
//import ListItemButton from '@mui/material/ListItemButton'
import ListItemText from '@mui/material/ListItemText'
import Tabs from '@mui/material/Tabs'
import Tab from '@mui/material/Tab'
import AccordionDetails from '@mui/material/AccordionDetails'
import AccordionSummary from '@mui/material/AccordionSummary'
import ToggleButtonGroup from '@mui/material/ToggleButtonGroup'
import ToggleButton from '@mui/material/ToggleButton'
//import Stack from '@mui/material/Stack'
import { useTheme } from '@mui/material/styles'

import { shallow } from 'zustand/shallow';
import { NodeRegistryState, useNodeRegistryState } from '../stores/nodeRegistryStore';
import { useNodeState, WorkflowType } from '../stores/nodeStore';

import OutlinedInput from '@mui/material/OutlinedInput'
import SearchIcon from '@mui/icons-material/Search'
import Accordion from '@mui/material/Accordion'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'
import BuildIcon from '@mui/icons-material/Build'
import ColorLensIcon from '@mui/icons-material/ColorLens'
import AutoFixHighIcon from '@mui/icons-material/AutoFixHigh'
import ExtensionIcon from '@mui/icons-material/Extension'
import SettingsIcon from '@mui/icons-material/Settings'
import ImageIcon from '@mui/icons-material/Image'
import TextFieldsIcon from '@mui/icons-material/TextFields'
import DataObjectIcon from '@mui/icons-material/DataObject'

const sidebarWidth = 260

const selectNodeRegistryState = (state: NodeRegistryState) => ({
  nodeRegistry: state.nodeRegistry,
});

const groupBy = (field: string, nodeRegistry: any, localMode: WorkflowType) => {
  const grouped = Object.entries(nodeRegistry).reduce((acc: any, [key, node]: [string, any]) => {
    // Check if this node should be shown in current mode
    const nodeType = node.type || 'workflow';
    const nodeTypes = Array.isArray(nodeType) ? nodeType : [nodeType];
    if (!nodeTypes.includes(localMode)) {
      return acc;
    }

    const fieldValue = node[field] || 'default';
    if (!acc[fieldValue]) {
      acc[fieldValue] = [];
    }
    acc[fieldValue].push({ key, ...node });
    return acc;
  }, {});

  if (field !== 'module') {
    // Sort nodes within each module alphabetically by label
    Object.keys(grouped).forEach(module => {
      grouped[module].sort((a: any, b: any) => 
        (a.label || a.key).localeCompare(b.label || b.key)
      );
    });
  }

  // Return as sorted object with sorted module names
  return Object.fromEntries(
    Object.entries(grouped).sort(([a], [b]) => a.localeCompare(b))
  );
};

const getNodeIcon = (node: any) => {
  // You can customize this based on node type, category, or module
  const category = (node.category || '').toLowerCase();
  const module = (node.module || '').toLowerCase();
  
  if (category === 'image' || module === 'image') {
    return <ImageIcon />;
  } else if (category === 'text' || module === 'text') {
    return <TextFieldsIcon />;
  } else if (category === 'data' || module === 'data') {
    return <DataObjectIcon />;
  } else if (category === 'settings' || module === 'settings') {
    return <SettingsIcon />;
  } else if (category === 'tools' || module === 'tools') {
    return <BuildIcon />;
  } else if (category === 'extension' || module === 'extension') {
    return <ExtensionIcon />;
  }
  
  return <AutoFixHighIcon />;
};

export default function LeftSidebar() {
  const theme = useTheme()
  const { nodeRegistry } = useNodeRegistryState(selectNodeRegistryState, shallow);
  const { mode, loadWorkflowFromStorage, updateLocalStorage } = useNodeState(
    state => ({ 
      mode: state.mode,
      loadWorkflowFromStorage: state.loadWorkflowFromStorage,
      updateLocalStorage: state.updateLocalStorage
    }), 
    shallow
  );

  const handleModeChange = (_: any, newMode: WorkflowType | null) => {
    console.log('Mode change attempted:', { newMode, currentMode: mode });
    if (!newMode || newMode === mode) return;
    
    try {
      // First load the new mode's data
      loadWorkflowFromStorage(newMode);
      // Then save the current state
      updateLocalStorage();
    } catch (error) {
      console.error('Error changing mode:', error);
    }
  };

  // Local node search state, the code will hide the nodes that don't match the search term instead of removing them from the DOM
  const [searchTerm, setSearchTerm] = useState('')
  const filteredNodes = useMemo(() => {
    const searchTerms = searchTerm.toLowerCase().split(/\s+/).filter(term => term.length > 0);
    if (searchTerms.length === 0) return null;

    return Object.keys(nodeRegistry).filter((key) => {
      const label = nodeRegistry[key].label.toLowerCase();
      return searchTerms.every(term => label.includes(term));
    })
  }, [nodeRegistry, searchTerm])

  // Drag and drop functionality
  const onDragStart = (event: React.DragEvent<HTMLLIElement>, key: string) => {
    event.dataTransfer.setData('text/plain', key);
    event.dataTransfer.effectAllowed = 'move';
  }

  // Tab state
  const [tabValue, setTabValue] = useState(0);
  const handleTabChange = (_: any, newValue: number) => {
    setTabValue(newValue);
  };

  const groupedNodes = useMemo(() => {
    // First get the base grouped nodes
    const grouped = tabValue === 0 ? groupBy('module', nodeRegistry, mode) : groupBy('category', nodeRegistry, mode);

    // If there's a search filter, only include nodes that match
    if (filteredNodes) {
      return Object.fromEntries(
        Object.entries(grouped).map(([module, nodes]: [string, any]) => [
          module,
          nodes.filter((node: any) => filteredNodes.includes(node.key))
        ]).filter(([_, nodes]) => nodes.length > 0)
      );
    }

    return grouped;
  }, [nodeRegistry, filteredNodes, tabValue, mode]);

  return (
    <Box
      className="left-sidebar"
      textAlign="center"
      sx={{
        width: sidebarWidth,
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        backgroundColor: theme.palette.background.paper,
        borderRight: `1px solid ${theme.palette.divider}`,
      }}
    >
      <Box sx={{ p: 1.5, borderBottom: `1px solid ${theme.palette.divider}` }}>
        <ToggleButtonGroup
          orientation="vertical"
          value={mode}
          exclusive
          onChange={handleModeChange}
          aria-label="mode switch"
          size="small"
          fullWidth
          sx={{ 
            display: 'flex', 
            flexDirection: 'column',
            '& .MuiToggleButton-root': {
              flex: 1,
              padding: '8px',
              minHeight: '36px',
              border: `1px solid ${theme.palette.divider}`,
              '&:not(:first-of-type)': {
                borderTop: 'none'
              }
            }
          }}
        >
          <ToggleButton 
            value="workflow" 
            aria-label="workflow mode"
          >
            <BuildIcon />
          </ToggleButton>
          <ToggleButton 
            value="tool" 
            aria-label="tool mode"
          >
            <ColorLensIcon />
          </ToggleButton>
        </ToggleButtonGroup>
      </Box>
      <Box sx={{ width: '100%', borderBottom: `1px solid ${theme.palette.divider}`, p: 1.5 }}>
        <Tabs
          value={tabValue}
          onChange={handleTabChange}
          variant="fullWidth"
          sx={{
            lineHeight: '16px',
            minHeight: 0,
            borderBottom: `1px solid ${theme.palette.divider}`,
            '.MuiButtonBase-root': { textTransform: 'none', lineHeight: '16px', minHeight: 0 }
          }}
        >
          <Tab label="Current" />
          <Tab label="New" />
        </Tabs>
        <OutlinedInput
          startAdornment={<SearchIcon fontSize="small" sx={{ marginRight: 1 }} />}
          id="main-module-search"
          placeholder="Search"
          size="small"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          sx={{ width: '100%', fontSize: '14px', mt: 1 }}
        />
      </Box>
      <Box sx={{
        flex: 1,
        overflowY: 'auto',
        p: 0, m: 0,
      }}>
        {tabValue === 1 && searchTerm.trim() === "" ? (
          <Box sx={{ p: 2, textAlign: 'center', color: theme.palette.text.secondary }}>
            Enter text to start searching
          </Box>
        ) : (
          <Box sx={{ p: 0, pb: 0, m: 0 }}>
            {Object.entries(groupedNodes).map(([module, nodes]: [string, any]) => (
              <Accordion disableGutters key={module} sx={{
                borderBottom: `1px solid ${theme.palette.divider}`,
                boxShadow: 'none',
                backgroundColor: theme.palette.background.paper,
                fontSize: 12,
                p: 0, m: 0,
                '&:before': { backgroundColor: 'transparent' },
                '.MuiAccordionSummary-root': {
                  backgroundColor: theme.palette.background.paper,
                  '&:hover': { backgroundColor: 'rgba(255, 255, 255, 0.1)' },
                },
                '.MuiAccordionDetails-root': {
                  backgroundColor: theme.palette.background.paper,
                  padding: '8px 4px',
                },
              }}>
                <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                  {module.replace(/[_-]/g, ' ').replace(/\b\w/g, char => char.toUpperCase())}
                </AccordionSummary>
                <AccordionDetails>
                  <List dense={true} sx={{ p: 1.5, pt: 0, pb: 0, m: 0 }}>
                    {nodes.map((node: any) => (
                      <ListItem
                        key={node.key}
                        draggable
                        className={`${node.key} category-${node.category} module-${node.module}`}
                        onDragStart={(event) => onDragStart(event, node.key)}
                        sx={{
                          outline: `1px solid ${theme.palette.divider}`,
                          borderRadius: 1,
                          boxShadow: 3,
                          m: 0, mb: 1,
                          p: 0.5, pl: 1,
                          borderLeftWidth: '8px',
                          borderLeftStyle: 'solid',
                          cursor: 'grab',
                          display: !filteredNodes || filteredNodes.includes(node.key) ? 'flex' : 'none',
                        }}
                      >
                        <ListItemText primary={node.label || node.key} sx={{ '& .MuiTypography-root': { fontSize: 12 } }} />
                      </ListItem>
                    ))}
                  </List>
                </AccordionDetails>
              </Accordion>
            ))}
          </Box>
        )}
      </Box>
    </Box>
  )
}


================================================================================
FILE: client/src/components/WebsocketContext.tsx
================================================================================

import React, { createContext, useContext } from 'react';
import { WebsocketState, useWebsocketState } from '../stores/websocketStore';

const WebSocketContext = createContext<WebsocketState | null>(null);

export function WebSocketProvider({ children }: { children: React.ReactNode }) {
    const store = useWebsocketState();
    return (
        <WebSocketContext.Provider value={store}>
            {children}
        </WebSocketContext.Provider>
    );
}

export function useWebSocket() {
    const context = useContext(WebSocketContext);
    if (!context) {
        throw new Error('useWebSocket must be used within a WebSocketProvider');
    }
    return context;
}

================================================================================
FILE: client/src/components/utils/deepEqual.ts
================================================================================


export const deepEqual = (a: any, b: any): boolean => {
    if (a === b) return true;
    if (a == null || b == null) return false;

    const bothAreObjects = a && b && typeof a === "object" && typeof b === "object";
    return bothAreObjects &&
        Object.keys(a).length === Object.keys(b).length &&
        Object.keys(a).every(key => deepEqual(a[key], b[key]));
};


================================================================================
FILE: client/src/components/utils/getDecimalPlaces.ts
================================================================================


const getDecimalPlaces = (value: number | undefined) => {
    if (!value) return 1;
    const str = value.toString();
    
    // Handle scientific notation (e.g., 1.23e-4)
    if (str.includes('e-')) {
        const [mantissa, exponent] = str.split('e-');
        const mantissaDecimals = mantissa.includes('.') ? mantissa.split('.')[1].length : 0;
        return mantissaDecimals + Number(exponent);
    }
    
    // Handle regular decimals (e.g., 0.001)
    const decimals = str.split('.')[1];
    return decimals ? decimals.length : 0;
};

export default getDecimalPlaces;

================================================================================
FILE: client/src/components/utils/groupParams.ts
================================================================================

import type { NodeParams, GroupParams } from '../../stores/nodeStore';

interface GroupedParam {
    display: 'group' | 'collapse';
    label: string | null;
    hidden: boolean;
    disabled: boolean;
    open: boolean;
    direction: 'row' | 'column';
    params: Record<string, NodeParams>;
}

const createGroupConfig = (group: GroupParams): GroupParams => {
    if (typeof group === 'string') {
        return { key: `${group}_group`, display: 'group' };
    }
    
    return {
        key: `${group.key || 'untitled'}_group`,
        display: group.display || 'group',
        label: group.label || null,
        hidden: group.hidden || false,
        disabled: group.disabled || false,
        open: group.open || false,
        direction: group.direction || 'row',
    };
};

const createGroupedParam = (config: GroupParams): GroupedParam => ({
    display: config.display || 'group',
    label: config.label || null,
    hidden: config.hidden || false,
    disabled: config.disabled || false,
    open: config.open || false,
    direction: config.direction || 'row',
    params: {},
});

/*
    Group fields by data.params.group.

    Convert group from:
    'seed': { ... }, 'width': { ... group: 'dimensions' }, 'height': { ... group: 'dimensions' }

    To:
    'seed': { ... }, 'dimensions_group': { ... , 'params': { 'width': { ... }, 'height': { ... } } }

    This complication is to keep all fields on the same level and avoid nested objects
*/
export const groupParams = (params: Record<string, NodeParams>): Record<string, NodeParams | GroupedParam> => {
    return Object.entries(params).reduce<Record<string, NodeParams | GroupedParam>>(
        (acc, [key, data]) => {
            if (!data.group) {
                acc[key] = data;
                return acc;
            }

            const groupConfig = createGroupConfig(data.group);

            if (!acc[groupConfig.key]) {
                acc[groupConfig.key] = createGroupedParam(groupConfig);
            }
            
            (acc[groupConfig.key] as GroupedParam).params[key] = data;
            return acc;
        }, 
        {}
    );
};

export type { GroupParams };


================================================================================
FILE: client/src/components/fields/AccordionField.tsx
================================================================================

import { styled } from "@mui/material/styles"
import Accordion from "@mui/material/Accordion";
import AccordionSummary from "@mui/material/AccordionSummary";
import AccordionDetails from "@mui/material/AccordionDetails";
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';

import NodeContent from "../NodeContent";

import { GroupProps } from "../NodeContent";

const PlainAccordion = styled(Accordion)(({ theme }) => ({
    boxShadow: 'none',
    border: 0,
    padding: 0,
    margin: 0,
    background: 'transparent',
    borderBottom: `1px solid ${theme.palette.divider}`,
    '&:before': { background: 'transparent' },
    '.MuiAccordionSummary-root': { padding: '0 4px', margin: 0, background: 'transparent', color: theme.palette.text.secondary, minHeight: '0', border: 'none' },
    '.MuiAccordionDetails-root': { padding: 0, margin: 0, border: 'none' },
    '.MuiAccordionSummary-root:hover, .MuiAccordionSummary-root:hover .MuiAccordionSummary-expandIconWrapper': { color: theme.palette.primary.main },
}));

const AccordionField = (
    { fieldKey, label, open, disabled, hidden, style, fields, updateStore }: GroupProps
) => {
    return (
        <PlainAccordion
            data-key={fieldKey}
            disableGutters={true}
            square={true}
            className={`nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            expanded={open}
            onChange={(_, expanded) => {
                updateStore(fieldKey, { open: expanded }, 'group');
            }}
            sx={{ ...style }}
        >
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                {label || fieldKey}
            </AccordionSummary>
            <AccordionDetails>
                <NodeContent
                    fields={fields}
                    updateStore={updateStore}
                    parentDisabled={disabled}
                />
            </AccordionDetails>
        </PlainAccordion>
    )
}

export default AccordionField;

================================================================================
FILE: client/src/components/fields/AutocompleteField.tsx
================================================================================

import Box from "@mui/material/Box";
import Autocomplete from "@mui/material/Autocomplete";
import TextField from "@mui/material/TextField";

import { FieldProps } from "../NodeContent";

const AutocompleteField = ({ fieldKey, value, style, disabled, hidden, label, no_validation, options, updateStore }: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ minWidth: '320px', ...style }}
            className={`nodrag nowheel ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Autocomplete
                disablePortal
                freeSolo={no_validation}
                options={options}
                renderInput={(params: any) => <TextField {...params} label={label} />}
                onChange={(_, value) => updateStore?.(fieldKey, value)}
                value={value}
                size="small"
                sx={{ '& + .MuiAutocomplete-popper .MuiAutocomplete-option': { fontSize: '12px' } }}
            />
        </Box>
    );
}

export default AutocompleteField;

================================================================================
FILE: client/src/components/fields/CustomField.tsx
================================================================================

import React from "react";
import Box from "@mui/material/Box";
import { useEffect, useState } from "react";
import { FieldProps } from "../NodeContent";
import config from "../../../config";
import { useTheme } from "@mui/material/styles";

const DynamicComponent = ({ component, props }: { component: string | undefined, props: any }) => {
    const [Comp, setComp] = useState<React.ComponentType<any> | null>(null);
    const w = window as any;
    const componentId = component?.split('/').pop();
    if (!component || !componentId) {
        console.error('The component must be in the format of `module/component`');
        return <Box>Error loading component</Box>;
    }

    useEffect(() => {
        // expose React to the custom component
        if (w.React === undefined) {
            w.React = React;
        }

        // Track script instances globally
        if (w.mellonCustomScripts === undefined) {
            w.mellonCustomScripts = new Map();
        }

        const loadComponent = async () => {
            try {
                // check if the script is already loaded
                const existingScript = w.mellonCustomScripts.get(component);
                if (existingScript) {
                    await existingScript;
                } else {
                    const loadPromise = new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = `http://${config.serverAddress}/custom_component/${component}`;
                        script.async = true;
                        script.onload = resolve;
                        script.onerror = reject;
                        script.id = componentId;
                        document.body.appendChild(script);
                    });

                    // Wait for script to load
                    w.mellonCustomScripts.set(component, loadPromise);
                    await loadPromise;
                }

                const LoadedComponent = w[componentId];
                if (!LoadedComponent) {
                    throw new Error(`Component ${componentId} failed to load properly`);
                }

                setComp(() => LoadedComponent);
            } catch (error) {
                console.error('Error loading component:', error);
                w.mellonCustomScripts.delete(component);
            }
        };

        // if the componentId is already in the window, use it
        const existingComponent = w[componentId];
        if (existingComponent) {
            setComp(() => existingComponent);
        } else {
            loadComponent();
        }

        // Cleanup
        return () => {
            const script = document.getElementById(componentId);
            if (script && !document.querySelector(`[data-component="${componentId}"]`)) {
                document.body.removeChild(script);
                w.mellonCustomScripts.delete(component);
            }
            // if mellonCustomScripts is empty we can also remove React from the window
            if (w.mellonCustomScripts.size === 0) {
                delete w.mellonCustomScripts;
                delete w.React;
            }
        };
    }, [component, componentId]);

    if (!Comp) {
        return <Box>Loading...</Box>;
    }

    return (
        <Box data-component={componentId}>
            <Comp {...props} />
        </Box>
    );
};


const CustomField = ({ fieldKey, value, style, disabled, hidden, label, updateStore, source }: FieldProps) => {
    const setValue = (v: any) => updateStore?.(fieldKey, v);
    const theme = useTheme();

    return (
        <Box
            data-key={fieldKey}
            className={`nodrag nowheel ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ ...style }}
        >
            <DynamicComponent
                component={source}
                props={{
                    fieldKey,
                    value,
                    label,
                    setValue,
                    theme,
                }}
            />
        </Box>
    );
}

export default CustomField;

================================================================================
FILE: client/src/components/fields/FileBrowserField.tsx
================================================================================

import { FieldProps } from "../NodeContent";
import { useState, useRef, useCallback, memo } from "react";
import config from "../../../config";
import { useWebsocketState } from "../../stores/websocketStore";

import Box from "@mui/material/Box";
import MuiTextField from "@mui/material/TextField";
import Stack from "@mui/material/Stack";
import IconButton from "@mui/material/IconButton";
import FolderOpenOutlinedIcon from '@mui/icons-material/FolderOpenOutlined';
import CloseIcon from '@mui/icons-material/Close';
import Card from "@mui/material/Card";
import CardMedia from "@mui/material/CardMedia";

interface ExtendedFieldProps extends FieldProps {
    accept?: string;  // File type accept string (e.g. "image/*,audio/*")
    fileType?: 'image' | 'audio' | 'video' | 'text' | 'any';  // Type of file for validation
}

// Map file types to accept strings
const fileTypeToAccept: Record<string, string> = {
    'image': '.jpg,.jpeg,.png,.gif,.webp,.bmp,.svg',
    'audio': '.mp3,.wav,.ogg,.m4a,.aac,.webm',
    'video': '.mp4,.webm,.ogv',
    'text': '.txt,.md,.html,.css,.js,.json',
    'any': '*/*'
};

const FilePreview = memo(({ value, fileType, onClear }: { 
    value: string | null, 
    fileType: string,
    onClear: () => void 
}) => {
    if (!value) return null;

    // Only show preview for files in the data/files directory
    if (!value.startsWith('data/files/')) return null;

    const fileUrl = `http://${config.serverAddress}/${value}`;

    const PreviewWrapper = ({ children }: { children: React.ReactNode }) => (
        <Box sx={{ 
            position: 'relative', 
            mt: 1,
            mx: -2  // Negative margin to counteract the Stack padding
        }}>
            <IconButton
                size="small"
                onClick={onClear}
                sx={{
                    position: 'absolute',
                    right: 8,  // Adjusted to account for new margin
                    top: -8,
                    zIndex: 1,
                    bgcolor: 'background.paper',
                    boxShadow: 1,
                    '&:hover': {
                        bgcolor: 'background.paper',
                    }
                }}
            >
                <CloseIcon fontSize="small" />
            </IconButton>
            {children}
        </Box>
    );

    switch (fileType) {
        case 'image':
            return (
                <PreviewWrapper>
                    <Card sx={{ width: '100%' }}>
                        <CardMedia
                            component="img"
                            height="140"
                            image={fileUrl}
                            sx={{ objectFit: 'contain', width: '100%' }}
                        />
                    </Card>
                </PreviewWrapper>
            );
        case 'audio':
            return (
                <PreviewWrapper>
                    <Box sx={{ width: '100%' }}>
                        <audio controls src={fileUrl} style={{ width: '100%' }} />
                    </Box>
                </PreviewWrapper>
            );
        case 'video':
            return (
                <PreviewWrapper>
                    <Box sx={{ width: '100%' }}>
                        <video 
                            controls 
                            src={fileUrl} 
                            style={{ width: '100%', maxHeight: '200px', objectFit: 'contain' }} 
                        />
                    </Box>
                </PreviewWrapper>
            );
        default:
            return null;
    }
});

FilePreview.displayName = 'FilePreview';

const FileBrowserField = memo(({
    fieldKey,
    value,
    style,
    disabled,
    hidden,
    label,
    updateStore,
    accept,
    fileType = 'any',
}: ExtendedFieldProps) => {
    const fileInputRef = useRef<HTMLInputElement>(null);
    const [error, setError] = useState<string | null>(null);
    const [uploading, setUploading] = useState(false);
    const { sid } = useWebsocketState();

    const validateFile = useCallback((file: File): boolean => {
        if (fileType === 'any') return true;

        const fileTypeMap: Record<string, RegExp> = {
            'image': /^image\/(jpeg|png|gif|webp|bmp|svg\+xml)$/i,
            'audio': /^audio\/(mpeg|wav|ogg|mp4|aac|webm)$/i,
            'video': /^video\/(mp4|webm|ogg)$/i,
            'text': /^text\/(plain|markdown|html|css|javascript|json)$/i
        };

        const validationType = fileTypeMap[fileType];
        if (!validationType) return true;

        if (!validationType.test(file.type)) {
            setError(`Invalid file type. Allowed types: ${fileTypeToAccept[fileType].split(',').join(', ')}`);
            return false;
        }
        return true;
    }, [fileType]);

    const handleFileSelect = useCallback(async (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (!file) return;

        setError(null);

        // Explicit size validation
        if (file.size === 0) {
            setError('Selected file is empty');
            if (fileInputRef.current) {
                fileInputRef.current.value = '';
            }
            return;
        }

        if (!validateFile(file)) {
            if (fileInputRef.current) {
                fileInputRef.current.value = '';
            }
            return;
        }

        try {
            setUploading(true);
            
            // Create a fresh blob from the file to ensure a clean stream
            const fileBlob = file.slice(0, file.size, file.type);
            const formData = new FormData();
            formData.append('file', fileBlob, file.name);

            console.log('FileBrowser: Starting upload', {
                fileName: file.name,
                fileType: file.type,
                fileSize: file.size,
                blobSize: fileBlob.size
            });

            const response = await fetch(`http://${config.serverAddress}/data/files`, {
                method: 'POST',
                body: formData,
                credentials: 'include',
                mode: 'cors'
            });

            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Upload failed: ${errorText}`);
            }

            const fileName = await response.text();
            const filePath = `data/files/${fileName}`;

            // Verify the file exists on the server
            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait for file to be written
            const checkResponse = await fetch(`http://${config.serverAddress}/${filePath}`, {
                method: 'HEAD',
                credentials: 'include',
                mode: 'cors'
            });

            if (!checkResponse.ok) {
                throw new Error('File was not properly saved on the server');
            }

            updateStore?.(fieldKey, filePath);
        } catch (error) {
            console.error('Error uploading file:', error);
            setError(error instanceof Error ? error.message : 'Failed to upload file');
        } finally {
            setUploading(false);
            if (fileInputRef.current) {
                fileInputRef.current.value = '';
            }
        }
    }, [fieldKey, validateFile, updateStore]);

    const handleBrowseClick = useCallback(() => {
        fileInputRef.current?.click();
    }, []);

    const handleTextChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        setError(null);
        updateStore?.(fieldKey, e.target.value);
    }, [fieldKey, updateStore]);

    const handleClear = useCallback(() => {
        updateStore?.(fieldKey, '');
        if (fileInputRef.current) {
            fileInputRef.current.value = '';
        }
    }, [fieldKey, updateStore]);

    return (
        <Box
            data-key={fieldKey}
            sx={{ ...style }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Stack
                direction="column"
                spacing={1}
            >
                <Stack
                    direction="row"
                    spacing={1}
                    sx={{
                        '& > .MuiBox-root': { flex: "1" },
                        '& > .flex-auto': { flex: "0 0 auto" },
                        justifyContent: "center",
                        alignItems: "stretch",
                    }}
                >
                    <MuiTextField
                        onChange={handleTextChange}
                        variant="outlined"
                        type="text"
                        size="small"
                        fullWidth
                        label={label}
                        value={value || ''}
                        className="nodrag"
                        autoComplete="off"
                        error={!!error}
                        helperText={error}
                        disabled={disabled || uploading}
                    />
                    <IconButton 
                        onClick={handleBrowseClick} 
                        disabled={disabled || uploading}
                    >
                        <FolderOpenOutlinedIcon />
                    </IconButton>
                    <input
                        type="file"
                        ref={fileInputRef}
                        style={{ display: 'none' }}
                        onChange={handleFileSelect}
                        accept={accept || fileTypeToAccept[fileType]}
                        disabled={disabled || uploading}
                    />
                </Stack>
                {error && (
                    <Box sx={{ color: 'error.main', fontSize: '0.75rem', px: 1 }}>
                        {error}
                    </Box>
                )}
                <FilePreview 
                    value={value} 
                    fileType={fileType} 
                    onClear={handleClear}
                />
            </Stack>
        </Box>
    );
});

FileBrowserField.displayName = 'FileBrowserField';

export default FileBrowserField;

================================================================================
FILE: client/src/components/fields/GroupField.tsx
================================================================================

import Stack from "@mui/material/Stack";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import NodeContent from "../NodeContent";

import { GroupProps } from "../NodeContent";
import { useTheme } from "@mui/material/styles";


const GroupField = (
    { fieldKey, label, direction, disabled, hidden, style, fields, updateStore }: GroupProps
) => {
    const alignItems = direction === 'column' ? 'stretch' : 'center';
    const spacing = direction === 'column' ? 0 : 1;

    const theme = useTheme();

    if (label) {
        return (
            <Box
                data-key={fieldKey}
                sx={{
                    borderBottom: `1px solid ${theme.palette.divider}`,
                    pt: 0.5, pb: 0,
                    ...style,
                }}
                className={`labelled-group ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            >
                <Typography sx={{ pb: 1, color: theme.palette.text.secondary, textOverflow: 'ellipsis', overflow: 'hidden', whiteSpace: 'nowrap' }}>
                    {label}
                </Typography>
                <Stack
                    direction={direction}
                    spacing={spacing}
                    sx={{
                        '& > .MuiBox-root': { flex: "1" },
                        '& > .flex-auto': { flex: "0 0 auto" },
                        justifyContent: "space-between",
                        alignItems: alignItems,
                    }}
                >
                    <NodeContent
                        fields={fields}
                        updateStore={updateStore}
                        parentDisabled={disabled}
                    />
                </Stack>
            </Box>
        )
    }

    return (
        <Stack
            data-key={fieldKey}
            direction={direction}
            spacing={spacing}
            sx={{
                '& > .MuiBox-root': { flex: "1" },
                '& > .flex-auto': { flex: "0 0 auto" },
                justifyContent: "space-between",
                alignItems: alignItems,
                ...style,
            }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <NodeContent
                fields={fields}
                updateStore={updateStore}
                parentDisabled={disabled}
            />
        </Stack>
    )
}

export default GroupField;


================================================================================
FILE: client/src/components/fields/HandleField.tsx
================================================================================

import { Handle, Position } from "@xyflow/react";
import Typography from "@mui/material/Typography";
import Box from "@mui/material/Box";
import { FieldProps } from "../NodeContent";

const InputHandle = ({ fieldKey, label, style, disabled, hidden, dataType }: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ position: 'relative', ...style }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Handle
                id={fieldKey}
                type="target"
                position={Position.Left}
                className={`${dataType}-handle`}
                style={{ marginTop: '-4px' }}
            />
            <Typography sx={{ pl: 1 }}>{label}</Typography>
        </Box>
    )
}

const OutputHandle = ({ fieldKey, label, style, disabled, hidden, dataType }: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ position: 'relative', ...style }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Handle
                id={fieldKey}
                type="source"
                position={Position.Right}
                className={`${dataType}-handle`}
                style={{ marginTop: '-4px' }}
            />
            <Typography sx={{ textAlign: 'right', pr: 1 }}>{label}</Typography>
        </Box>
    )
}

const HandleField = ({ fieldType, fieldKey, label, style, disabled, hidden, dataType }: FieldProps) => {
    const HandleElement = fieldType === 'input' ? InputHandle : OutputHandle;

    return (
        <HandleElement
            fieldKey={fieldKey}
            label={label}
            style={style}
            disabled={disabled}
            hidden={hidden}
            dataType={dataType}
        />
    );
}

export default HandleField;

================================================================================
FILE: client/src/components/fields/IconToggleField.tsx
================================================================================

import { useEffect } from "react";

import Box from "@mui/material/Box";
import Checkbox from "@mui/material/Checkbox";
import { FieldProps } from "../NodeContent";
import { useTheme } from "@mui/material/styles";

import AutoFixHighIcon from '@mui/icons-material/AutoFixHigh';

const IconToggleField = ({ fieldKey, value, style, disabled, hidden, label, icon, onChangeAction, updateStore }: FieldProps) => {
    const theme = useTheme();

    const iconsMap = {
        'random': <AutoFixHighIcon />,
    }

    const MuiIcons = {
        icon: iconsMap[icon as keyof typeof iconsMap],
        checkedIcon: iconsMap[icon as keyof typeof iconsMap],
    }

    const handleDisableAction = (value: boolean, target: any) => {
        const onTrueTargets = Array.isArray(target.true) ? target.true : [target.true];
        const onFalseTargets = Array.isArray(target.false) ? target.false : [target.false];

        onTrueTargets.forEach((field: string) => {
            updateStore?.(field, value, 'disabled');
        });
        onFalseTargets.forEach((field: string) => {
            updateStore?.(field, !value, 'disabled');
        });
    };

    useEffect(() => {
        if (onChangeAction && onChangeAction.action === 'disable') {
            handleDisableAction(value, onChangeAction.target);
        }
    }, [value]);

    return (
        <Box
            data-key={fieldKey}
            className={`flex-auto nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ ...style }}
        >
            <Checkbox
                size="small"
                {...MuiIcons}
                checked={value}
                title={label}
                onChange={(e) => updateStore?.(fieldKey, e.target.checked)}
                disableRipple
                sx={{
                    p: 1.1,
                    m: 0,
                    border: 1,
                    borderRadius: 1,
                    borderColor: "rgba(255,255,255,0.25)",
                    '&.Mui-checked': {
                        backgroundColor: theme.palette.secondary.main,
                        color: theme.palette.background.paper,
                        borderColor: theme.palette.secondary.main,
                    }
                }}
            />
        </Box>
    )
}

export default IconToggleField;

================================================================================
FILE: client/src/components/fields/NumberField.tsx
================================================================================

import Stack from "@mui/material/Stack";
import IconButton from "@mui/material/IconButton";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import InputBase from "@mui/material/InputBase";
import ChevronLeftIcon from "@mui/icons-material/ChevronLeft";
import ChevronRightIcon from "@mui/icons-material/ChevronRight";
import { FieldProps } from "../NodeContent";
import { useTheme } from '@mui/material/styles';
import { useEffect, useRef, useState } from "react";
import getDecimalPlaces from "../utils/getDecimalPlaces";
const NumberField = ({
    fieldKey,
    fieldType,
    dataType,
    value,
    style,
    disabled,
    hidden,
    label,
    min,
    max,
    step,
    updateStore,
}: FieldProps) => {
    const theme = useTheme();
    const inputRef = useRef<HTMLInputElement>();
    const dragStartRef = useRef({ x: 0, value: 0 });
    const isDraggingRef = useRef(false);
    const [isEditing, setIsEditing] = useState(false);

    const displaySlider = fieldType === 'slider' && min !== undefined && max !== undefined;
    const minValue = min !== undefined ? min : -Number.MAX_SAFE_INTEGER;
    const maxValue = max !== undefined ? max : Number.MAX_SAFE_INTEGER;
    const decimals = dataType === 'float' ? getDecimalPlaces(step) : 0;
    const increment = step !== undefined ? step : (dataType === 'float' ? 0.1 : 1);

    const formatValue = (value: number | string) => {
        if ( isEditing ) {
            return value;
        }

        const newValue = isNaN(Number(value)) ? 0 : Number(value);
        return Math.min(maxValue, Math.max(minValue, newValue)).toFixed(decimals)
    };

    const inputValue = formatValue(value || 0); // we use Zustand for the value and it's already memoized

    const getSliderStyle = () => {
        if (!displaySlider) return {};

        const sliderPercent = isNaN(Number(inputValue)) ? 0 : ((Number(inputValue) - minValue) / (maxValue - minValue) * 100);
        const baseColor = 'rgba(255,255,255,0.15)';
        const gradientStyle = `linear-gradient(to right, ${baseColor} ${sliderPercent}%, rgba(255,255,255,0.0) ${sliderPercent}%)`;

        return {
            background: gradientStyle,
        };
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();

        const delta = e.clientX - dragStartRef.current.x;

        // ignore small movements
        if (Math.abs(delta) < 2) return;

        if (!isDraggingRef.current) {
            isDraggingRef.current = true;
        }

        const inputElement = inputRef.current;

        // we are dragging, so we remove the focus from the input
        if (document.activeElement === inputElement) {
            inputElement?.blur();
            setIsEditing(false);
        }

        const range = maxValue - minValue;
        const steps = range / increment || 100;
        const valueRange = displaySlider ? steps / 250 * delta : delta;
        const newValue = dragStartRef.current.value + valueRange*increment;

        updateStore?.(fieldKey, formatValue(newValue));
    };

    const handleMouseUp = (e: React.MouseEvent) => {
        document.removeEventListener('mousemove', handleMouseMove as any);
        document.removeEventListener('mouseup', handleMouseUp as any);
        
        const currentTarget = (e.target as HTMLElement).closest('.numberField');
        const closestTarget = (e.target as HTMLElement).closest('button');

        if (currentTarget && displaySlider && !isDraggingRef.current && !closestTarget) {
            const rect = currentTarget.getBoundingClientRect();

            const x = e.clientX - rect.left;
            const relPos = Math.max(0, Math.min(1, x / rect.width));
            const newValue = formatValue(minValue + (maxValue - minValue) * relPos);
            updateStore?.(fieldKey, newValue);
        }
        
        isDraggingRef.current = false;
    };

    const handleMouseDown = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();

        // Only handle left mouse button
        if (e.button !== 0) return;

        // if we are already editing, don't do anything
        if (isEditing) return;

        // blur any currently focused element
        (document.activeElement as HTMLElement)?.blur();

        dragStartRef.current = { x: e.clientX, value: Number(inputValue) };

        document.addEventListener('mousemove', handleMouseMove as any);
        document.addEventListener('mouseup', handleMouseUp as any);
    };

    const handleBlur = () => {
        const inputElement = inputRef.current;
        setIsEditing(false);

        if (!inputElement) return;

        if (Number(inputElement.value) !== Number(inputValue)) {
            updateStore?.(fieldKey, formatValue(inputElement.value));
        }

        // trick to force a re-render otherwise the style won't update on blur in some edge cases
        const currentValue = inputElement.value;
        updateStore?.(fieldKey, formatValue(' ' + currentValue));
        updateStore?.(fieldKey, formatValue(currentValue));

        inputElement.removeEventListener('keydown', handleKeyDown as any);
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
        const inputElement = inputRef.current;

        if (!inputElement) return;

        if (e.key === 'Enter' || e.key === 'Escape') {
            inputElement.removeEventListener('keydown', handleKeyDown as any);

            setIsEditing(false);
            updateStore?.(fieldKey, formatValue(inputElement.value || ''));
            inputElement.blur();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            const newValue = Math.min(maxValue, Math.max(minValue, Number(inputElement.value) + increment)).toFixed(decimals);
            inputElement.value = String(newValue);
            updateStore?.(fieldKey, newValue);
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            const newValue = Math.min(maxValue, Math.max(minValue, Number(inputElement.value) - increment)).toFixed(decimals);
            inputElement.value = String(newValue);
            updateStore?.(fieldKey, newValue);
        }
    };

    const handleDoubleClick = (e: React.MouseEvent) => {
        // ignore double clicks on buttons
        if ((e.target as HTMLElement).closest('button')) return;

        const inputElement = inputRef.current;
        if (!inputElement) return;

        inputElement.focus();
        inputElement.select();
        setIsEditing(true);

        inputElement.addEventListener('keydown', handleKeyDown as any);
    };

    useEffect(() => {
        const inputElement = inputRef.current;
        if (inputElement === document.activeElement) {
            inputElement.focus();
            setIsEditing(true);
        } else {
            inputElement?.blur();
            setIsEditing(false);
        }

        return () => {
            document.removeEventListener('mousemove', handleMouseMove as any);
            document.removeEventListener('mouseup', handleMouseUp as any);

            const inputElement = inputRef.current;
            if (inputElement) {
                inputElement.removeEventListener('keydown', handleKeyDown as any);
            }
        };
    }, [isEditing, inputRef]);

    return (
        <Box className={`${hidden ? 'mellon-hidden' : ''} ${disabled ? 'mellon-disabled' : ''}`}>
            <Stack
                data-key={fieldKey}
                direction="row"
                spacing={0.5}
                className={`numberField nodrag`}
                onMouseDown={handleMouseDown}
                onDoubleClick={handleDoubleClick}
                sx={{
                    mb: 0,
                    p: 0.6,
                    width: '100%',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    borderRadius: 1,
                    overflow: 'hidden',
                    userSelect: 'none',
                    cursor: 'default',
                    outline: isEditing ? `2px solid ${theme.palette.primary.main}` : "1px solid #4f4f4f",
                    '&:hover': {
                        outline: isEditing ? `2px solid ${theme.palette.primary.main}` : `1px solid ${theme.palette.common.white}`,
                    },
                    ...getSliderStyle(),
                    ...style
                }}
            >
                <IconButton
                    size="small"
                    disableRipple // ripple effect is buggy
                    onClick={() => { inputRef.current?.blur(); updateStore?.(fieldKey, formatValue(Number(inputRef.current?.value) - increment)) }}
                    sx={{
                        p: 0.5,
                        borderRadius: 1,
                        opacity: Number(inputValue) <= minValue ? 0.4 : 1,
                        '&:hover': { background: Number(inputValue) <= minValue ? '' : 'rgba(255,255,255,0.15)' }
                    }}
                >
                    <ChevronLeftIcon fontSize="small" />
                </IconButton>
                <Box sx={{ maxWidth: '50%', pointerEvents: 'none' }}>
                    <Typography sx={{ fontSize: 13, color: theme.palette.text.secondary, textOverflow: 'ellipsis', overflow: 'hidden', whiteSpace: 'nowrap' }} title={label}>{label}</Typography>
                </Box>
                <InputBase
                    inputRef={inputRef}
                    value={inputValue}
                    size="small"
                    onChange={(e) => updateStore?.(fieldKey, formatValue(e.target.value))}
                    onBlur={handleBlur}
                    sx={{ flexGrow: 1, pointerEvents: 'none' }}
                    slotProps={{
                        input: {
                            sx: { textAlign: 'right', p: 0, cursor: 'default' },
                        },
                    }}
                />
                <IconButton
                    size="small"
                    disableRipple
                    onClick={() => { inputRef.current?.blur(); updateStore?.(fieldKey, formatValue(Number(inputRef.current?.value) + increment)) }}
                    sx={{
                        p: 0.5,
                        borderRadius: 1,
                        opacity: Number(inputValue) >= maxValue ? 0.4 : 1,
                        '&:hover': { background: Number(inputValue) >= maxValue ? '' : 'rgba(255,255,255,0.15)' }
                    }}
                >
                    <ChevronRightIcon fontSize="small" />
                </IconButton>
            </Stack>
        </Box>
    );
}

export default NumberField;


================================================================================
FILE: client/src/components/fields/RangeField.tsx
================================================================================

import Box from "@mui/material/Box"
import Slider from "@mui/material/Slider"
import Typography from "@mui/material/Typography"
import { FieldProps } from "../NodeContent"
import { useTheme } from "@mui/material/styles"

const RangeField = ({ fieldKey, value, style, disabled, hidden, label, min, max, step, updateStore }: FieldProps) => {
    const theme = useTheme();

    return (
        <Box
            key={fieldKey}
            data-key={fieldKey}
            sx={{ pt: 0, pb: 1, pl: 1, pr: 1, ...style }}
            className={`nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}>
            <Typography gutterBottom>{label}</Typography>
            <Slider
                value={value || [0, 1]}
                onChange={(_, newValue) => updateStore?.(fieldKey, newValue)}
                min={min || 0}
                max={max || 1}
                step={step || 0.01}
                valueLabelDisplay="auto"
                color="secondary"
                disableSwap
                sx={{
                    '& .MuiSlider-thumb': {
                        color: theme.palette.secondary.main,
                    },
                }}
            />
        </Box>
    )
}

export default RangeField;

================================================================================
FILE: client/src/components/fields/SelectField.tsx
================================================================================

import Box from "@mui/material/Box/Box";
import Select from "@mui/material/Select";
import FormControl from "@mui/material/FormControl";
import InputLabel from "@mui/material/InputLabel";
import { FieldProps } from "../NodeContent";
import { useEffect } from "react";

const SelectField = ({ fieldKey, value, style, disabled, hidden, label, options, updateStore, onChangeAction }: FieldProps) => {

    const handleShowAction = (value: string, optionsMap: object) => {
        Object.entries(optionsMap).forEach(([key, target]: any) => {
            const isHidden = key !== value;

            if (!target) return;

            if (!Array.isArray(target)) {
                target = [target];
            }

            target.forEach((t: string) => {
                if (t.endsWith('_group')) {
                    updateStore?.(t, { hidden: isHidden }, 'group');
                } else {
                    updateStore?.(t, isHidden, 'hidden');
                }
            });
        });
    };

    const menuItems = Array.isArray(options) ? (
        options.map((v: any, i: number) => (
            <option key={`${fieldKey}-${i}`} value={v}>{v}</option>
        ))
    ) : (
        Object.entries(options).map(([k, v]: any) => (
            <option key={`${fieldKey}-${k}`} value={k}>
                {typeof v === 'object' ? v.label : v}
            </option>
        ))
    );

    useEffect(() => {
        if (onChangeAction?.action === 'show') {
            handleShowAction(value, onChangeAction?.target);
        }
    }, [value]);

    return (
        <Box
            data-key={fieldKey}
            className={`nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ ...style }}
        >
            <FormControl fullWidth>
                <InputLabel>{label}</InputLabel>
                <Select
                    fullWidth
                    size="small"
                    label={label}
                    value={value || ''}
                    native
                    onChange={(e) => updateStore?.(fieldKey, e.target.value)}
                >
                    {menuItems}
                </Select>
            </FormControl>
        </Box>
    )
};

export default SelectField;


================================================================================
FILE: client/src/components/fields/TagsField.tsx
================================================================================

import Box from "@mui/material/Box";
import Autocomplete from "@mui/material/Autocomplete";
import TextField from "@mui/material/TextField";

import { FieldProps } from "../NodeContent";

const TagsField = ({ fieldKey, value, style, disabled, hidden, label, no_validation, options, updateStore }: FieldProps) => {
    const tags = typeof value === 'string' ? [value] : value || [];

    return (
        <Box
            data-key={fieldKey}
            sx={{ minWidth: '320px', ...style }}
            className={`nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Autocomplete
                multiple
                disablePortal
                filterSelectedOptions
                handleHomeEndKeys
                freeSolo={no_validation}
                options={options}
                renderInput={(params: any) => <TextField {...params} label={label} />}
                onChange={(_, v) => updateStore?.(fieldKey, v)}
                value={tags}
                size="small"
            />
        </Box>
    )
}

export default TagsField;

================================================================================
FILE: client/src/components/fields/TextField.tsx
================================================================================

import Box from "@mui/material/Box";
import MuiTextField from "@mui/material/TextField";
import { FieldProps } from "../NodeContent";

const TextField = ({
    fieldKey,
    value,
    dataType,
    style,
    disabled,
    hidden,
    label,
    updateStore,
}: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ ...style }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <MuiTextField
                onChange={(e) => updateStore?.(fieldKey, e.target.value)}
                variant="outlined"
                type="text"
                size="small"
                fullWidth
                label={label}
                value={value}
                className="nodrag"
                autoComplete="off"
                sx={ (dataType === 'int' || dataType === 'integer' || dataType === 'float' || dataType === 'number') ? { '& input': { textAlign: 'right' } } : {} }
            />
        </Box>
    );
}

export default TextField;

================================================================================
FILE: client/src/components/fields/TextareaField.tsx
================================================================================

import Box from "@mui/material/Box";
import { FieldProps } from "../NodeContent";
import { TextField } from "@mui/material";

const TextareaField = ({ fieldKey, value, style, disabled, hidden, label, updateStore }: FieldProps) => {
    return (
        <Box
            key={fieldKey}
            data-key={fieldKey}
            className={`nodrag nowheel ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ minWidth: '320px', ...style }}
        >
            <TextField
                variant="outlined"
                type="text"
                size="small"
                fullWidth
                multiline
                minRows={3}
                maxRows={12}
                label={label}
                value={value}
                onChange={(e) => updateStore?.(fieldKey, e.target.value)}
            />
        </Box>
    );
}

export default TextareaField;

================================================================================
FILE: client/src/components/fields/ToggleField.tsx
================================================================================

import Box from "@mui/material/Box";
import Switch from "@mui/material/Switch";
import Checkbox from "@mui/material/Checkbox";
import FormControlLabel from "@mui/material/FormControlLabel";
import FormGroup from "@mui/material/FormGroup";
import { FieldProps } from "../NodeContent";
import { useEffect } from "react";

const ToggleField = ({ fieldType, fieldKey, label, style, disabled, hidden, value, updateStore, onChangeAction }: FieldProps) => {
    const MuiSwitch = fieldType === 'switch' ? Switch : Checkbox;

    const handleDisableAction = (value: boolean, target: any) => {
        const onTrueTargets = Array.isArray(target.true) ? target.true : [target.true];
        const onFalseTargets = Array.isArray(target.false) ? target.false : [target.false];

        onTrueTargets.forEach((field: string) => {
            if (field.endsWith('_group')) {
                updateStore?.(field, { disabled: value }, 'group');
            } else {
                updateStore?.(field, value, 'disabled');
            }
        });
        onFalseTargets.forEach((field: string) => {
            if (field.endsWith('_group')) {
                updateStore?.(field, { disabled: !value }, 'group');
            } else {
                updateStore?.(field, !value, 'disabled');
            }
        });
    };

    useEffect(() => {
        if (onChangeAction?.action === 'disable') {
            handleDisableAction(value, onChangeAction.target);
        }
    }, [value]);

    return (
        <Box
            data-key={fieldKey}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ ...style }}
        >
            <FormGroup>
                <FormControlLabel
                    sx={{ m: 0, p: 0 }}
                    control={<MuiSwitch
                        sx={{ mr: 0.5 }}
                        size="small"
                        color="secondary"
                        className="nodrag"
                        checked={value}
                        onChange={(e) => updateStore?.(fieldKey, e.target.checked)}
                    />}
                    label={label}
                />
            </FormGroup>
        </Box>
    );
};


export default ToggleField;


================================================================================
FILE: client/src/components/fields/UIDropdownIcon.tsx
================================================================================

import Box from "@mui/material/Box";
import IconButton from "@mui/material/IconButton";
import MoreVertIcon from '@mui/icons-material/MoreVert';
import Menu from "@mui/material/Menu";
import { useTheme } from "@mui/material/styles";

import { FieldProps } from "../NodeContent";
import { useState } from "react";
import Divider from "@mui/material/Divider";
import MenuItem from "@mui/material/MenuItem";

const UIDropdownIcon = ({ fieldKey, style, disabled, hidden, label, options, updateStore, onChangeAction }: FieldProps) => {
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const open = Boolean(anchorEl);
    const targetFields = Array.isArray(onChangeAction?.target) ? onChangeAction?.target : [onChangeAction?.target];

    const theme = useTheme();

    const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
        setAnchorEl(event.currentTarget);
    };
    const handleMenuItemClick = (i: number) => {
        setAnchorEl(null);
        if (i<0) return;

        const targetValue = Array.isArray(options[i].value) ? options[i].value : [options[i].value];

        targetFields.forEach((k: string, i: number) => {
            updateStore?.(k, targetValue[i]);
        });
    };

    return (
        <Box data-key={fieldKey} className={`flex-auto nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`} sx={{ ...style }}>
            <IconButton
                onClick={handleClick}
                title={label}
            >
                <MoreVertIcon />
            </IconButton>
            <Menu
                anchorEl={anchorEl}
                open={open}
                onClose={() => handleMenuItemClick(-1)}
                slotProps={{
                    paper: {
                        sx: {
                            maxHeight: '640px',
                            lineHeight: '0',
                            '& li:hover': {
                                backgroundColor: theme.palette.secondary.main,
                            },
                        },
                        elevation: 8,
                    },
                }}
            >
                {options.map((option: any, i: number) => (
                    option.label?.startsWith('---') ? (
                        <Divider key={i} sx={{ borderColor: 'rgba(255, 255, 255, 0.5)' }} />
                    ) : (
                        <MenuItem key={i} sx={{ lineHeight: '1.2', pl: 1, pr: 1 }} onClick={() => handleMenuItemClick(i)}>
                            {option.label}
                        </MenuItem>
                    )
                ))}
            </Menu>
        </Box>
    )
}

export default UIDropdownIcon;

================================================================================
FILE: client/src/components/fields/UIImageField.tsx
================================================================================

import { FieldProps } from "../NodeContent";
import config from '../../../config';
import Box from "@mui/material/Box";
import { KeyboardEventHandler, MouseEventHandler, useCallback, useEffect, memo, useRef, useState, WheelEventHandler } from "react";
import Modal from "@mui/material/Modal";
import IconButton from "@mui/material/IconButton";
import Slider from "@mui/material/Slider";
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import CloseIcon from '@mui/icons-material/Close';
import { useTheme } from '@mui/material/styles';
import { deepEqual } from '../utils/deepEqual';

const LightBox = memo(({ urls, index, label, onClose }: { urls: {url: string, width: number, height: number}[], index: number, label: string, onClose: () => void }) => {
    const theme = useTheme();

    const [currentIndex, setCurrentIndex] = useState(-1);
    const [zoom, setZoom] = useState(1);
    const [pan, setPan] = useState({ x: 0, y: 0 });

    const isDraggingRef = useRef(false);
    const dragStartRef = useRef({ x: 0, y: 0 });
    const timeRef = useRef(0);

    // Add mouse drag handlers for panning
    const handleMouseDown = (e: React.MouseEvent) => {
        if (zoom === 1) return;
        isDraggingRef.current = true;
        dragStartRef.current = {
            x: e.clientX - pan.x,
            y: e.clientY - pan.y
        };
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDraggingRef.current) return;
        const newX = e.clientX - dragStartRef.current.x;
        const newY = e.clientY - dragStartRef.current.y;
        
        // Calculate bounds to prevent panning outside image bounds
        const bounds = {
            x: Math.min(Math.max(newX, -(zoom - 1) * 500), (zoom - 1) * 500),
            y: Math.min(Math.max(newY, -(zoom - 1) * 500), (zoom - 1) * 500)
        };
        
        setPan(bounds);
    };

    const handleMouseUp = (_: React.MouseEvent) => {
        isDraggingRef.current = false;
    };

    // Reset pan when zoom changes or image changes
    useEffect(() => {
        setPan({ x: 0, y: 0 });
    }, [zoom, currentIndex]);

    useEffect(() => {
        timeRef.current = Date.now();
    }, [urls]);

    useEffect(() => {
        setZoom(1);
        setPan({ x: 0, y: 0 });
        setCurrentIndex(index);
    }, [index]);

    const handleKeyDown = useCallback<KeyboardEventHandler<HTMLDivElement>>((e) => {
        if (currentIndex === -1) return;

        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            e.preventDefault();
            e.stopPropagation();

            if (e.key === 'ArrowLeft' && currentIndex > 0) {
                setCurrentIndex(currentIndex - 1);
            }
            if (e.key === 'ArrowRight' && currentIndex < urls.length - 1) {
                setCurrentIndex(currentIndex + 1);
            }    
        }
    }, [currentIndex, urls.length]);

    const handleWheel = useCallback<WheelEventHandler<HTMLDivElement>>((e) => {
        if (currentIndex === -1) return;
        setZoom(prev => Math.min(Math.max(1, prev - e.deltaY * 0.005), 4));
    }, [currentIndex]);

    const currentUrl = () => {
        if (currentIndex === -1) return '';
        return `http://${config.serverAddress}${urls[currentIndex].url.split('?')[0].replace(/\/$/, '')}?t=${timeRef.current}`;
    };

    // Navigation handlers
    const handlePrevImage = useCallback<MouseEventHandler<HTMLButtonElement>>(() => currentIndex > 0 && setCurrentIndex(currentIndex - 1), [currentIndex]);
    const handleNextImage = useCallback<MouseEventHandler<HTMLButtonElement>>(() => currentIndex < urls.length - 1 && setCurrentIndex(currentIndex + 1), [currentIndex, urls.length]);

    return (
        <Modal
            open={currentIndex > -1}
            onClose={onClose}
            onKeyDown={handleKeyDown}
            onWheel={handleWheel}
            aria-labelledby="lightbox"
        >
            <Box
                sx={{
                    position: 'absolute',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    width: '100vw',
                    height: '100vh',
                    display: 'flex',
                    flexDirection: 'column',
                    justifyContent: 'center',
                    alignItems: 'center',
                }}
                onClick={onClose}
            >
                <Box
                    sx={{
                        display: 'flex',
                        alignItems: 'center',
                        p: 2,
                        backgroundColor: theme.palette.background.paper,
                        borderRadius: 1,
                        mb: 1, mt: 2,
                        //border: `1px solid ${theme.palette.divider}`,
                    }}
                    onClick={(e) => { e.stopPropagation(); e.preventDefault(); }}
                >
                    <IconButton 
                        onClick={handlePrevImage}
                        disabled={currentIndex === 0}
                        size="small"
                    >
                        <ArrowBackIcon />
                    </IconButton>
                    <IconButton
                        onClick={handleNextImage}
                        disabled={currentIndex === urls.length - 1}
                        size="small"
                    >
                        <ArrowForwardIcon />
                    </IconButton>
                    <Slider
                        value={zoom}
                        onChange={(_, newValue) => setZoom(newValue as number)}
                        min={1}
                        max={4}
                        step={0.1}
                        sx={{ mx: 2, width: 200 }}
                    />
                    <Box sx={{ flexGrow: 1 }} />
                    <IconButton onClick={onClose} size="small">
                        <CloseIcon />
                    </IconButton>
                </Box>
                <Box
                    sx={{
                        flexGrow: 1,
                        overflow: 'hidden',
                        display: 'flex',
                        justifyContent: 'center',
                        alignItems: 'center',
                        cursor: zoom > 1 ? 'grab' : 'default',
                        '&:active': {
                            cursor: zoom > 1 ? 'grabbing' : 'default',
                        },
                        '& img': {
                            maxWidth: '100%',
                            maxHeight: '100%',
                            objectFit: 'contain',
                            p: 0, m: 0,
                            transform: `scale(${zoom}) translate(${pan.x / zoom}px, ${pan.y / zoom}px)`,
                            transition: isDraggingRef.current ? 'none' : 'transform 0.2s',
                            pointerEvents: 'none',
                            imageRendering: 'pixelated'
                        }
                    }}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onClick={(e) => { e.stopPropagation(); e.preventDefault(); }}
                >
                {currentIndex > -1 && (
                    <img
                        src={currentUrl()}
                        alt={`${label} ${currentIndex}`}
                        width={`${urls[currentIndex].width}`}
                        height={`${urls[currentIndex].height}`}
                    />
                )}
                </Box>
            </Box>
        </Modal>
    )
}, (prevProps, nextProps) => {
    if (prevProps.index !== nextProps.index) { 
        return false;
    }

    if (!deepEqual(prevProps.urls, nextProps.urls)) {
        return false;
    }

    return true;
});

const UIImageField = ({ fieldKey, value, style, disabled, hidden, label }: FieldProps) => {
    if (typeof value === 'string') {
        value = [{url: value, width: 0, height: 0}];
    }

    //const imgWidth = value.length > 1 ? '50%' : '100%';
    const containerWidth = value.length > 1 ? '1288px' : 'auto';
    const maxHeight = value.length > 4 ? '1360px' : 'auto';

    const imageWidth = (width: number, height: number) => {
        if (value.length === 1) {
            return '100%';
        }
        const aspectRatio = width / height;
        if (aspectRatio > 1.6) {
            return '100%';
        }
        return '50%';
    }

    const [modalIndex, setModalIndex] = useState(-1);

    const handleModalOpen = (index: number) => {
        setModalIndex(index);
    };

    return (
        <>
        <Box
            data-key={fieldKey}
            sx={{
                width: containerWidth,
                height: 'auto',
                maxWidth: '2048px',
                maxHeight: maxHeight,
                overflow: value.length > 4 ? 'auto' : 'hidden',
                mb: 2,
                ...style,
            }}
            className={`${value.length > 4 ? 'nowheel' : ''} ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            {value.map(({url, width, height}: {url: string, width: number, height: number}, index: number) => (
                <Box
                    key={`${fieldKey}-${index}`}
                    sx={{
                        width: imageWidth(Number(width), Number(height)),
                        height: 'auto',
                        display: 'block',
                        float: 'left',
                        '& img': {
                            width: '100%',
                            height: 'auto',
                            display: 'block',
                            p: 0.25,
                            cursor: 'pointer'
                        }
                    }}
                >
                    <img src={`http://${config.serverAddress}${url}`} alt={`${label} ${index}`} onClick={() => handleModalOpen(index)} />
                </Box>
            ))}
        </Box>

        <LightBox
            urls={value}
            index={modalIndex}
            label={label || ''}
            onClose={() => setModalIndex(-1)}
        />
        </>
    );
};

export default UIImageField;

================================================================================
FILE: client/src/components/fields/UITextField.tsx
================================================================================

import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import { FieldProps } from "../NodeContent";
import { useTheme } from "@mui/material/styles";

const UITextField = ({
    fieldKey,
    value,
    style,
    disabled,
    hidden,
    label,
}: FieldProps) => {
    const theme = useTheme();
    // const dataUrl = value.url; // not used, but this endpoint can be used to display the text field value
    const dataValue = value.value;

    return (
        <Box>
            <Typography sx={{ fontSize: 13, color: theme.palette.text.secondary, fontWeight: 'bold' }}>{label}</Typography>
            <Box
                component="pre"
                data-key={fieldKey}
                sx={{ 
                    color: theme.palette.text.secondary, 
                    backgroundColor: theme.palette.mode === 'light' ? '#ffffff' : '#111',
                    border: `1px solid ${theme.palette.divider}`, 
                    borderRadius: 1, 
                    padding: 1, 
                    m: 0, 
                    mb: 1, 
                    ...style 
                }}
                className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            >
                <Typography>{dataValue}</Typography>
            </Box>
        </Box>
    );
}

export default UITextField;

================================================================================
FILE: client/src/components/fields/UIThreeField.tsx
================================================================================

import { lazy, Suspense } from "react";
const ThreePreview = lazy(() => import('./UIThreePreview'));

import { FieldProps } from "../NodeContent";
import Box from "@mui/material/Box";
import CircularProgress from "@mui/material/CircularProgress";

const UIThreeFields = ({ fieldKey, value, style, disabled, hidden }: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ p: 0, m: 0, mt: 1, mb: 1, ...style }}
            className={`nodrag nowheel ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Suspense fallback={
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', width: '768px', height: '768px' }}>
                    <CircularProgress />
                </Box>
            }>
                <ThreePreview value={value} />
            </Suspense>
        </Box>
    );
};

export default UIThreeFields;

================================================================================
FILE: client/src/components/fields/UIThreePreview.tsx
================================================================================

import { Canvas } from '@react-three/fiber';
import { Environment, OrbitControls, useGLTF, Center } from '@react-three/drei';
import config from '../../../config';
import { useEffect, useState } from 'react';
import { useStore } from '@xyflow/react';

import Button from '@mui/material/Button';
import Select from '@mui/material/Select';
import Stack from '@mui/material/Stack';

import * as THREE from 'three';

function getMaterial(materialType: string, wireframe: boolean, shaded: boolean, originalMaterial: THREE.Material | null) {
    let material;
    switch(materialType) {
        case 'phong':
            material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            wireframe,
            flatShading: !shaded,
            shininess: 100,
            specular: 0x444444,
            side: THREE.DoubleSide
        });
        break;
    case 'lambert':
        material = new THREE.MeshLambertMaterial({
            color: 0xffffff,
            wireframe,
            flatShading: !shaded,
            side: THREE.DoubleSide
        });
        break;
    case 'normal':
        material = new THREE.MeshNormalMaterial({
            wireframe,
            flatShading: !shaded,
            side: THREE.DoubleSide
        });
        break;
    case 'toon':
        material = new THREE.MeshToonMaterial({
            color: 0xffffff,
            wireframe,
            side: THREE.DoubleSide,
            map: originalMaterial instanceof THREE.MeshStandardMaterial ? originalMaterial.map : null,
            normalMap: originalMaterial instanceof THREE.MeshStandardMaterial ? originalMaterial.normalMap : null,
        });
        break;
    case 'metal':
        material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 1.0,
            roughness: 0.1,
            wireframe,
            flatShading: !shaded,
            side: THREE.DoubleSide,
            envMapIntensity: 1.5
        });
        break;
    default: // 'standard'
        material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            wireframe,
            flatShading: !shaded,
            roughness: 0.5,
            metalness: 0.1,
            side: THREE.DoubleSide
        });
    }

    return material;
}

function Model({ url, wireframe, shaded, materialType }: { url: string, wireframe: boolean, shaded: boolean, materialType: string }) {
    const [error, setError] = useState<Error | null>(null);
    const { scene } = useGLTF(url, undefined, undefined, (err: any) => {
        if (err instanceof Error) {
            console.log("Error loading 3d model", err.message)
            setError(err);
        }
    });

    if (error || !scene) {
        return null;
    }

    useEffect(() => {
        console.log("scene", scene)
        scene.traverse((child: any) => {
            if (child.isMesh) {
                console.log("mesh", child)
                child.userData.originalMaterial = child.material;
                console.log("child material", child.material)
            }
        });
    }, [scene]);

    useEffect(() => {
        scene.traverse((child: any) => {
            if (child.isMesh) {
                if (child.material) {
                    if (materialType === 'original') {
                        child.material = child.userData.originalMaterial;
                        child.material.flatShading = !shaded;
                        child.material.wireframe = wireframe;
                        //child.material.emissive = new THREE.Color(0x111111);
                        //child.material.emissiveIntensity = 1.5;
                    } else {
                        child.material = getMaterial(materialType, wireframe, shaded, child.userData.originalMaterial);
                    }
                    child.material.needsUpdate = true;
                    
                    // Force geometry normal updates
                    if (child.geometry) {
                        child.geometry.computeVertexNormals();
                        child.geometry.attributes.normal.needsUpdate = true;
                    }
                }
            }
        });
    }, [wireframe, shaded, materialType]);

    return (
        <Center>
            <primitive object={scene} />
        </Center>
    );
}

export default function ThreePreview({ value, ...props }: { value: any, [key: string]: any }) {
    const zoomLevel = useStore((state: any) => state.transform[2]);
    const [wireframe, setWireframe] = useState(false);
    const [shaded, setShaded] = useState(false);
    const [materialType, setMaterialType] = useState('original');

    const containerSize = 768;
    const scaledSize = containerSize * zoomLevel;

    const url = value[0]?.url;
    return (
        <div
            style={{
                position: 'relative',
                width: '768px',
                height: '768px',
                overflow: 'hidden',
            }}
            {...props}
        >
            <div style={{
                position: 'absolute',
                top: 0,
                left: 0,
                transform: `scale(${1/zoomLevel})`,
                transformOrigin: 'top left',
                width: `${scaledSize}px`,
                height: `${scaledSize}px`,
            }}>
                <Canvas
                    style={{ background: '#333333', width: '100%', height: '100%' }}
                    resize={{ scroll: false, debounce: { scroll: 50, resize: 0 } }}
                    camera={{ position: [0, 0, 5] }}
                    dpr={2}
                >
                    <ambientLight intensity={0.25} />
                    <directionalLight position={[5, 5, 5]} intensity={1} />
                    <directionalLight position={[-5, 0, -5]} intensity={0.25} />
                    {url && <Model
                        url={`http://${config.serverAddress}${url}`}
                        wireframe={wireframe}
                        shaded={shaded}
                        materialType={materialType}
                    />}
                    <OrbitControls
                        enableDamping
                        target={[0, 0, 0]}
                        dampingFactor={0.05}
                    />
                    <Environment preset="warehouse" background={false} />
                </Canvas>
            </div>

            <Stack 
                direction="row" 
                spacing={1} 
                sx={{ 
                    position: 'absolute', 
                    top: 10, 
                    left: 10, 
                    zIndex: 1 
                }}
            >
                <Button 
                    variant={wireframe ? "contained" : "outlined"}
                    color="secondary"
                    size="small"
                    onClick={() => setWireframe(!wireframe)}
                    sx={{
                        fontSize: '11px',
                        '&.MuiButton-outlined': {
                            color: '#999999',
                        }
                    }}
                >
                    Wireframe
                </Button>
                <Button 
                    variant={shaded ? "contained" : "outlined"}
                    color="secondary"
                    size="small"
                    onClick={() => setShaded(!shaded)}
                    sx={{
                        fontSize: '11px',
                        '&.MuiButton-outlined': {
                            color: '#999999',
                        }
                    }}
                >
                    Smooth shading
                </Button>
                <Select
                    value={materialType}
                    onChange={(e) => setMaterialType(e.target.value)}
                    size="small"
                    native={true}
                    sx={{
                        fontSize: '12px',
                        width: '120px',
                        backgroundColor: 'rgba(0, 0, 0, 0.2)',
                    }}
                >
                    <option value="original">Original</option>
                    <option value="standard">Standard</option>
                    <option value="phong">Phong</option>
                    <option value="lambert">Lambert</option>
                    <option value="normal">Normal</option>
                    <option value="toon">Toon</option>
                    <option value="metal">Metal</option>
                </Select>
            </Stack>
        </div>
    );
}

================================================================================
FILE: client/src/components/fields/UIVideoPlayer.tsx
================================================================================

import React, { useRef, useState, useEffect } from 'react';
import { Box, IconButton, Slider, Stack, Typography } from '@mui/material';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import PauseIcon from '@mui/icons-material/Pause';
import FastRewindIcon from '@mui/icons-material/FastRewind';
import FastForwardIcon from '@mui/icons-material/FastForward';
import config from '../../../config';
import { FieldProps } from '../NodeContent';
import { useTheme } from "@mui/material/styles";

const UIVideoPlayer = ({
  fieldKey,
  value,
  style,
  disabled,
  hidden,
  label,
  updateStore
}: FieldProps) => {
    const theme = useTheme();

    const dataValue = value.value;
    // Debug: log on mount

    
    useEffect(() => {
        console.log('UIVideoPlayer mounted with props:', {
        value,
        fieldKey,            
        configServer: config.serverAddress,
        valueIsNull: value === null,
        // Now we ALWAYS expect value is an object with .value
        // so you can remove type checks if you like.
        });
    }, [value, fieldKey]);

    // Only keep valid DOM props to avoid React warnings


    // Remove known non-DOM props from boxProps

    // In UITextField we do: const dataValue = value.value;
    // So let's do exactly that here:
    

    // If there's no usable string in videoValue, just render a "No video selected" placeholder
    if (!dataValue) {
        console.log('UIVideoPlayer: Rendering placeholder because videoValue is falsy:', dataValue);
        return (
        <Box
            component="div"
            sx={{
            width: '100%',
            aspectRatio: '16/9',
            maxHeight: '200px',
            backgroundColor: 'black',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center'
            }}
            style={style}
        >
            <Typography variant="body2" color="gray">
            No video selected
            </Typography>
        </Box>
        );
    }

    // Build the final video URL
    // If filePath doesn't start with '/', assume it needs '/data/files/' prepended
    const filePath = dataValue;
    const adjustedPath = filePath.startsWith('/') ? filePath : `/data/files/${filePath}`;
    const videoUrl = `http://${config.serverAddress}${adjustedPath}`;
    console.log('UIVideoPlayer: Final videoUrl:', videoUrl);

    // Local state
    const videoRef = useRef<HTMLVideoElement>(null);
    const [playing, setPlaying] = useState(false);
    const [currentTime, setCurrentTime] = useState<number>(0);
    const [duration, setDuration] = useState<number>(0);
    const [error, setError] = useState<string | null>(null);

    // Debug if error changes
    useEffect(() => {
        if (error) {
        console.log('UIVideoPlayer: error updated:', error);
        }
    }, [error]);

    const handlePlayPause = () => {
        if (!videoRef.current) return;
        if (playing) {
        videoRef.current.pause();
        setPlaying(false);
        } else {
        videoRef.current
            .play()
            .then(() => setPlaying(true))
            .catch(err => {
            setError(`Failed to play video: ${err.message}`);
            setPlaying(false);
            });
        }
    };

    const handleRewind = () => {
        if (videoRef.current) {
        videoRef.current.currentTime = Math.max(videoRef.current.currentTime - 10, 0);
        }
    };

    const handleForward = () => {
        if (videoRef.current) {
        videoRef.current.currentTime = Math.min(videoRef.current.currentTime + 10, duration);
        }
    };

    const handleTimeUpdate = () => {
        if (videoRef.current) {
        setCurrentTime(videoRef.current.currentTime);
        }
    };

    const handleLoadedMetadata = () => {
        if (videoRef.current) {
        setDuration(videoRef.current.duration);
        setError(null);
        }
    };

    const handleError = (e: React.SyntheticEvent<HTMLVideoElement>) => {
        const target = e.currentTarget;
        // If the browser provides an error object:
        setError(`Failed to load video: ${target.error?.message || 'Unknown error'}`);
        setPlaying(false);
    };

    const handleSliderChange = (
        _event: Event,
        sliderValue: number | number[],
        _activeThumb: number
    ) => {
        if (!videoRef.current) return;
        if (typeof sliderValue === 'number') {
        videoRef.current.currentTime = sliderValue;
        setCurrentTime(sliderValue);
        }
    };

    if (error) {
        return (
        <Box
            component="div"
            sx={{
            p: 2,
            bgcolor: 'error.main',
            color: 'error.contrastText',
            borderRadius: 1
            }}
            style={style}
        >
            {error}
        </Box>
        );
    }

    return (
        <Box 
            component="div" 
            style={style}
            className="nodrag"
        >
            <video
                ref={videoRef}
                src={videoUrl}
                onTimeUpdate={handleTimeUpdate}
                onLoadedMetadata={handleLoadedMetadata}
                onError={handleError}
                style={{ width: '100%', maxHeight: '500px', backgroundColor: 'black' }}
            />
            <Stack
                direction="row"
                spacing={2}
                alignItems="center"
                justifyContent="center"
                sx={{ mt: 1 }}
            >
                <IconButton onClick={handleRewind} aria-label="rewind">
                <FastRewindIcon />
                </IconButton>
                <IconButton onClick={handlePlayPause} aria-label={playing ? 'pause' : 'play'}>
                {playing ? <PauseIcon /> : <PlayArrowIcon />}
                </IconButton>
                <IconButton onClick={handleForward} aria-label="forward">
                <FastForwardIcon />
                </IconButton>
            </Stack>
            <Slider
                value={currentTime}
                min={0}
                max={duration}
                step={1}
                onChange={handleSliderChange}
                aria-label="time slider"
            />
        </Box>
    );
    };

    export default UIVideoPlayer;


================================================================================
FILE: client/src/services/dataService.ts
================================================================================

import config from '../../config';

export interface NodePersistentData {
    params: { [key: string]: any };
    files?: string[];
    cache?: boolean;
    time?: number;
    memory?: number;
    event?: string;
    eventId?: number;
}

class DataService {
    private baseUrl: string;
    private readonly FILES_BASE_PATH = '';

    constructor() {
        this.baseUrl = `http://${config.serverAddress}`;
    }

    getFullFilePath(fileName: string): string {
        const baseFileName = fileName.includes('/') ? fileName.split('/').pop()! : fileName;
        return baseFileName;
    }

    async saveNodeData(nodeName: string, data: NodePersistentData): Promise<void> {
        console.log('📤 DataService.saveNodeData called:', {
            nodeName,
            data: JSON.stringify(data).slice(0, 500) + '...',
            hasEvent: Boolean(data.event),
            event: data.event,
            eventId: data.eventId,
            timestamp: new Date().toISOString()
        });

        if (data.params && !data.event && data.params.event) {
            data.event = data.params.event;
            delete data.params.event;
        }
        if (data.params && !data.eventId && data.params.eventId) {
            data.eventId = data.params.eventId;
            delete data.params.eventId;
        }

        const response = await fetch(`${this.baseUrl}/node/${nodeName}/data`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(data)
        });
        
        if (!response.ok) {
            console.error('❌ Failed to save node data:', {
                nodeName,
                status: response.status,
                statusText: response.statusText,
                timestamp: new Date().toISOString()
            });
            throw new Error(`Failed to save node data: ${response.statusText}`);
        }

        console.log('✅ DataService.saveNodeData success:', {
            nodeName,
            timestamp: new Date().toISOString()
        });
    }

    async loadNodeData(nodeName: string): Promise<NodePersistentData | null> {
        try {
            console.log('📥 DataService.loadNodeData called:', {
                nodeName,
                timestamp: new Date().toISOString()
            });

            const response = await fetch(`${this.baseUrl}/node/${nodeName}/data`);
            if (response.ok) {
                const data = await response.json();
                console.log('✅ DataService.loadNodeData success:', {
                    nodeName,
                    hasEvent: Boolean(data.event),
                    event: data.event,
                    eventId: data.eventId,
                    data: JSON.stringify(data).slice(0, 500) + '...',
                    timestamp: new Date().toISOString()
                });
                return data;
            }
            if (response.status === 404) {
                console.log('⚠️ DataService.loadNodeData - No data found:', {
                    nodeName,
                    timestamp: new Date().toISOString()
                });
                return null;
            }
            throw new Error(`Failed to load node data: ${response.statusText}`);
        } catch (error: any) {
            console.error('❌ DataService.loadNodeData error:', {
                nodeName,
                error: error.message,
                stack: error.stack,
                timestamp: new Date().toISOString()
            });
            return null;
        }
    }

    async deleteNodeData(nodeName: string): Promise<void> {
        const response = await fetch(`${this.baseUrl}/node/${nodeName}/data`, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            throw new Error(`Failed to delete node data: ${response.statusText}`);
        }
    }

    async saveNodeFile(nodeName: string, fileName: string, fileData: ArrayBuffer): Promise<string> {
        const formData = new FormData();
        const baseFileName = fileName.includes('/') ? fileName.split('/').pop()! : fileName;
        formData.append('file', new Blob([fileData]), baseFileName);

        const response = await fetch(`${this.baseUrl}/data/files`, {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            throw new Error(`Failed to save node file: ${response.statusText}`);
        }

        return baseFileName;
    }

    async loadNodeFile(nodeName: string, fileName: string): Promise<ArrayBuffer | null> {
        try {
            const baseFileName = fileName.includes('/') ? fileName.split('/').pop()! : fileName;
            const response = await fetch(`${this.baseUrl}/data/files/${baseFileName}`);
            if (response.ok) {
                return await response.arrayBuffer();
            }
            if (response.status === 404) {
                return null;
            }
            throw new Error(`Failed to load node file: ${response.statusText}`);
        } catch (error) {
            console.error(`Error loading file ${fileName} for node ${nodeName}:`, error);
            return null;
        }
    }

    async deleteNodeFile(nodeName: string, fileName: string): Promise<void> {
        const baseFileName = fileName.includes('/') ? fileName.split('/').pop()! : fileName;
        const response = await fetch(`${this.baseUrl}/data/files/${baseFileName}`, {
            method: 'DELETE'
        });
        
        if (!response.ok) {
            throw new Error(`Failed to delete node file: ${response.statusText}`);
        }
    }
}

// Create and export a singleton instance
export const dataService = new DataService();
export default dataService; 
