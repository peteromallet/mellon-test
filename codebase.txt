
================================================================================
FILE: config.py
================================================================================

import configparser
import logging
import os

class Config:
    def __init__(self):
        self.config = configparser.ConfigParser()
        self.config.read('config.ini')

        self.server = {
            'host': self.config.get('server', 'host', fallback='127.0.0.1'),
            'port': self.config.getint('server', 'port', fallback=8080),
            'cors': self.config.getboolean('server', 'cors', fallback=False),
            'cors_route': self.config.get('server', 'cors_route', fallback='*'),
        }

        self.app = {
            'global_seed': self.config.getint('app', 'global_seed', fallback=42),
        }

        self.log = {
            'level': getattr(logging, self.config.get('logging', 'level', fallback='INFO').upper()),
        }

        self.hf = {
            'token': self.config.get('huggingface', 'token', fallback=None),
            'cache_dir': self.config.get('huggingface', 'cache_dir', fallback=None),
            'online_status': self.config.get('huggingface', 'online_status', fallback='Connect if needed'),
        }

        self.paths = {
            'data': self.config.get('paths', 'data', fallback='data'),
            'temp': self.config.get('paths', 'temp', fallback='data/temp'),
        }

        for path, value in self.paths.items():
            if not os.path.isabs(value):
                value = os.path.join(os.path.dirname(__file__), value)
                self.paths[path] = value

            if not os.path.exists(value):
                os.makedirs(value)

        self.environ = self.config['environ'] if 'environ' in self.config else {}
        for key, value in self.environ.items():
            self.environ[key] = self.config.get('environ', key, fallback=None)

config = Config()


================================================================================
FILE: main.py
================================================================================

import logging
import os
from config import config
import torch # warm up since we are going to use it anyway

# initialize logging
logging.basicConfig(level=config.log['level'], format="%(asctime)s [%(levelname)s] %(message)s", datefmt="%Y%m%d %H.%M.%S")
logger = logging.getLogger('mellon')

# random seed generation
# import numpy as np
#import random
# torch.cuda.manual_seed(0)
# torch.cuda.manual_seed_all(0)
# torch.backends.cudnn.deterministic = True
# torch.backends.cudnn.benchmark = False
# np.random.seed(0)
# random.seed(0)
# os.environ['PYTHONHASHSEED'] = str(0)
# os.environ['CUBLAS_WORKSPACE_CONFIG'] = ':4096:8'
# torch.use_deterministic_algorithms(True)

# huggingface cache directory
if config.hf['cache_dir']:
    os.environ['HF_HOME'] = config.hf['cache_dir']

# load modules
from modules import MODULE_MAP

# start web server
from mellon.server import web_server #WebServer
#web_server = WebServer(MODULE_MAP, **config.server)

# welcome message
logger.info(f"""\x1b[33;20m
╔══════════════════════╗
║  Welcome to Mellon!  ║
╚══════════════════════╝\x1b[0m
Speak Friend and Enter: http://{config.server['host']}:{config.server['port']}""")

# Engage!
web_server.run()



================================================================================
FILE: mellon/NodeBase.py
================================================================================

import logging
logger = logging.getLogger('mellon')
from modules import MODULE_MAP
import torch
import time
from utils.memory_manager import memory_flush, memory_manager
from mellon.server import web_server
import nanoid
import numpy as np

def get_module_params(module_name, class_name):
    params = MODULE_MAP[module_name][class_name]['params'] if module_name in MODULE_MAP and class_name in MODULE_MAP[module_name] else {}
    return { p: params[p]['default'] if 'default' in params[p] else None
            for p in params if not 'display' in params[p] or (params[p]['display'] != 'output' and params[p]['display'] != 'ui') }

def get_module_output(module_name, class_name):
    params = MODULE_MAP[module_name][class_name]['params'] if module_name in MODULE_MAP and class_name in MODULE_MAP[module_name] else {}
    return { p: None for p in params if 'display' in params[p] and params[p]['display'] == 'output' }

def filter_params(params, args):
    return { key: args[key] for key in args if key in params }

def has_changed(params, args):
    return any(params.get(key) != args.get(key) for key in args if key in params)

def are_different(a, b):
    # quick identity check
    if a is b:
        return False

    # check if the types are different
    if type(a) != type(b):
        return True

    # check custom hash, this value is king
    if hasattr(a, "_MELLON_HASH") and hasattr(b, "_MELLON_HASH"):
       return hasattr(a, "_MELLON_HASH") != hasattr(b, "_MELLON_HASH")
    
    # common attributes
    if hasattr(a, 'shape'):
        if a.shape != b.shape:
            return True
    if hasattr(a, 'dtype'):
        if not hasattr(b, 'dtype') or a.dtype != b.dtype:
            return True

    # quick image comparison
    if hasattr(a, 'size'):
        if a.size != b.size:
            return True
    if hasattr(a, 'mode'):
        if a.mode != b.mode:
            return True

    # deep PIL images comparison
    if hasattr(a, 'getdata') and hasattr(a, 'width') and hasattr(a, 'height'):
        # compare small images with tobytes(), possibly unnecessary optimization
        if a.width*a.height < 32768:
            return a.tobytes() != b.tobytes()
        return not np.array_equal(np.asarray(a), np.asarray(b))

    # trimesh comparison
    if hasattr(a, 'vertices') and hasattr(a.vertices, 'shape'):
        if are_different(a.vertices, b.vertices):
            return True
        if hasattr(a, 'visual') and hasattr(a.visual, 'material') and hasattr(a.visual.material, 'image'):
            if are_different(a.visual.material.image, b.visual.material.image):
                return True
        if hasattr(a, 'faces') and hasattr(a.faces, 'shape'):
            if are_different(a.faces, b.faces):
                return True
        # we assume that the mesh is the same if the vertices, faces and material are the same
        # TODO: check if this is correct
        return False

    # compare numpy arrays
    if isinstance(a, np.ndarray):
        return not np.array_equal(a, b)

    # compare tensors
    if isinstance(a, torch.Tensor):
        return not torch.equal(a, b)

    # iterate list, tuple, dict
    if isinstance(a, (list, tuple)):
        if len(a) != len(b):
            return True
        return any(are_different(x, y) for x, y in zip(a, b))
    if isinstance(a, dict):
        if a.keys() != b.keys():
            return True
        return any(are_different(a[k], b[k]) for k in a)

    if hasattr(a, 'to_dict'):
        x = a.to_dict()
        y = b.to_dict()
        return any(are_different(x[k], y[k]) for k in x)

    if hasattr(a, '__dict__') and hasattr(b, '__dict__'):
        if a.__dict__ != b.__dict__:
            return True

    if a != b:
        return True

    return False

class NodeBase():
    CALLBACK = 'execute'
    FORCE_UNLOAD = True

    def __init__(self, node_id=None):
        self.node_id = node_id
        self.module_name = self.__class__.__module__.split('.')[-1]
        if 'custom.' in self.__class__.__module__:
            self.module_name = self.module_name + '.custom'
        self.class_name = self.__class__.__name__
        self.params = {}
        self.output = get_module_output(self.module_name, self.class_name)
        
        self._client_id = None
        self._pipe_interrupt = False
        self._mm_model_ids = []
        self._execution_time = 0

    def __call__(self, **kwargs):
        self._pipe_interrupt = False

        # if the node_id is not set, the class was called by the user and it's not part of a workflow,
        # we execute the method directly
        if not self.node_id:
            params = { key: kwargs[key] for key in kwargs if not key.startswith('__') }
            return getattr(self, self.CALLBACK)(**params)

        values = self._validate_params(kwargs)

        execution_time = time.time()

        if self._has_changed(values) or self._is_output_empty():
            self.params.update(values)

            # delete previously loaded models
            # TODO: delete a model only if something changed about it
            if self._mm_model_ids:
                memory_manager.delete_model(self._mm_model_ids, unload=self.FORCE_UNLOAD)
                self._mm_model_ids = []

            try:
                params = { key: self.params[key] for key in self.params if not key.startswith('__') }
                output = getattr(self, self.CALLBACK)(**params)
            except Exception as e:
                self.params = {}
                self.output = get_module_output(self.module_name, self.class_name)
                memory_flush(gc_collect=True)
                raise e

            if isinstance(output, dict):
                # Overwrite output values only for existing keys
                #self.output.update({k: output[k] for k in self.output if k in output})
                self.output = output
            else:
                # If only a single value is returned, assign it to the first output
                first_key = next(iter(self.output))
                self.output[first_key] = output

        self._execution_time = time.time() - execution_time

        # for good measure, flush the memory
        memory_flush()

        return self.output

    def __del__(self):
        del self.params, self.output # TODO: check if this actually works with cuda

        if self._mm_model_ids:
            memory_manager.delete_model(self._mm_model_ids, unload=self.FORCE_UNLOAD)

        memory_flush(gc_collect=True)

    def _validate_params(self, values):
        # get the parameters schema for the module/class
        schema = MODULE_MAP[self.module_name][self.class_name]['params'] if self.module_name in MODULE_MAP and self.class_name in MODULE_MAP[self.module_name] else {}

        # get the default values for the parameters
        defaults = get_module_params(self.module_name, self.class_name)

        # filter out any input args that are not valid parameters and exclude the special fields starting with __
        values = { key: values[key] for key in values if key in defaults and not key.startswith('__') }

        # ensure the values are of the correct type
        for key in values:
            if 'type' in schema[key]:
                # type can be a list, used to allow multiple types with input handles (a helper for the UI)
                # the main type is the first one in the list
                type = (schema[key]['type'][0] if isinstance(schema[key]['type'], list) else schema[key]['type']).lower()

                if type.startswith('int'):
                    values[key] = int(values[key]) if not isinstance(values[key], list) else [int(v) for v in values[key]]
                elif type == 'float':
                    values[key] = float(values[key]) if not isinstance(values[key], list) else [float(v) for v in values[key]]
                elif type.startswith('bool'):
                    values[key] = bool(values[key]) if not isinstance(values[key], list) else [bool(v) for v in values[key]]
                elif type.startswith('str'):
                    values[key] = str(values[key] or '') if not isinstance(values[key], list) else [str(v or '') for v in values[key]]

        # we perform a second pass for cross parameter validation when calling the postProcess function
        for key in values:
            # ensure the value is a valid option (mostly for dropdowns)
            if 'options' in schema[key] and not ('no_validation' in schema[key] and schema[key]['no_validation']):
                options = schema[key]['options']

                # options can be in the format: [ 1, 2, 3 ] or { '1': { }, '2': { }, '3': { } }
                if isinstance(options, list):
                    val = [values[key]] if not isinstance(values[key], list) else values[key]
                    if any(v not in options for v in val):
                        raise ValueError(f"Invalid value for {key}: {values[key]}")
                elif isinstance(options, dict):
                    val = [values[key]] if not isinstance(values[key], list) else values[key]
                    if any(v not in options for v in val):
                        raise ValueError(f"Invalid value for {key}: {values[key]}")
                else:
                    raise ValueError(f"Invalid options for {key}: {options}")

            # call the postProcess function if present
            if 'postProcess' in schema[key]:
                # we pass the value and the entire dict for cross parameter validation
                values[key] = schema[key]['postProcess'](values[key], values)

        # update the default values with the validated values
        defaults.update(values)

        return defaults

    def _has_changed(self, values):
        return any(
            key not in self.params or
            are_different(self.params.get(key), values.get(key))
            for key in values
        )
    
    def _is_output_empty(self):
        return all(value is None for value in self.output.values())
    
    def pipe_callback(self, pipe, step_index, timestep, kwargs):
        import asyncio
        if self.node_id:
            try:
                progress = int((step_index + 1) / pipe._num_timesteps * 100)
                asyncio.run_coroutine_threadsafe(
                    web_server.client_queue.put({
                        "client_id": self._client_id,
                        "data": {
                            "type": "progress",
                            "nodeId": self.node_id,
                            "progress": progress
                        }
                    }), 
                    web_server.event_loop
                )
            except Exception as e:
                logger.warning(f"Error queuing progress update: {str(e)}")

            # interrupt callback
            if self._pipe_interrupt:
                pipe._interrupt = True

        return kwargs
    
    def mm_add(self, model, model_id=None, device=None, priority=2):
        # if the node_id is not set, the class was called directly and we skip the memory manager
        # it's up to the caller to manage the model
        if not self.node_id:
            return model

        if memory_manager.is_cached(model_id):
            self.mm_update(model_id, model=model, priority=priority)
            return model_id

        model_id = f'{self.node_id}.{model_id}' if model_id else f'{self.node_id}.{nanoid.generate(size=8)}'
        device = device if device else str(model.device)

        self._mm_model_ids.append(model_id)
        return memory_manager.add_model(model, model_id, device=device, priority=priority)

    def mm_get(self, model_id):
        model_id = model_id if isinstance(model_id, str) else model_id._mm_id if hasattr(model_id, '_mm_id') else None
        return memory_manager.get_model(model_id) if model_id else None

    def mm_load(self, model_id, device):
        model_id = model_id if isinstance(model_id, str) else model_id._mm_id if hasattr(model_id, '_mm_id') else None
        return memory_manager.load_model(model_id, device) if model_id else None

    def mm_unload(self, model_id):
        model_id = model_id if isinstance(model_id, str) else model_id._mm_id if hasattr(model_id, '_mm_id') else None
        return memory_manager.unload_model(model_id) if model_id else None

    def mm_update(self, model_id, model=None, priority=None, unload=True):
        model_id = model_id if isinstance(model_id, str) else model_id._mm_id if hasattr(model_id, '_mm_id') else None
        return memory_manager.update_model(model_id, model=model, priority=priority, unload=unload) if model_id else None
    
    def mm_inference(self, func, device, exclude=None, no_grad=False):
        exclude_list = []
        if exclude:
            exclude = [exclude] if not isinstance(exclude, list) else exclude
            for model in exclude:
                if isinstance(model, str):
                    exclude_list.append(model)
                elif hasattr(model, '_mm_id'):
                    exclude_list.append(model._mm_id)

        while True:
            try:
                with torch.inference_mode() if not no_grad else torch.no_grad():
                    return func()
            except torch.OutOfMemoryError as e:
                if memory_manager.unload_next(device, exclude=exclude):
                    continue
                else:
                    raise e
    
    def mm_flash_load(self, model, model_id=None, device='cpu', priority=3):
        model_id = f'{self.node_id}.{model_id}' if model_id else f'{self.node_id}.{nanoid.generate(size=8)}'
        device = device if device else str(model.device)

        return memory_manager.flash_load(model, model_id, device=device, priority=priority)


================================================================================
FILE: mellon/server.py
================================================================================

import logging
logger = logging.getLogger('mellon')
from aiohttp import web, WSMsgType
from aiohttp_cors import setup as cors_setup, ResourceOptions
import json
import nanoid
import io
import base64
import re
from importlib import import_module
import asyncio
import traceback
from utils.memory_manager import memory_flush
from copy import deepcopy
import random
import signal
import time

class WebServer:
    def __init__(self, module_map: dict, host: str = "0.0.0.0", port: int = 8080, cors: bool = False, cors_route: str = "*"):
        self.module_map = module_map
        self.node_store = {}
        self.queue = asyncio.Queue()
        self.queue_task = None
        self.host = host
        self.port = port
        self.ws_clients = {}
        self.app = web.Application()
        self.event_loop = None

        self.client_queue = asyncio.Queue()
        self.client_task = None

        self.app.add_routes([web.get('/', self.index),
                             web.get('/nodes', self.nodes),
                             web.get('/view/{format}/{node}/{key}/{index}', self.view),
                             web.get('/custom_component/{module}/{component}', self.custom_component),
                             web.get('/custom_assets/{module}/{file_path}', self.custom_assets),
                             web.post('/graph', self.graph),
                             web.post('/nodeExecute', self.node_execute),                             
                             web.delete('/clearNodeCache', self.clear_node_cache),
                             web.static('/assets', 'web/assets'),
                             web.get('/favicon.ico', self.favicon),
                             web.get('/ws', self.websocket_handler)])

        if cors:
            cors = cors_setup(self.app, defaults={
                cors_route: ResourceOptions(
                    allow_credentials=True,
                    expose_headers="*",
                    allow_headers="*",
                )
            })

            for route in list(self.app.router.routes()):
                cors.add(route)

    def run(self):
        async def shutdown():
            if hasattr(self, 'is_shutting_down') and self.is_shutting_down:
                return
            self.is_shutting_down = True
            
            logger.info("Received shutdown signal. Namárië!")
            self.shutdown_event.set()

            # Cancel all running tasks except the current one
            tasks = [t for t in asyncio.all_tasks() if t is not asyncio.current_task()]
            for task in tasks:
                task.cancel()

            #try:
                # Wait for all tasks to finish
            await asyncio.gather(*tasks, return_exceptions=True)
            #except asyncio.CancelledError:
                #pass  # Ignore cancelled error during shutdown

            # Close all websocket connections
            for ws in list(self.ws_clients.values()):
                try:
                    await ws.close(code=1000, message=b'Server shutting down')
                except Exception:
                    pass  # Ignore any websocket closing errors
            self.ws_clients.clear()

        async def start_app():
            self.shutdown_event = asyncio.Event()
            self.event_loop = asyncio.get_event_loop()
            self.is_shutting_down = False

            # Set up signal handlers
            def signal_handler():
                if not self.is_shutting_down:
                    asyncio.create_task(shutdown())

            try:
                for sig in (signal.SIGINT, signal.SIGTERM):
                    self.event_loop.add_signal_handler(sig, signal_handler)
            except NotImplementedError:
                # For Windows compatibility
                pass

            runner = web.AppRunner(self.app, client_max_size=1024**4)
            await runner.setup()
            site = web.TCPSite(runner, self.host, self.port)

            # Start background tasks
            self.queue_task = asyncio.create_task(self.process_queue())
            self.client_task = asyncio.create_task(self.process_client_messages())

            await site.start()

            try:
                await self.shutdown_event.wait()
            finally:
                await shutdown()
                await runner.cleanup()

        try:
            asyncio.run(start_app())
        except KeyboardInterrupt:
            # On Windows, asyncio.run() may not handle KeyboardInterrupt properly
            pass
        except asyncio.CancelledError:
            pass  # Ignore cancelled error during shutdown

    async def process_client_messages(self):
        while True:
            message = await self.client_queue.get()
            try:
                await self.ws_clients[message["client_id"]].send_json(message["data"])
            except Exception as e:
                logger.error(f"Error sending client message: {str(e)}")
            finally:
                self.client_queue.task_done()

    async def process_queue(self):
        while True:
            item = await self.queue.get()
            try:
                if "kwargs" in item:
                    await self.node_execute_single(item)
                else:
                    await self.graph_execution(item)
            except Exception as e:
                logger.error(f"Error processing queue task: {str(e)}")
                logger.error(f"Error occurred in {traceback.format_exc()}")
                await self.broadcast({
                    "type": "error",
                    "error": "An unexpected error occurred while processing the graph"
                })
            finally:
                self.queue.task_done()

    async def index(self, request):
        response = web.FileResponse('web/index.html')
        response.headers["Cache-Control"] = "no-cache"
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "0"
        return response

    async def favicon(self, request):
        return web.FileResponse('web/favicon.ico')

    """
    HTTP API
    """

    async def custom_component(self, request):
        module = request.match_info.get('module')
        component = request.match_info.get('component')

        path = component.split('/')
        if len(path) > 1:
            module = path[0]
            component = path[1]

        #if module not in self.module_map:
        #    raise web.HTTPNotFound(text=f"Module {module} not found")

        response = web.FileResponse(f'custom/{module}/web/{component}.js')
        response.headers["Content-Type"] = "application/javascript"
        response.headers["Cache-Control"] = "no-cache"
        response.headers["Pragma"] = "no-cache"
        response.headers["Expires"] = "0"
        return response

    async def custom_assets(self, request):
        module = request.match_info.get('module')
        file_path = request.match_info.get('file_path')

        #if module not in self.module_map:
        #    raise web.HTTPNotFound(text=f"Module {module} not found")

        return web.FileResponse(f'custom/{module}/web/assets/{file_path}')

    async def nodes(self, request):
        nodes = {}
        for module_name, actions in self.module_map.items():
            for action_name, action in actions.items():
                params = {}
                groups = {}
                if 'params' in action:
                    params = deepcopy(action['params'])

                    for p in params:
                        # remove attributes that are not needed by the client
                        if 'postProcess' in params[p]:
                            del params[p]['postProcess']

                nodes[f"{module_name}-{action_name}"] = {
                    "label": action.get('label', f"{module_name}: {action_name}"),
                    "module": module_name,
                    "action": action_name,
                    "category": self.slugify(action.get('category', 'default')),
                    "execution_type": action.get('execution_type', 'workflow'),
                    "params": params,
                    "groups": groups,
                }
                if 'style' in action:
                    nodes[f"{module_name}-{action_name}"]["style"] = action['style']
                if 'resizable' in action:
                    nodes[f"{module_name}-{action_name}"]["resizable"] = action['resizable']

        return web.json_response(nodes)
    
    async def view(self, request):
        allowed_formats = ['webp', 'png', 'jpeg', 'glb', 'text']

        format = request.match_info.get('format', 'webp').lower()
        if format not in allowed_formats:
            raise web.HTTPNotFound(text=f"Invalid format: {format}")

        nodeId = request.match_info.get('node')
        key = request.match_info.get('key')
        node = self.node_store.get(nodeId)

        if node is None:
            raise web.HTTPNotFound(text=f"Node {nodeId} not found")
        if key not in node.output:
            raise web.HTTPNotFound(text=f"Key {key} not found in node {nodeId}")   
        
        value = node.output[key]
        if value is None:
            raise web.HTTPNotFound(text=f"No data found for {key}")
        
        if not isinstance(value, list):
            value = [value]

        index = int(request.match_info.get("index", 0))
        if index < 0 or index >= len(value):
            raise web.HTTPNotFound(text=f"Index {index} out of bounds for {key}")
        
        # get additional request parameters
        quality = int(request.rel_url.query.get("quality", 100))
        quality = max(0, min(100, quality))
        scale = float(request.rel_url.query.get("scale", 1))
        scale = max(0.01, min(2, scale))
        filename = request.rel_url.query.get("filename", f"{key}_{index}.{format}")

        value = value[index]
        if scale != 1:
            from PIL.Image import Resampling
            width = int(value.width * scale)
            height = int(value.height * scale)
            value = value.resize((max(width, 1), max(height, 1)), resample=Resampling.BICUBIC)

        # return the value as image
        if format == "webp" or format == "png" or format == "jpeg":
            byte_arr = io.BytesIO()
            value.save(byte_arr, format=format.upper(), quality=quality)
            byte_arr = byte_arr.getvalue()
            return web.Response(
                body=byte_arr,
                content_type="image/webp",
                headers={
                    "Content-Disposition": f"inline; filename={filename}",
                    "Content-Length": str(len(byte_arr)),
                    "Cache-Control": "max-age=31536000, immutable",
                }
            )
        elif format == "glb":
            byte_arr = io.BytesIO()
            byte_arr.write(value)
            byte_arr = byte_arr.getvalue()
            return web.Response(
                body=byte_arr,
                content_type="model/glb",
                headers={
                    "Content-Disposition": f"inline; filename={key}.glb",
                    "Content-Length": str(len(byte_arr)),
                    "Cache-Control": "max-age=31536000, immutable",
                }
            )
        elif format == "text":
            return web.json_response({ "data": value })

    async def clear_node_cache(self, request):
        data = await request.json()
        nodeId = []

        if "nodeId" in data:
            nodeId = data["nodeId"] if isinstance(data["nodeId"], list) else [data["nodeId"]]
        else:
            nodeId = list(self.node_store.keys())

        for node in nodeId:
            if node in self.node_store:
                self.node_store[node] = None
                del self.node_store[node]

        memory_flush(gc_collect=True)

        return web.json_response({
            "type": "cacheCleared",
            "nodeId": nodeId
        })

    async def graph(self, request):
        graph = await request.json()
        await self.queue.put(graph)
        return web.json_response({
            "type": "graphQueued",
            "sid": graph["sid"]
        })

    async def node_execute(self, request):
        data = await request.json()
        await self.queue.put(data)
        return web.json_response({
            "type": "nodeQueued",
            "sid": data["sid"],
        })

    async def node_execute_single(self, data):
        sid = data["sid"]
        module = data["module"]
        action = data["action"]
        kwargs = data["kwargs"]
        node = data["node"]

        if module not in self.module_map:
            raise ValueError("Invalid module")
        if action not in self.module_map[module]:
            raise ValueError("Invalid action")

        if module.endswith(".custom"):
            module = import_module(f"custom.{module.replace('.custom', '')}.{module.replace('.custom', '')}")
        else:
            module = import_module(f"modules.{module}.{module}")
        action = getattr(module, action)

        if not callable(action):
            raise ValueError("Action is not callable")

        node = action()
        node._client_id = sid

        result = {}

        try:
            result = await self.event_loop.run_in_executor(None, lambda: node(**kwargs))
        except Exception as e:
            logger.error(f"Error executing node {module}.{action}: {str(e)}")
            raise e

        await self.client_queue.put({
            "client_id": sid,
            "data": {
                "type": "single_executed",
                "nodeId": node,
                "module": module,
                "action": action,
                "result": result,
            }
        })

    async def graph_execution(self, graph):
        #graph = await request.json()
        sid = graph["sid"]
        nodes = graph["nodes"]
        paths = graph["paths"]

        randomized_fields = {}
        for path in paths:
            for node in path:
                module_name = nodes[node]["module"]
                action_name = nodes[node]["action"]
                logger.debug(f"Executing node {module_name}.{action_name}")

                params = nodes[node]["params"]
                ui_fields = {}
                args = {}
                for p in params:
                    source_id = params[p].get("sourceId")
                    source_key = params[p].get("sourceKey")

                    if "display" in params[p] and params[p]["display"] == "ui":
                        # store ui fields that need to be sent back to the client
                        if params[p]["type"] == "image" or params[p]["type"] == "3d" or params[p]["type"] == "text":
                            ui_fields[p] = { "source": source_key, "type": params[p]["type"] }
                    else:
                        # handle list values (spawn input fields)
                        # if p ends with [d+], it means that the field is part of a list
                        if source_id and re.match(r".*\[\d+\]$", p):
                            spawn_key = re.sub(r"\[\d+\]$", "", p)
                            if not args.get(spawn_key):
                                args[spawn_key] = []
                            elif not isinstance(args[spawn_key], list):
                                args[spawn_key] = [args[spawn_key]]

                            args[spawn_key].append(self.node_store[source_id].output[source_key])
                        else:
                            # if there is a source id, it means that the value comes from a pipeline,
                            # so we follow the connection to the source node and get the associated value
                            # Otherwise we use the value in the params
                            args[p] = self.node_store[source_id].output[source_key] if source_id else params[p].get("value")

                # check if there is a field with the name __random__<param>
                # randomize the field unless it has been already randomized
                for key in args:
                    if key.startswith('__random__') and args[key] is True:
                        if node not in randomized_fields:
                            randomized_fields[node] = []
                        if key in randomized_fields[node]:
                            continue
                        randomized_fields[node].append(key)

                        random_field = key.split('__random__')[1]
                        args[random_field] = random.randint(0, (1<<53)-1) # TODO: allow min/max values
                        #self.node_store[node].params[random_field] = args[random_field]
                        params[random_field]["value"] = args[random_field]
                        await self.client_queue.put({
                            "client_id": sid,
                            "data": {
                                "type": "updateValues",
                                "nodeId": node,
                                "key": random_field,
                                "value": args[random_field]
                            }
                        })

                if module_name not in self.module_map:
                    raise ValueError("Invalid module")
                if action_name not in self.module_map[module_name]:
                    raise ValueError("Invalid action")

                # import the module and get the action
                if module_name.endswith(".custom"):
                    module = import_module(f"custom.{module_name.replace('.custom', '')}.{module_name.replace('.custom', '')}")
                else:
                    module = import_module(f"modules.{module_name}.{module_name}")
                action = getattr(module, action_name)

                # if the node is not in the node store, initialize it
                if node not in self.node_store:
                    self.node_store[node] = action(node)

                self.node_store[node]._client_id = sid

                if not callable(self.node_store[node]):
                    raise TypeError(f"The class `{module_name}.{action_name}` is not callable. Ensure that the class has a __call__ method or extend it from `NodeBase`.")

                # initialize the progress bar
                await self.client_queue.put({
                    "client_id": sid,
                    "data": {
                        "type": "progress",
                        "nodeId": node,
                        "progress": -1
                    }
                })

                try:
                    def execute_node():
                        try:
                            return self.node_store[node](**args)
                        except StopIteration:
                            # Handle StopIteration explicitly to prevent it from propagating
                            return None
                            
                    result = await self.event_loop.run_in_executor(None, execute_node)
                except Exception as e:
                    logger.error(f"Error executing node {module_name}.{action_name}: {str(e)}")
                    raise e

                execution_time = self.node_store[node]._execution_time if hasattr(self.node_store[node], '_execution_time') else 0

                await self.client_queue.put({
                    "client_id": sid,
                    "data": {
                        "type": "executed",
                        "nodeId": node,
                        "time": f"{execution_time:.2f}",
                        #"updateValues": updateValues
                        #"memory": f"{memory_usage/1024**3:.2f}"
                    }
                })

                logger.debug(f"Node {module_name}.{action_name} executed in {execution_time:.3f}s")

                for key in ui_fields:
                    source = ui_fields[key]["source"]
                    source_value = self.node_store[node].output[source]
                    length = len(source_value) if isinstance(source_value, list) else 1
                    format = ui_fields[key]["type"]
                    if format == "image":
                        format = 'webp'
                    elif format == "3d":
                        format = 'glb'
                    else:
                        format = 'text'
                    data = []
                    if format == 'text':
                        data = {
                            "url": f"/view/{format}/{node}/{source}/{0}?t={time.time()}",
                            "value": source_value
                        }
                    else:
                        for i in range(length):
                            if format == 'image':
                                if length > 1:
                                    scale = 0.5 if source_value[i].width > 1024 or source_value[i].height > 1024 else 1
                                else:
                                    scale = 0.5 if source_value[i].width > 2048 or source_value[i].height > 2048 else 1
                                url = f"/view/{format}/{node}/{source}/{i}?scale={scale}&t={time.time()}"
                                data.append({
                                    "url": url,
                                    "width": source_value[i].width,
                                    "height": source_value[i].height
                                })
                            else:
                                url = f"/view/{format}/{node}/{source}/{i}?t={time.time()}"
                                data.append({
                                    "url": url,
                                })

                    await self.client_queue.put({
                        "client_id": sid,
                        "data": {
                            "type": ui_fields[key]["type"],
                            "key": key,
                            "nodeId": node,
                            "data": data
                            #"data": self.to_base64(ui_fields[key]["type"], value)
                        }
                    })

                await asyncio.sleep(0)

        # if updateValues:
        #     await self.client_queue.put({
        #         "client_id": sid,
        #         "data": {
        #             "type": "updateValues",
        #             "values": updateValues
        #         }
        #     })

    """
    WebSocket API
    """

    async def websocket_handler(self, request):
        ws = web.WebSocketResponse()
        await ws.prepare(request)
        sid = request.query.get("sid")
        logger.info(f"WebSocket connection with sid {sid}")
        if sid:
            if sid in self.ws_clients:
                del self.ws_clients[sid]
        else:
            # if the client does not provide a session id, we create one for them one
            sid = nanoid.generate(size=10)

        self.ws_clients[sid] = ws
        await ws.send_json({"type": "welcome", "sid": sid})

        async for msg in ws:
            if msg.type == WSMsgType.TEXT:
                data = json.loads(msg.data)

                try:
                    if data["type"] == "ping":
                        await ws.send_json({"type": "pong"})
                    elif data["type"] == "close":
                        await ws.close()
                        break
                        """
                    elif data["type"] == "module":
                        module_name = data["module"]
                        action_name = data["action"]
                        params = data["data"] if "data" in data else {}

                        if module_name not in self.module_map or action_name not in self.module_map[module_name]:
                            raise ValueError("Invalid module or action")

                        module = import_module(f"modules.{module_name}.{module_name}")
                        action = getattr(module, action_name)
                        result = await action(**params)
                        await ws.send_json({"type": "result", "result": result})

                    elif data["type"] == "graph":
                        graph = data["graph"]
                        for node in graph["nodes"]:
                            module_name = node["module"]
                            action_name = node["action"]
                            params = node["params"]
                            module = import_module(f"modules.{module_name}.{module_name}")
                            action = getattr(module, action_name)
                            result = await action(**params)
                            await ws.send_json({"type": "result", "result": result})
                        """
                    else:
                        raise ValueError("Invalid message type")

                #except KeyError as e:
                #    await ws.send_json({"type": "error", "message": f"Missing required field: {str(e)}"})
                #except ValueError as e:
                #    await ws.send_json({"type": "error", "message": str(e)})
                except Exception as e:
                    logger.error(f"Unexpected error: {str(e)}")
                    await ws.send_json({"type": "error", "message": "An unexpected error occurred"})

            elif msg.type == WSMsgType.ERROR:
                logger.error(f'WebSocket connection closed with exception {ws.exception()}')

        del self.ws_clients[sid]
        logger.info(f'WebSocket connection {sid} closed')

        return ws

    async def broadcast(self, message, client_id=None):
        if client_id:
            if client_id not in self.ws_clients:
                return
            ws_clients = [client_id] if not isinstance(client_id, list) else client_id
        else:
            ws_clients = self.ws_clients

        for client in ws_clients:
            await self.ws_clients[client].send_json(message)


    """
    Helper functions
    """
    def to_base64(self, type, value):
        if type == "image":
            img_byte_arr = io.BytesIO()
            value.save(img_byte_arr, format='WEBP', quality=100)
            img_byte_arr = img_byte_arr.getvalue()
            return base64.b64encode(img_byte_arr).decode('utf-8')
        elif type == "3d":
            glb_byte_arr = io.BytesIO()
            glb_byte_arr.write(value)
            glb_byte_arr = glb_byte_arr.getvalue()
            return base64.b64encode(glb_byte_arr).decode('utf-8')

    def slugify(self, text):
        return re.sub(r'[^\w\s-]', '', text).strip().replace(' ', '-')
1
from modules import MODULE_MAP
from config import config

web_server = WebServer(MODULE_MAP, **config.server)


================================================================================
FILE: modules/Text/Text.py
================================================================================

from mellon.NodeBase import NodeBase

class Text(NodeBase):
    def execute(self, text_field):
        return text_field
    
class Text2(NodeBase):
    def execute(self, text_field):
        return text_field

class DisplayText(NodeBase):
    def execute(self, text_in, text_in_2):
        return {"text_out": text_in + text_in_2}

================================================================================
FILE: modules/Text/__init__.py
================================================================================

MODULE_MAP = {
    "Text": {
        "label": "Text",
        "description": "Text",
        "category": "text",
        "execution_type": "button",
        "params": {
            "text": {
                "label": "Text",
                "type": "string",
                "display": "output",
            },
            "text_field": {
                "label": "Text Field",
                "type": "string",
                "display": "textarea",
            }
        }
    },
    "Text2": {
        "label": "Text2",
        "description": "Text",
        "category": "text",        
        "params": {
            "text": {
                "label": "Text",
                "type": "string",
                "display": "output",
            },
            "text_field": {
                "label": "Text Field",
                "type": "string",
                "display": "textarea",
            }
        }
    },

    "TextContinuous": {
        "label": "Text (Continuous)",
        "description": "Text that runs automatically as you type",
        "category": "text",
        "execution_type": "continuous",
        "params": {
            "text": {
                "label": "Text",
                "type": "string",
                "display": "output",
            },
            "text_field": {
                "label": "Text Field",
                "type": "string",
                "display": "textarea",
            }
        }
    },

    "DisplayText": {
        "label": "Display Text",
        "description": "Display text",
        "category": "text",
        "params": {
            "text_in": {
                "label": "Text Input",
                "type": "string",
                "display": "input",
            },
            "text_in_2": {
                "label": "Text Input",
                "type": "string",
                "display": "input",
            },
            "text_display": {
                "label": "Text",
                "type": "text",
                "display": "ui",
                "source": "text_out",
            }
        }
    }
}

================================================================================
FILE: client/src/App.tsx
================================================================================

import { useEffect } from 'react';
import { 
  ReactFlow,
  //Controls,
  Background,
  BackgroundVariant,
  NodeOrigin,
  useReactFlow,
  Connection,
  IsValidConnection,
  Viewport
} from '@xyflow/react';
import { shallow } from 'zustand/shallow';
import { useNodeState, NodeState, CustomNodeType } from './stores/nodeStore';
import { useNodeRegistryState, NodeRegistryState } from './stores/nodeRegistryStore';
import { useWebsocketState, WebsocketState } from './stores/websocketStore';

import { nanoid } from 'nanoid';

import config from '../config';
import CustomNode from './components/CustomNode';

import '@xyflow/react/dist/base.css';
import './app.css';

const nodeTypes = {
  custom: CustomNode,
};

const selectNodeState = (state: NodeState) => ({
  nodes: state.nodes,
  edges: state.edges,
  onNodesChange: state.onNodesChange,
  onEdgesChange: state.onEdgesChange,
  onEdgeDoubleClick: state.onEdgeDoubleClick,
  onConnect: state.onConnect,
  addNode: state.addNode,
  getParam: state.getParam,
});

const selectNodeRegistryState = (state: NodeRegistryState) => ({
  nodeRegistry: state.nodeRegistry,
  updateNodeRegistry: state.updateNodeRegistry,
});

const selectWebsocketState = (state: WebsocketState) => ({
  connect: state.connect,
});

const nodeOrigin: NodeOrigin = [0, 0];

export default function App() {
  const { nodes, edges, onNodesChange, onEdgesChange, onEdgeDoubleClick, onConnect, addNode, getParam } = useNodeState(selectNodeState, shallow);
  const { nodeRegistry, updateNodeRegistry } = useNodeRegistryState(selectNodeRegistryState, shallow);
  const { connect: connectWebsocket } = useWebsocketState(selectWebsocketState, shallow);
  const { screenToFlowPosition, setNodes, setEdges, setViewport } = useReactFlow();

  // Load the list of available nodes
  useEffect(() => {
    const stored = localStorage.getItem('workflow');
    if (stored) {
      const { nodes: storedNodes, edges: storedEdges } = JSON.parse(stored);

      setNodes(storedNodes || []);
      setEdges(storedEdges || []);
    }

    updateNodeRegistry();
    connectWebsocket('ws://' + config.serverAddress + '/ws');
  }, []);

  // Save viewport position when it changes
  const onMoveEnd = (_: MouseEvent | TouchEvent | null, viewport: Viewport) => {
    const workflow = JSON.parse(localStorage.getItem('workflow') || '{}');
    workflow.viewport = viewport;
    localStorage.setItem('workflow', JSON.stringify(workflow));
  };
  
  // TODO: probably need to use useCallback
  const onWorkflowDrop = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();
    const file = event.dataTransfer.files[0];
    if (file?.type !== 'application/json') return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const flow = JSON.parse(e.target?.result as string);
      const { x = 0, y = 0, zoom = 1 } = flow.viewport;
      setViewport({ x, y, zoom });
      setNodes(flow.nodes);
      setEdges(flow.edges);
    };

    reader.readAsText(file);
  };

  // Handle drag and drop
  const onDragOver = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();

    if (event.dataTransfer.types.includes('Files')) {
      event.dataTransfer.dropEffect = 'copy';
      return;
    }
    event.dataTransfer.dropEffect = 'move';
  }

  const onDrop = (event: React.DragEvent<HTMLDivElement>) => {
    event.preventDefault();

    // Handle workflow file drops
    if (event.dataTransfer.files.length > 0) {
      onWorkflowDrop(event);
      return;
    }

    if (!nodeRegistry) return;

    const key = event.dataTransfer.getData('text/plain');
    if (!key || !nodeRegistry[key]) return;

    const nodeData = nodeRegistry[key];

    const position = screenToFlowPosition({
      x: event.clientX,
      y: event.clientY,
    });

    const newNode = {
      id: nanoid(),
      type: 'custom', // for now we only have custom type
      position,
      data: nodeData,
    };

    addNode(newNode as CustomNodeType);
  }

  const isValidConnection = (connection: Connection) => {
    if (!connection.sourceHandle || !connection.targetHandle) return false;

    // prevent self-loops
    if (connection.source === connection.target) return false;

    let sourceType = getParam(connection.source, connection.sourceHandle, 'type');
    let targetType = getParam(connection.target, connection.targetHandle, 'type');
    sourceType = Array.isArray(sourceType) ? sourceType : [sourceType];
    sourceType.push('any');
    targetType = Array.isArray(targetType) ? targetType : [targetType];

    if (!sourceType.some((type: string) => targetType.includes(type))) return false;

    return true;
  }

  // Get stored viewport or use defaults
  const defaultViewport = (() => {
    const stored = localStorage.getItem('workflow');
    if (stored) {
      const { viewport } = JSON.parse(stored);
      if (viewport) {
        return viewport;
      }
    }
    return { x: 0, y: 0, zoom: 1 };
  })();

  return (
    <ReactFlow
      nodes={nodes}
      edges={edges}
      nodeTypes={nodeTypes}
      onNodesChange={onNodesChange}
      onEdgesChange={onEdgesChange}
      onEdgeDoubleClick={(_, edge) => onEdgeDoubleClick(edge.id)}
      isValidConnection={isValidConnection as IsValidConnection}
      onConnect={onConnect}
      nodeOrigin={nodeOrigin}
      onDragOver={onDragOver}
      onDrop={onDrop}
      onMoveEnd={onMoveEnd}
      edgesReconnectable={true}
      defaultViewport={defaultViewport}
      minZoom={0.1}
      maxZoom={1.2}
      //connectionRadius={18}
      //fitView
      proOptions={{hideAttribution: true}}
      deleteKeyCode={['Backspace', 'Delete']}      
    >
      {/* <Controls position="bottom-right" /> */}
      <Background variant={BackgroundVariant.Dots} gap={16} size={1} color="rgba(255, 255, 255, 0.3)" />
    </ReactFlow>
  );
}


================================================================================
FILE: client/src/main.tsx
================================================================================

import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import {ReactFlowProvider } from '@xyflow/react'

import { createTheme, ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import "@fontsource/jetbrains-mono/latin-400.css";
import "@fontsource/jetbrains-mono/latin-700.css";

import { WebSocketProvider } from './components/WebsocketContext';

const themeOptions = createTheme({
  components: {
    MuiAccordionSummary: {
      styleOverrides: {
        root: {
          fontFamily: 'JetBrains Mono',
        },
      },
    },
  },
  palette: {
    mode: 'dark',
    primary: {
      main: '#ffb300',
    },
    secondary: {
      main: '#00695f',
    },
    background: {
      default: '#121212',
      paper: '#1a1a1a',
    },
  },
  typography: {
    fontSize: 14,
    fontFamily: 'JetBrains Mono',
  },
  /* Disable all transitions
  transitions: {
    create: () => 'none',
  }
  */
});

import App from './App.tsx'
import Box from '@mui/material/Box';
import ToolBar from './components/ToolBar.tsx';
import ActionBar from './components/ActionBar.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <ThemeProvider theme={themeOptions}>
      <CssBaseline />
      <ReactFlowProvider>
        <Box sx={{
          display: 'flex',
          flexDirection: 'column',
          height: '100vh',
          width: '100vw',
          overflow: 'hidden',
        }}>
          <ActionBar />
          <Box sx={{
            display: 'flex',
            flex: 1,
            minHeight: 0,
            height: '100%',
          }}>
            <ToolBar />
            <Box sx={{ flex: 1, height: '100%' }}>
              <WebSocketProvider>
                <App />          
              </WebSocketProvider>
            </Box>
          </Box>
        </Box>
      </ReactFlowProvider>
    </ThemeProvider>
  </StrictMode>
)


================================================================================
FILE: client/src/stores/nodeRegistryStore.ts
================================================================================

import { createWithEqualityFn } from 'zustand/traditional';
import config from '../../config';

type NodeType = {
    [key: string]: {
        label: string
        module: string
        action: string
        category: string
        params?: { [key: string]: any }
    }
}

export type NodeRegistryState = {
    nodeRegistry: NodeType;
    updateNodeRegistry: () => Promise<void>;
}

export const useNodeRegistryState = createWithEqualityFn<NodeRegistryState>((set) => ({
    nodeRegistry: {},
    updateNodeRegistry: async () => {
        try {
            const response = await fetch('http://' + config.serverAddress + '/nodes')
            const data = await response.json()
            set({ nodeRegistry: data })
        } catch (error) {
            console.error('Can\'t connect to route `/nodes`', error)
        }
    },
}))

================================================================================
FILE: client/src/stores/nodeStore.ts
================================================================================

import {
    Edge,
    Node,
    OnConnect,
    NodeChange,
    EdgeChange,
    OnNodesChange,
    OnEdgesChange,
    applyNodeChanges,
    applyEdgeChanges,
    Connection,
    getOutgoers,
    getIncomers,
} from '@xyflow/react';
import { createWithEqualityFn } from 'zustand/traditional';
import { nanoid } from 'nanoid';
import { useWebsocketState } from './websocketStore';

import config from '../../config';

export type GroupParams = {
    key: string;
    display: 'group' | 'collapse';
    label?: string | null;
    hidden?: boolean;
    disabled?: boolean;
    open?: boolean;
    direction?: 'row' | 'column';
}

export type NodeParams = {
    type?: string | string[];
    label?: string;
    display?: string;
    value?: any;
    spawn?: boolean;
    options?: any;
    default?: any;
    description?: string;
    source?: string;
    min?: number;
    max?: number;
    step?: number;
    group?: GroupParams;
    style?: { [key: string]: string };
    no_validation?: boolean;
    disabled?: boolean;
    hidden?: boolean;
    onChange?: any;
    icon?: string;
};

type NodeData = {
    module: string;
    action: string;
    category: string;
    execution_type: 'workflow' | 'button' | 'continuous';
    params: { [key: string]: NodeParams };
    cache?: boolean;
    time?: number;
    memory?: number;
    label?: string;
    description?: string;
    resizable?: boolean;
    groups?: { [key: string]: { disabled?: boolean, hidden?: boolean, open?: boolean } };
    style?: { [key: string]: string };
};

type StoredWorkflow = {
    nodes: CustomNodeType[];
    edges: Edge[];
    viewport?: { x: number; y: number; zoom: number };
  };

export type CustomNodeType = Node<NodeData, 'custom'>;

// Data format for API export
type APINodeData = {
    // TODO: we also need a workflow id probably
    module: string;
    action: string;
    params: {
        [key: string]: {
            sourceId?: string,
            sourceKey?: string,
            value?: any,
            display?: string,
            type?: string | string[]
        }
    };
};

type GraphExport = {
    sid: string;
    nodes: { [key: string]: APINodeData };
    paths: string[][];
};

const formatAPIData = (node: CustomNodeType, edge: Edge[]): APINodeData => {
    const inputEdges = edge.filter(e => e.target === node.id);
    const params: APINodeData['params'] = {};

    Object.entries(node.data.params).forEach(([key, param]) => {
        // We don't need to export output parameters
        if (param.display === 'output') {
            return;
        }

        const edge = inputEdges.find(e => e.targetHandle === key);

        params[key] = {
            sourceId: edge?.source ?? undefined,
            sourceKey: (edge ? edge.sourceHandle : param.source) ?? undefined,
            value: param.value ?? undefined,
            display: param.display ?? undefined,
            type: param.type ?? undefined
        };
    });

    return {
        module: node.data.module,
        action: node.data.action,
        params
    };
};

/*
const findOutputNode = (nodes: CustomNodeType[], edges: Edge[]): CustomNodeType[] => {
    const outputNodes = new Set(edges.map(edge => edge.source));
    return nodes.filter(node => !outputNodes.has(node.id));
};
*/

const buildPath = (
    currentNode: string,
    nodes: CustomNodeType[],
    edges: Edge[],
    visited: Set<string> = new Set()
): string[] => {
    if (visited.has(currentNode)) return []; // Prevent cycles
    visited.add(currentNode);

    // Get all incoming edges to this node
    //const incomingEdges = edges.filter(edge => edge.target === currentNode);
    const node = nodes.find(n => n.id === currentNode);
    if (!node) return [];
    
    const incomingNodes = getIncomers(node, nodes, edges);

    // If this is an input node (no incoming edges), return just this node
    if (incomingNodes.length === 0) {
        return [currentNode];
    }

    const inputPaths = incomingNodes.flatMap(sourceNode =>
        buildPath(sourceNode.id, nodes, edges, new Set(visited))
    );

    return [...inputPaths, currentNode];
};

export type NodeState = {
    nodes: CustomNodeType[];
    edges: Edge[];
    onNodesChange: OnNodesChange<CustomNodeType>;
    onEdgesChange: OnEdgesChange;
    onEdgeDoubleClick: (id: string) => void;
    onConnect: OnConnect;
    addNode: (node: CustomNodeType) => void;
    setParamValue: (id: string, key: string, value: any) => void;
    setParam: (id: string, param: string, value: any, key?: keyof NodeParams) => void;
    getParam: (id: string, param: string, key: keyof NodeParams) => any;
    setNodeExecuted: (id: string, cache: boolean, time: number, memory: number) => void;
    exportGraph: (sid: string) => GraphExport;
    updateLocalStorage: () => void;
    runSubGraph: (sid: string, nodeId: string) => Promise<void>;
};

export const useNodeState = createWithEqualityFn<NodeState>((set, get) => ({
    nodes: JSON.parse(localStorage.getItem('workflow') || '{"nodes":[]}').nodes || [],
    edges: JSON.parse(localStorage.getItem('workflow') || '{"edges":[]}').edges || [],

    onNodesChange: async (changes: NodeChange<CustomNodeType>[]) => {
        const newNodes = applyNodeChanges(changes, get().nodes);
        set({ nodes: newNodes });

        // Save to localStorage after changes
        const stored = localStorage.getItem('workflow');
        const { viewport } = stored ? JSON.parse(stored) : { viewport: { x: 0, y: 0, zoom: 1 } };
        const workflow: StoredWorkflow = { nodes: newNodes, edges: get().edges, viewport };
        localStorage.setItem('workflow', JSON.stringify(workflow));
        
        // delete the server cache for the deleted nodes
        if (changes.some(change => change.type === 'remove')) {
            // Create an array of node ids to delete
            const nodeIds = changes.filter(change => change.type === 'remove').map(change => change.id);
            
            try {
                await fetch('http://' + config.serverAddress + '/clearNodeCache', {
                    method: 'DELETE',
                    body: JSON.stringify({ nodeId: nodeIds }),
                });
            } catch (error) {
                console.error('Can\'t connect to server to clear cache:', error);
                // TODO: should we retry?
            }
        }
    },
    onEdgesChange: (changes: EdgeChange<Edge>[]) => {
        const newEdges = applyEdgeChanges(changes, get().edges);

        // Handle array disconnections
        const removedEdges = changes.filter(change => change.type === 'remove');
        for (const removedEdge of removedEdges) {
            const edge = get().edges.find(e => e.id === removedEdge.id);
            const spawnHandle = get().getParam(edge?.target!, edge?.targetHandle!, 'spawn');
            if (edge && spawnHandle) {
                const targetNode = get().nodes.find(n => n.id === edge.target);
                if (targetNode) {
                    // Remove the specific parameter that was disconnected
                    set({
                        nodes: get().nodes.map(node => {
                            if (node.id === edge.target) {
                                const { [edge.targetHandle!]: _, ...remainingParams } = node.data.params;
                                return {
                                    ...node,
                                    data: {
                                        ...node.data,
                                        params: remainingParams
                                    }
                                };
                            }
                            return node;
                        })
                    });
                }
            }
        }

        set({ edges: newEdges });
        get().updateLocalStorage();
    },
    onEdgeDoubleClick: (id: string) => {
        const edgeChange: EdgeChange = {
            id,
            type: 'remove'
        };
        
        // Use the existing onEdgesChange handler to process the removal
        get().onEdgesChange([edgeChange]);
    },
    onConnect: (conn: Connection) => {
        const updatedEdges = get().edges.filter(
            edge => !(edge.target === conn.target && edge.targetHandle === conn.targetHandle)
        );

        // find the color of the target handle
        const targetHandleEl = document.getElementById(conn.target)?.querySelector(`[data-key="${conn.targetHandle}"] .react-flow__handle`);
        const backgroundColor = targetHandleEl ? window.getComputedStyle(targetHandleEl).backgroundColor : '#aaaaaa';
        const newEdge = { ...conn, id: nanoid(), style: { stroke: backgroundColor } };
        const newEdges = [...updatedEdges, newEdge];
        const spawnHandle = get().getParam(conn.target, conn.targetHandle!, 'spawn');

        // Check if this connection is replacing an existing one
        const isReconnection = get().edges.some(
            edge => edge.target === conn.target && edge.targetHandle === conn.targetHandle
        );

        // Handle array connections
        if (spawnHandle && !isReconnection) {
            const targetNode = get().nodes.find(n => n.id === conn.target);
            if (targetNode) {
                const baseParamKey = conn.targetHandle!.replace(/(\[\d*\])?$/, '');
                const arrayParams = Object.keys(targetNode.data.params)
                    .filter(k => k.startsWith(baseParamKey));

                // we can spawn maximum 32 array parameters
                if (arrayParams.length > 32) {
                    return;
                }

                // find the biggest index of the array params
                const nextIndex = Math.max(...arrayParams.map(k => {
                    const match = k.match(/\[\d*\]$/);
                    return match ? parseInt(match[0].replace('[', '').replace(']', '') || '0') : 0;
                }));
                const newParamKey = `${baseParamKey}[${nextIndex + 1}]`;

                // Clone the base parameter
                const baseParam = targetNode.data.params[conn.targetHandle!];

                // Reorder parameters to keep array fields together
                const orderedParams: { [key: string]: NodeParams } = {};
                Object.entries(targetNode.data.params).forEach(([key, value]) => {
                    orderedParams[key] = value;
                    // Insert the new parameter right after finding an array parameter of the same type
                    if (key === conn.targetHandle) {
                        orderedParams[newParamKey] = { ...baseParam };
                    }
                });

                set({
                    nodes: get().nodes.map(node => {
                        if (node.id === conn.target) {
                            return {
                                ...node,
                                data: {
                                    ...node.data,
                                    params: orderedParams
                                }
                            };
                        }
                        return node;
                    })
                });
            }
        }

        set({ edges: newEdges });
        get().updateLocalStorage();
    },
    addNode: (node: CustomNodeType) => {
        //const newNode = { ...node, dragHandle: 'header' };

        // Set initial value for all parameters, TODO: needed? default value should be exported by the server
        if (node.data?.params) {
            Object.keys(node.data.params).forEach(key => {
                const param = node.data.params[key];
                node.data.params[key] = {
                    ...param,
                    value: param.value ?? param.default
                };
            });
        }
        const newNodes = [...get().nodes, node];
        set({ nodes: newNodes });

        // Save to localStorage after changes
        const workflow: StoredWorkflow = { nodes: newNodes, edges: get().edges };
        localStorage.setItem('workflow', JSON.stringify(workflow));
    },
    setParamValue: (id: string, key: string, value: any) => {
        set({
            nodes: get().nodes.map((node) => (
                node.id === id
                ? {
                    ...node,
                    data: {
                        ...node.data,
                        params: {
                            ...node.data.params,
                            [key]: {
                                ...node.data.params[key],
                                value: value
                            }
                        }
                    }
                }
                : node
            ))
        });

        // Keep localStorage in sync
        get().updateLocalStorage();

        // If this node is continuous, call runSubGraph
        const node = get().nodes.find((n) => n.id === id);
        if (node?.data.execution_type === 'continuous') {
            const { sid } = useWebsocketState.getState();
            if (sid) {
                // partial-run the subgraph that includes this node
                get().runSubGraph(sid, id);
            }
        }
    },
    updateLocalStorage: () => {
        const stored = localStorage.getItem('workflow');
        const { viewport } = stored ? JSON.parse(stored) : { viewport: { x: 0, y: 0, zoom: 1 } };
        const workflow: StoredWorkflow = { nodes: get().nodes, edges: get().edges, viewport };
        localStorage.setItem('workflow', JSON.stringify(workflow));
    },
    setParam: (id: string, param: string, value: any, key?: keyof NodeParams) => {
        const k = key ?? 'value';

        if (k !== 'group') {
            set({
                nodes: get().nodes.map((node) => (
                    node.id === id
                    ? {
                        ...node,
                        data: {
                            ...node.data,
                            params: {
                                ...node.data.params,
                                [param]: {
                                    ...node.data.params[param],
                                    [k]: value
                                }
                            }
                        }
                    }
                    : node
                )) // is this real life?
            });
        } else {
            set({
                nodes: get().nodes.map((node) => (
                    node.id === id
                    ? { ...node, data: { ...node.data, groups: { ...node.data.groups, [param]: { ...node.data.groups?.[param], ...value } } } }
                    : node
                ))
            });
        }

        get().updateLocalStorage();
    },
    getParam: (id: string, param: string, key: keyof NodeParams) => {
        const node = get().nodes.find(n => n.id === id);
        return node?.data.params[param][key];
    },
    setNodeExecuted: (id: string, cache: boolean, time: number, memory: number) => {
        set({ nodes: get().nodes.map(node => (node.id === id ? { ...node, data: { ...node.data, cache, time, memory } } : node)) });
    },
    exportGraph: (sid: string) => {
        const { nodes, edges } = get();
        const outputNodes = nodes.filter(node => getOutgoers(node, nodes, edges).length === 0); //findOutputNode(nodes, edges);
        const paths = outputNodes.map(node => buildPath(node.id, nodes, edges));

        const nodesLookup = nodes.reduce((acc, node) => ({
            ...acc,
            [node.id]: formatAPIData(node, edges)
        }), {});

        const graphData: GraphExport = {
            sid: sid ?? '',
            nodes: nodesLookup,
            paths
        };

        return graphData;
    },
    runSubGraph: async (sid: string, nodeId: string) => {
        const { nodes, edges } = get();
        
        // Start from the triggering node and find all paths to outputs
        const allPaths: string[][] = [];
        const visited = new Set<string>();
        
        const buildForwardPath = (currentId: string, currentPath: string[] = []): void => {
            if (visited.has(currentId)) return;
            visited.add(currentId);
            
            const newPath = [...currentPath, currentId];
            const node = nodes.find(n => n.id === currentId);
            if (!node) return;
            
            const outgoers = getOutgoers(node, nodes, edges);
            
            // If this is an output node (no outgoers), add the path
            if (outgoers.length === 0) {
                allPaths.push(newPath);
            }
            
            // Continue building paths through outgoing nodes
            outgoers.forEach(outNode => {
                buildForwardPath(outNode.id, newPath);
            });
        };

        // Build all forward paths starting from our node
        buildForwardPath(nodeId);
        
        // If no downstream paths found, just run this node
        if (allPaths.length === 0) {
            allPaths.push([nodeId]);
        }

        // Format nodes just like exportGraph does
        const nodesLookup = nodes.reduce((acc, node) => ({
            ...acc,
            [node.id]: formatAPIData(node, edges)
        }), {});

        // Create and send the sub-graph
        const subGraph = {
            sid,
            nodes: nodesLookup,
            paths: allPaths
        };

        try {
            await fetch('http://' + config.serverAddress + '/graph', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(subGraph),
            });
        } catch (error) {
            console.error('Error connecting to API server:', error);
        }
    }
}));


================================================================================
FILE: client/src/stores/websocketStore.ts
================================================================================

import { createWithEqualityFn } from 'zustand/traditional';
import { useNodeState } from './nodeStore';
import { nanoid } from 'nanoid';

/*
const selectNodeState = (state: NodeState) => ({
    nodes: state.nodes,
    setParamValue: state.setParamValue,
});
*/
type NodeProgress = {
    value: number;
    type: 'determinate' | 'indeterminate' | 'disabled';
};

export type WebsocketState = {
    address: string | null;
    sid: string | null;
    socket: WebSocket | null;
    isConnected: boolean;
    reconnectTimer: NodeJS.Timeout | undefined;

    connect: (addr?: string) => void;
    disconnect: () => void;

    threeData: Record<string, string>;
    updateThreeData: (nodeId: string, key: string, value: string) => void;

    nodeProgress: Record<string, NodeProgress>;
    updateNodeProgress: (nodeId: string, progress: number) => void;
}

export const useWebsocketState = createWithEqualityFn<WebsocketState>((set, get) => ({
    address: null,
    sid: null,
    socket: null,
    isConnected: false,
    reconnectTimer: undefined,

    nodeProgress: {},
    updateNodeProgress: (nodeId: string, progress: number) => {
        set((state) => ({
            nodeProgress: {
                ...state.nodeProgress,
                [nodeId]: {
                    value: progress < 0 ? 0 : progress,
                    type: progress === -1 ? 'indeterminate' : progress === -2 ? 'disabled' : 'determinate'
                }
            }
        }));
    },

    threeData: {},
    updateThreeData: (nodeId: string, key: string, value: string) => {
        set((state) => ({
            threeData: {
                ...state.threeData,
                [`${nodeId}-${key}`]: value
            }
        }));
    },

    connect: async (addr?: string) => {
        const { reconnectTimer } = get();
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            set({ reconnectTimer: undefined });
        }
    
        let { address, sid, socket } = get();

        if (socket) {
            console.info('WebSocket already created.');
            return;
        }

        if (!address && !addr) {
            console.error('Cannot connect to WebSocket. No address specified.');
            return;
        }

        if (addr && addr !== address) {
            address = addr;
            set({ address });
        }

        if (!sid) {
            sid = nanoid(10);
            set({ sid });
        }

        socket = new WebSocket(`${address}?sid=${sid}`);
        set({ socket });

        const onOpen = () => {
            set({ isConnected: true, reconnectTimer: undefined });
            console.info('WebSocket connection established');
        };

        const onClose = () => {
            clearTimeout(get().reconnectTimer); // just to be sure
            set({ socket: null, isConnected: false, reconnectTimer: undefined });
            console.info('WebSocket connection closed');

            const timer = setTimeout(() => {
                console.info('Trying to reconnect...');
                get().connect();
            }, 500);

            set({ reconnectTimer: timer });
        };

        const onMessage = (event: MessageEvent) => {
            //const { setNodeExecuted } = useNodeState((state: NodeState) => ({ setNodeExecuted: state.setNodeExecuted }), shallow);
            const message = JSON.parse(event.data);

            if (message.type === 'welcome') {
                if (!message.sid) {
                    console.error('Invalid welcome message.');
                    return;
                }
                if (message.sid !== sid) {
                    console.info('Session ID mismatch. Updating.', message.sid, sid);
                    set({ sid: message.sid });
                }
                console.info('WebSocket connection established');
            }
            else if (message.type === 'progress') {
                if (!message.progress || !message.nodeId ) {
                    return;
                }
                get().updateNodeProgress(message.nodeId, message.progress);
            }
            else if (message.type === 'image') {
                if (!message.nodeId || !message.key || !message.data) {
                    console.error('Invalid image message. Ignoring.');
                    return;
                }
                useNodeState.getState().setParam(message.nodeId, message.key, message.data);
            }
            else if (message.type === '3d') {
                if (!message.nodeId || !message.key) {
                    console.error('Invalid 3D model message. Ignoring.');
                    return;
                }
                const data = message.data || { url: null };
                useNodeState.getState().setParam(message.nodeId, message.key, data);

                // For blob data
                // const blob = new Blob([message.data], { type: 'model/gltf-binary' });
                // const url = URL.createObjectURL(blob);
                // el.setAttribute('url', url);
            }
            else if (message.type === 'text') {
                if (!message.nodeId || !message.key || !message.data) {
                    console.error('Invalid text message. Ignoring.');
                    return;
                }
                useNodeState.getState().setParam(message.nodeId, message.key, message.data);
            }
            else if (message.type === 'executed') {
                console.info('executed', message);
                if (!message.nodeId) {
                    console.error('Invalid executed message. Ignoring.');
                    return;
                }
                useNodeState.getState().setNodeExecuted(message.nodeId, true, message.time || 0, message.memory || 0);
                get().updateNodeProgress(message.nodeId, -2);

                // if ('updateValues' in message) {
                //     Object.entries(message.updateValues).forEach(([k, v]) => {
                //         useNodeState.getState().setParamValue(message.nodeId, k, v);
                //     });
                // }
            }
            else if (message.type === 'updateValues') {
                if (!message.nodeId || !message.key || !message.value) {
                    console.error('Invalid updateValues message. Ignoring.');
                    return;
                }
                useNodeState.getState().setParamValue(message.nodeId, message.key, message.value);
            }
            else if (message.type === 'error') {
                console.error('Error:', message.error);
                set({ nodeProgress: {} });
            }
        };

        //const onError = (event: Event) => {
        //    console.error('WebSocket error:', event);
        //};

        socket.addEventListener('open', onOpen);
        socket.addEventListener('close', onClose);
        socket.addEventListener('message', onMessage);
        //socket.addEventListener('error', onError);
    },
    disconnect: async () => {
        const { reconnectTimer } = get();
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
        }
        set((state) => {
            if (state.socket) {
                state.socket.close();
            }
            return ({
                socket: null,
                isConnected: false,
                reconnectTimer: undefined,
            });
        });
    },
    destroy: async () => {
        get().disconnect();
        set({ address: null, sid: null });
    },
}))


================================================================================
FILE: client/src/components/ActionBar.tsx
================================================================================

import { useCallback } from 'react'
import { useReactFlow } from '@xyflow/react'
import { useTheme } from '@mui/material/styles'
import Box from '@mui/material/Box'
import Typography from '@mui/material/Typography'
import Button from '@mui/material/Button'
import Stack from '@mui/material/Stack'
//import IconButton from '@mui/material/IconButton'

//import WifiIcon from '@mui/icons-material/Wifi';
import { shallow } from 'zustand/shallow'
import { NodeState, useNodeState } from '../stores/nodeStore'
import { WebsocketState, useWebsocketState } from '../stores/websocketStore'
import config from '../../config';

// Icons
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import GetAppIcon from '@mui/icons-material/GetApp';
import InsertDriveFileOutlinedIcon from '@mui/icons-material/InsertDriveFileOutlined';
import SvgIcon from '@mui/material/SvgIcon'

export default function AppToolbar() {
  const { setNodes, setEdges, toObject, setViewport } = useReactFlow();
  const theme = useTheme()
  const { exportGraph } = useNodeState((state: NodeState) => ({ exportGraph: state.exportGraph }), shallow);
  const { sid, isConnected } = useWebsocketState((state: WebsocketState) => ({ sid: state.sid, isConnected: state.isConnected }), shallow);
  const onRun = async () => {
    if (!isConnected) {
      console.error('Not connected to WebSocket server');
      return;
    }

    const graphData = exportGraph(sid ?? '');

    console.info(graphData);

    try {
      await fetch('http://' + config.serverAddress + '/graph', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(graphData),
      });
    } catch (error) {
      console.error('Error connecting to API server:', error);
    }
  }

  const onExport = useCallback(() => {
    const flow = toObject();
    const jsonString = JSON.stringify(flow, null, 2);

    // Create blob and download
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'workflow.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  }, [toObject]);

  const onNew = useCallback(() => {
    // Clear the nodes and edges
    setNodes([]);
    setEdges([]);
    
    // Clear localStorage
    localStorage.removeItem('workflow');
    
    const defaultViewport = { x: 0, y: 0, zoom: 1 };
    localStorage.setItem('workflow', JSON.stringify({ nodes: [], edges: [], viewport: defaultViewport }));
    setViewport(defaultViewport);
  }, [setNodes, setEdges]);

  return (
    <Box sx={{
      backgroundColor: theme.palette.background.paper,
      padding: 1,
      borderBottom: `1px solid ${theme.palette.divider}`,
    }}>
      <Stack
        direction="row"
        spacing={0}
        sx={{ justifyContent: "space-between", alignItems: "center" }}
      >
        <Stack
          direction="row"
          spacing={0}
          sx={{ justifyContent: "space-between", alignItems: "center" }}
        >
          <Box sx={{ display: 'flex', alignItems: 'center', ml: 3 }}>
            <SvgIcon>
              <svg viewBox="0 0 28 12" style={{ width: '40px', height: '100%', marginRight: '4px' }} xmlSpace="preserve" xmlns="http://www.w3.org/2000/svg">
                <path style={{ fill: `${theme.palette.primary.main}` }} d="M1.815 11.95c0-.08.421-.784.936-1.565 1.217-1.848 2.4-5.662 2.161-6.965-.29-1.577-1.831-1.974-3.759-.97-1.334.696-1.513.496-.524-.578C1.682.725 3.286.007 4.807 0 6.57-.008 7.485 1.07 7.149 2.866c-.07.373-.077.665-.052.682.026.018.683-.505 1.368-1.122C10.205.861 11.458.232 13.026.266c2.323.054 2.982 1.899 3.153 2.636l.233 1.008 1.067-1.027C19.471.963 21.347.29 22.372.233c1.025-.058 1.686.18 2.376.915 1.69 1.801 1.441 4.275-.753 7.237-.963 1.3-1.166 1.726-.822 1.724.56.082 2.803-.211 3.602-.475.801-.262 1.16-.602 1.22-.507.047.072-.253.528-.4.695-.388.431-1.228 1.447-3.416 1.87-1.432.276-3.066.272-7.87.011-5.772-.312-8.614-.405-13.131.207-.75.101-1.364.12-1.364.041zM7.704 9.96c5.39-.463 5.243-.537 5.872-1.863 1.538-3.246-.245-6.387-3.297-5.802-1.09.209-2.7 1.904-4.049 4.262a522.55 522.55 0 0 1-1.532 2.666c-.286.489-.418.888-.296.886.123 0 1.609-.004 3.302-.149zm14.219-.594c.924-.558 1.842-2.346 1.842-3.592 0-1.864-1.516-3.591-3.15-3.591-1.511 0-2.565.904-4.441 3.81-.958 1.483-1.918 2.724-2.028 2.877-.328.462.122.959 4.76 1.064 1.702.038 2.42-.209 3.017-.568z"/>
              </svg>
            </SvgIcon>
          </Box>

          <Box sx={{ mr: 3 }}>
            <Typography variant="h6" sx={{ fontSize: '20px', padding: '0px 4px' }}>
              Mellon
            </Typography>
          </Box>

          <Box>
          <Button
              variant="text"
              startIcon={<InsertDriveFileOutlinedIcon />}
              onClick={onNew}
              sx={{ mr: 1 }}  // Add margin between buttons
            >
              New
            </Button>
            <Button
              variant="text"
              startIcon={<GetAppIcon />}
              onClick={onExport}
            >
              Export
            </Button>
          </Box>
        </Stack>
        <Box>
          <Button
            variant="contained"
            startIcon={<PlayArrowIcon />}
            onClick={onRun}
            disabled={!isConnected}
            
            sx={{
              background: `linear-gradient(100deg, ${theme.palette.primary.main} 25%, #ff4259 90%)`,
              '&.Mui-disabled': {
                background: `linear-gradient(100deg, #6a6a6a, #303030)`,
                color: '#1a1a1a',
              }
            }}
          >
            Run
          </Button>
        </Box>
        <Box></Box>
      </Stack>
    </Box>
  )
}


================================================================================
FILE: client/src/components/CustomNode.tsx
================================================================================

import { memo } from 'react';
import { NodeProps, NodeResizeControl } from '@xyflow/react';
import { shallow } from 'zustand/shallow';

// MUI components
import { useTheme } from '@mui/material/styles'
import Box from '@mui/material/Box';
import Chip from '@mui/material/Chip';
import Stack from '@mui/material/Stack';
import Button from '@mui/material/Button';

// Icons
import DeleteForeverIcon from '@mui/icons-material/DeleteForever';
import AccessAlarmIcon from '@mui/icons-material/AccessAlarm';
import PlayArrowIcon from '@mui/icons-material/PlayArrow';
import LinearProgress from '@mui/material/LinearProgress';
import OpenInFullIcon from '@mui/icons-material/OpenInFull';

import config from '../../config';
import { groupParams } from './utils/groupParams';
import { useNodeState, NodeState, CustomNodeType, NodeParams } from '../stores/nodeStore';
import { useWebsocketState } from '../stores/websocketStore';
import NodeContent from './NodeContent';

import { deepEqual } from './utils/deepEqual';

const CustomNode = memo((props: NodeProps<CustomNodeType>) => {
    const theme = useTheme();
    const { setParam, setNodeExecuted, runSubGraph } = useNodeState((state: NodeState) => ({
        setParam: state.setParam,
        setNodeExecuted: state.setNodeExecuted,
        runSubGraph: state.runSubGraph
    }), shallow);

    const { sid } = useWebsocketState((state) => ({
        sid: state.sid
    }), shallow);

    const nodeProgress = useWebsocketState(
        (state) => state.nodeProgress[props.id] || { value: 0, type: 'determinate' },
        shallow
    );

    const onClearCache = async () => {
        const nodeId = props.id;

        try {
            const response = await fetch('http://' + config.serverAddress + '/clearNodeCache', {
                method: 'DELETE',
                body: JSON.stringify({ nodeId }),
            });

            if (response.ok) {
                setNodeExecuted(nodeId, false, 0, 0);
            }
        } catch (error) {
            console.error('Error clearing cache:', error);
        }
    }

    const onRunSubGraph = async () => {
        if (!sid) return;
        await runSubGraph(sid, props.id);
    };

    const nodeId = props.id;
    const nodeTitle = props.data.label;

    // format grouped fields
    const fieldList = groupParams(props.data.params);

    //const nodeContent = Object.entries(fieldList).map(([key, data]) => renderNodeContent(nodeId, key, data, setParam));
    const style = props.data.style || {};

    const updateStore = (param: string, value: any, key?: keyof NodeParams) => {
        setParam(nodeId, param, value, key);
    };

    const resizeControl = (
        <NodeResizeControl style={{ backgroundColor: 'transparent', border: 'none' }} minWidth={200} minHeight={8}>
            <OpenInFullIcon sx={{
                position: 'absolute',
                right: '-6px',
                bottom: '-6px',
                transform: 'rotate(90deg)',
                width: '26px',
                height: '26px',
                backgroundColor: theme.palette.background.default,
                borderRadius: '0',
                padding: '2px',
                color: theme.palette.text.secondary,
            }} />
        </NodeResizeControl>
    );

    return (
        <Box
            id={nodeId}
            className={`${props.data.module}-${props.data.action} category-${props.data.category} module-${props.data.module}`}
            sx={{
                position: 'relative',
                boxShadow: 4,
                outlineOffset: '5px',
                borderRadius: '0',
                minWidth: '200px',
                ...style,
            }}
        >
            {props.data.resizable && resizeControl}

            <Box
                component="header"
                sx={{
                    color: theme.palette.common.white,
                    padding: 1,
                    borderTopWidth: '6px',
                    borderTopStyle: 'solid',
                    borderTopColor: 'rgba(0, 0, 0)',
                    backgroundColor: theme.palette.background.default,
                    fontSize: '16px',
                    textShadow: '0px 2px 0px rgba(0, 0, 0, 0.75)',
                }}
            >
                {nodeTitle}
            </Box>
            <Box sx={{
                backgroundColor: theme.palette.background.paper,
                pl: 1, pr: 1, pt: 1, pb: 0,
                '& > .MuiBox-root': {
                    pb: 1.5,
                },
                '& .MuiAccordionDetails-root > .MuiBox-root': {
                    pb: 1.5,
                },
                '& .MuiStack-root > .MuiBox-root': {
                    pb: 1.5,
                },
                '& .numberField > .MuiBox-root': {
                    pb: 0,
                },
                '& .labelled-group': {
                    pb: 0,
                },
            }}
            >
                <NodeContent
                    fields={fieldList}
                    updateStore={updateStore}
                    groups={props.data.groups}
                />
            </Box>
            <Box
                component="footer"
                sx={{
                    p: 0,
                    backgroundColor: theme.palette.background.default,
                }}
            >
                <Box sx={{ width: '100%' }}>
                    <LinearProgress
                        variant={nodeProgress.type === 'indeterminate' ? 'indeterminate' : 'determinate'}
                        color="inherit"
                        value={nodeProgress.value}
                        className={nodeProgress.type === 'disabled' ? 'progress-disabled' : ''}
                        sx={{
                            height: '4px',
                            '&.progress-disabled': {
                                '& .MuiLinearProgress-bar': {
                                    display: 'none',
                                },
                            },
                            '& .MuiLinearProgress-bar1Indeterminate': {
                                background: `repeating-linear-gradient(45deg, ${theme.palette.primary.main} 0, ${theme.palette.primary.main} 20px, ${theme.palette.primary.dark} 20px, ${theme.palette.primary.dark} 40px)`,
                                backgroundSize: '60px 100%',
                                backgroundPosition: '0 0',
                                left: '0', right: '0',
                                animation: 'mellon-progress-ind 1s linear infinite',
                            },
                            '& .MuiLinearProgress-bar1Determinate': {
                                transitionDuration: '80ms',
                                background: `linear-gradient(100deg, ${theme.palette.primary.main} 50%, #ff4259 90%)`,
                            },
                            '& .MuiLinearProgress-bar2Indeterminate': {
                                display: 'none',
                                animation: 'none',
                            },
                         }}
                    />
                </Box>

                <Box sx={{ p: 1 }}>
                    <Stack
                        direction="row"
                        spacing={2}
                        sx={{
                            justifyContent: "space-between",
                            alignItems: "center",
                            pr: props.data.resizable ? 2.5 : 0,
                        }}
                    >
                        <Stack direction="row" spacing={1}>
                            <Chip
                                icon={<DeleteForeverIcon />}
                                label="Cache"
                                title="Clear Cache"
                                onClick={onClearCache}
                                disabled={!props.data.cache}
                                color="secondary"
                                variant="filled"
                                sx={{
                                    height: '24px',
                                    borderRadius: 0.5,
                                    fontSize: '12px',
                                    span: { padding: '0px 8px 0px 10px' },
                                    '& .MuiChip-icon': {
                                        fontSize: '18px',
                                    },
                                }}
                            />
                            {props.data.execution_type === 'button' && (
                                <Button
                                    variant="contained"
                                    size="small"
                                    startIcon={<PlayArrowIcon />}
                                    onClick={onRunSubGraph}
                                    sx={{
                                        height: '24px',
                                        borderRadius: 0.5,
                                        fontSize: '12px',
                                        textTransform: 'none',
                                        minWidth: 0,
                                        padding: '4px 8px',
                                    }}
                                >
                                    Run
                                </Button>
                            )}
                        </Stack>
                        {/* <Chip
                            icon={<MemoryIcon />}
                            label={props.data.memory ? `${props.data.memory}` : '0Mb'}
                            title="Memory Usage"
                            sx={{
                                color: theme.palette.text.secondary,
                                height: '24px',
                                borderRadius: 0.5,
                                fontSize: '12px',
                                span: { padding: '0px 8px 0px 10px' },
                                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                            }}
                        /> */}
                        <Chip
                            icon={<AccessAlarmIcon />}
                            label={props.data.time ? `${props.data.time}s` : '-'}
                            title="Execution Time"
                            sx={{
                                color: theme.palette.text.secondary,
                                height: '24px',
                                borderRadius: 0.5,
                                fontSize: '12px',
                                span: { padding: '0px 8px 0px 10px' },
                                backgroundColor: 'rgba(255, 255, 255, 0.1)',
                                '& .MuiChip-icon': {
                                    fontSize: '18px',
                                    color: theme.palette.text.secondary,
                                },
                            }}
                        />
                    </Stack>
                </Box>
            </Box>
        </Box>
    );
}, (prevProps, nextProps) => {
    if (prevProps.data.time !== nextProps.data.time) {
        return false;
    }
    if (prevProps.data.cache !== nextProps.data.cache) {
        return false;
    }

    // groups properties
    if (!deepEqual(prevProps.data.groups, nextProps.data.groups)) {
        return false;
    }

    const prevParams = prevProps.data.params;
    const nextParams = nextProps.data.params;

    const prevKeys = Object.keys(prevParams);
    const nextKeys = Object.keys(nextParams);

    // Check if the objects have different number of keys
    if (prevKeys.length !== nextKeys.length) {
        return false;
    }

    // Check if all keys match
    if (!prevKeys.every(key => key in nextParams)) {
        return false;
    }

    // Now check the values for each key
    for (const key of prevKeys) {
        const prev = prevParams[key];
        const next = nextParams[key];

        if (!deepEqual(prev.value, next.value) ||
            prev.disabled !== next.disabled ||
            prev.hidden !== next.hidden) {
            return false;
        }
    }

    return true;
});

export default CustomNode;


================================================================================
FILE: client/src/components/CustomNumberInput.tsx
================================================================================

import IconButton from '@mui/material/IconButton';
import ChevronLeftIcon from '@mui/icons-material/ChevronLeft';
import ChevronRightIcon from '@mui/icons-material/ChevronRight';
import InputBase from '@mui/material/InputBase';
import Stack from '@mui/material/Stack';
import Box from '@mui/material/Box';
import Typography from '@mui/material/Typography';
import { useTheme } from '@mui/material/styles';
import { useState, useRef, EventHandler, useCallback, useEffect } from 'react';

// TODO: Someone with React expertise should review this code

const CustomNumberInput = ({
    value,
    label = '',
    dataType = 'int',
    slider = false,
    disabled = false,
    onChange,
    min,
    max,
    step,
    style,
    ...props
}: {
    dataKey: string;
    value: string | number;
    label: string;
    dataType?: string;
    slider?: boolean;
    disabled?: boolean;
    onChange: EventHandler<any>;
    min?: number;
    max?: number;
    step?: number;
    style?: { [key: string]: string };
}) => {
    const theme = useTheme();

    const sx = style || {};

    // we display the slider only if we have both min and max values
    const displaySlider = slider && min !== undefined && max !== undefined;

    // min/max normalization
    min = min !== undefined ? min : -Number.MAX_SAFE_INTEGER;
    max = max !== undefined ? max : Number.MAX_SAFE_INTEGER;
    if (min > max) {
        [min, max] = [max, min];
    }

    const minValue = min;
    const maxValue = max;
    const increment = step !== undefined ? step : (dataType === 'float' ? 0.1 : 1);
    const decimals = dataType === 'float' ? (increment.toString().split('.')[1]?.length || 1) : 0;

    const [inputValue, setInputValue] = useState(String(value || 0));
    const [isEditing, setIsEditing] = useState(false);
    const inputRef = useRef<HTMLDivElement>(null);
    const dragTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const dragStartRef = useRef({ x: 0, value: 0 });
    const isDraggingRef = useRef(false);

    const getBackgroundStyle = (value: number) => {
        if (!displaySlider) return {};

        const sliderPercent = isNaN(Number(value)) ? 0 : ((Number(value) - minValue) / (maxValue - minValue) * 100);
        const baseColor = isDraggingRef.current ? theme.palette.secondary.main : 'rgba(255,255,255,0.25)';
        const hoverColor = theme.palette.secondary.main;

        const gradientStyle = `linear-gradient(to right, ${baseColor} ${sliderPercent}%, rgba(255,255,255,0.1) ${sliderPercent}%)`;

        return {
            background: gradientStyle,
            '&:hover': { background: `linear-gradient(to right, ${hoverColor} ${sliderPercent}%, rgba(255,255,255,0.1) ${sliderPercent}%)` }
        };
    };

    const updateValue = useCallback((value: string | number) => {
        value = Number(value);

        // if the value is invalid, it defaults to the middle of the range
        if (isNaN(value)) {
            value = (maxValue - minValue) / 2;
        }

        const newValue = String(Math.min(maxValue, Math.max(minValue, value)).toFixed(decimals));
        setInputValue(newValue);

        if (!isEditing) {
            onChange(newValue);
        }
    }, [minValue, maxValue, decimals]);

    const handleBlur = useCallback(() => {
        const inputElement = inputRef.current?.querySelector('input');
        setIsEditing(false);

        if (!inputElement) return;

        inputElement.removeEventListener('blur', handleBlur as any);
        inputElement.removeEventListener('keydown', handleKeyDown as any);
        updateValue(inputElement.value);
    }, [updateValue]);

    const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
        const inputElement = inputRef.current?.querySelector('input');

        if (e.key === 'Enter' || e.key === 'Escape') {
            inputElement?.removeEventListener('blur', handleBlur as any);
            inputElement?.removeEventListener('keydown', handleKeyDown as any);

            setIsEditing(false);
            updateValue(inputElement?.value || '');
            inputElement?.blur();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            updateValue(Number(inputElement?.value) + increment);
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            updateValue(Number(inputElement?.value) - increment);
        }
    }, [increment, updateValue]);

    const handleMouseMove = useCallback((e: React.MouseEvent) => {
        clearTimeout(dragTimeoutRef.current as any);

        e.preventDefault();
        e.stopPropagation();

        if (!isDraggingRef.current) {
            isDraggingRef.current = true;
        }

        const inputElement = inputRef.current?.querySelector('input');

        // we are dragging, so we remove the focus from the input
        if (document.activeElement === inputElement) {
            inputElement?.blur();
            setIsEditing(false);
        }

        const delta = e.clientX - dragStartRef.current.x;
        const range = maxValue - minValue;
        const steps = range / increment || 100;
        const valueRange = displaySlider ? steps / 300 * delta : delta;
        const newValue = dragStartRef.current.value + valueRange*increment;

        updateValue(newValue);
        //onChange(normalizedValue);
    }, [minValue, maxValue, increment, updateValue]);

    const handleMouseUp = useCallback((e: React.MouseEvent) => {
        clearTimeout(dragTimeoutRef.current as any);
        const inputElement = inputRef.current?.querySelector('input');

        document.removeEventListener('mousemove', handleMouseMove as any);
        document.removeEventListener('mouseup', handleMouseUp as any);
        //inputElement?.removeEventListener('blur', handleBlur as any);
        //inputElement?.removeEventListener('keydown', handleKeyDown as any);

        if (document.activeElement !== inputElement && !isDraggingRef.current && (e.target as HTMLElement).closest('button') === null) {
            // give the focus to the input, unless we are clicking on a left/right button
            inputElement?.focus();
            inputElement?.addEventListener('blur', handleBlur as any);
            inputElement?.addEventListener('keydown', handleKeyDown as any);
            setIsEditing(true);
        } else {
            inputElement?.blur();
            setIsEditing(false);
        }

        isDraggingRef.current = false;
    }, [handleBlur, handleKeyDown]);

    const handleMouseDown = (e: React.MouseEvent) => {
        // Only handle left mouse button
        if (e.button !== 0) {
            e.preventDefault();
            e.stopPropagation();
            return;
        }

        const inputElement = inputRef.current?.querySelector('input');

        // If the input is already focused, act like a standard text field
        // this allows to edit the value by just typing
        if (document.activeElement === inputElement) return;

        (document.activeElement as HTMLElement)?.blur();

        e.preventDefault();
        e.stopPropagation();

        dragStartRef.current = { x: e.clientX, value: Number(inputValue) };

        // we wait 200ms before entering dragging mode
        // a quick click will just focus the input without starting the drag
        dragTimeoutRef.current = setTimeout(() => {
            inputElement?.blur();
            isDraggingRef.current = true;
        }, 200);

        document.addEventListener('mousemove', handleMouseMove as any);
        document.addEventListener('mouseup', handleMouseUp as any);
    };

    const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        //const value = e.target.value;
        setInputValue(e.target.value);
        //onChange(value);
    };

    useEffect(() => {
        setInputValue(String(value));
    }, [value]);

    useEffect(() => {
        return () => {
            clearTimeout(dragTimeoutRef.current as any);
            document.removeEventListener('mousemove', handleMouseMove as any);
            document.removeEventListener('mouseup', handleMouseUp as any);

            const inputElement = inputRef.current?.querySelector('input');
            if (inputElement) {
                inputElement.removeEventListener('blur', handleBlur as any);
                inputElement.removeEventListener('keydown', handleKeyDown as any);
            }
        };
    }, [handleMouseMove, handleMouseUp, handleBlur, handleKeyDown]);

    const field = (
        <Stack
            data-key={props.dataKey}
            direction="row"
            spacing={0.5}
            className={`nodrag customNumberInput${disabled ? ' mellon-disabled' : ''}`}
            onMouseDown={handleMouseDown}
            sx={{
                mb: 0,
                p: 0.5,
                width: '100%',
                justifyContent: 'space-between', alignItems: 'center',
                ...getBackgroundStyle(Number(inputValue)),
                borderRadius: 1,
                overflow: 'hidden',
                userSelect: 'none',
                cursor: 'default',
                outline: isEditing ? `2px solid ${theme.palette.primary.main}` : 'none',
                ...sx,
            }}
        >
            <IconButton
                size="small"
                disableRipple // ripple effect is buggy
                onClick={() => updateValue(Number(inputValue) - increment)}
                sx={{
                    borderRadius: 1,
                    opacity: Number(inputValue) <= minValue ? 0.4 : 1,
                    '&:hover': { background: Number(inputValue) <= minValue ? '' : 'rgba(255,255,255,0.15)' }
                }}
            >
                <ChevronLeftIcon fontSize="small" />
            </IconButton>
            <Box sx={{ maxWidth: '50%'}}>
                <Typography sx={{ fontSize: '14px', textOverflow: 'ellipsis', overflow: 'hidden', whiteSpace: 'nowrap' }} title={label}>{label}</Typography>
            </Box>
            <InputBase
                ref={inputRef}
                value={inputValue}
                onChange={handleChange}
                size="small"
                sx={{ flexGrow: 1 }}
                slotProps={{
                    input: {
                        sx: { textAlign: 'right', padding: 0, cursor: 'default' },
                    },
                }}
            />
            <IconButton
                size="small"
                disableRipple
                onClick={() => updateValue(Number(inputValue) + increment)}
                sx={{
                    borderRadius: 1,
                    opacity: Number(inputValue) >= maxValue ? 0.4 : 1,
                    '&:hover': { background: Number(inputValue) >= maxValue ? '' : 'rgba(255,255,255,0.15)' }
                }}
            >
                <ChevronRightIcon fontSize="small" />
            </IconButton>
        </Stack>
    );

    return field;
};

export default CustomNumberInput;

================================================================================
FILE: client/src/components/NodeContent.tsx
================================================================================

import { memo } from "react";
import { NodeParams } from "../stores/nodeStore";
import { deepEqual } from './utils/deepEqual';

// MUI
import { SxProps, Theme } from "@mui/material/styles";

// Custom fields
import AccordionField from "./fields/AccordionField";
import GroupField from "./fields/GroupField";
import HandleField from './fields/HandleField';
import TextField from './fields/TextField';
import ToggleField from "./fields/ToggleField";
import AutocompleteField from "./fields/AutocompleteField";
import SelectField from "./fields/SelectField";
import IconToggleField from "./fields/IconToggleField";
import NumberField from "./fields/NumberField";
import RangeField from "./fields/RangeField";
import TextareaField from "./fields/TextareaField";
import TagsField from "./fields/TagsField";
import CustomField from "./fields/CustomField";
import UIDropdownIcon from "./fields/UIDropdownIcon";
import UIImageField from "./fields/UIImageField";
import UIThreeField from "./fields/UIThreeField";
import FileBrowserField from "./fields/FileBrowserField";
import UITextField from "./fields/UITextField";

// These are the props sent to the fields
export type FieldProps = {
    fieldKey: string;
    label?: string;
    fieldType?: string;
    value?: any;
    options?: any;
    dataType?: string;
    style?: SxProps<Theme>;
    disabled?: boolean;
    hidden?: boolean;
    open?: boolean;
    no_validation?: boolean;
    icon?: 'random' | 'none';
    min?: number;
    max?: number;
    step?: number;
    source?: string;
    updateStore?: (param: string, value: any, key?: keyof NodeParams) => void;
    onChangeAction?: { action: string, target?: any };
}

export type GroupProps = {
    fieldKey: string;
    fields: Record<string, NodeParams>;
    updateStore: (param: string, value: any, key?: keyof NodeParams) => void;
    label?: string;
    open?: boolean;
    direction?: 'row' | 'column';
    disabled?: boolean;
    hidden?: boolean;
    style?: SxProps<Theme>;
}

type NodeContentProps = {
    fields: NodeParams;
    updateStore: (param: string, value: any, key?: keyof NodeParams, group?: string) => void;
    groups?: { [key: string]: { disabled?: boolean, hidden?: boolean, open?: boolean } };
    parentDisabled?: boolean; // avoid disabling fields when the parent group is already disabled
}

const NodeContent = (props: NodeContentProps) => {
    //const renderField = (key: string, data: any) => {
    return Object.entries(props.fields).map(([key, data]: [string, any]) => {
        const displayData = (data.display || '').toLowerCase();
        const disabled = props.parentDisabled ? false : data.disabled || false;
        const hidden = data.hidden || false;
        const sxStyle = data.style || {};
        const label = data.label || key;
        
        if (displayData === 'group') {
            const group = props.groups?.[key];
            const groupDisabled = group ? (group.disabled !== undefined ? group.disabled : disabled) : false;
            const groupHidden = group ? (group.hidden !== undefined ? group.hidden : hidden) : false;

            return (
                <GroupField
                    key={key}
                    fieldKey={key}
                    label={data.label}
                    direction={data.direction}
                    disabled={groupDisabled}
                    hidden={groupHidden}
                    style={sxStyle}
                    updateStore={props.updateStore}
                    fields={data.params}
                />
            )
        }
        
        if (displayData === 'collapse') {
            const group = props.groups?.[key];
            const open = group ? (group.open !== undefined ? group.open : data.open) : false;
            const groupDisabled = group ? (group.disabled !== undefined ? group.disabled : disabled) : false;
            const groupHidden = group ? (group.hidden !== undefined ? group.hidden : hidden) : false;

            return (
                <AccordionField
                    key={key}
                    fieldKey={key}
                    open={open}
                    label={data.label}
                    disabled={groupDisabled}
                    hidden={groupHidden}
                    style={sxStyle}
                    updateStore={props.updateStore}
                    fields={data.params}
                />
            )
        }

        // Data type can be an array, the array is mostly used for input handles to allow connection to multiple types
        // For node processing we only use the first type, that becomes the main type
        // TODO: should we use an "allowedTypes" property instead?
        const dataType = (Array.isArray(data.type) && data.type.length > 0 ? data.type[0] : data.type || 'string').toLowerCase();

        const fieldType = getFieldType(displayData, dataType, data);
        const fieldValue = data.value === undefined ? data.default || '' : data.value;
        const options = data.options || [];
        const no_validation = data.no_validation || false;
        const onChangeAction = typeof data.onChange === 'string' ? { action: data.onChange } : data.onChange || null;

        const fieldProps: FieldProps = {
            fieldKey: key,
            fieldType: fieldType,
            dataType: dataType,
            label: label,
            value: fieldValue,
            style: sxStyle,
            hidden: hidden,
            disabled: disabled,
            options: options,
            no_validation: no_validation,
            updateStore: props.updateStore,
            onChangeAction: onChangeAction,
            icon: data.icon,
            min: data.min,
            max: data.max,
            step: data.step,
            source: data.source,
        }

        return <FieldMemo key={key} {...fieldProps} />;
    });

    //return Object.entries(props.fields).map(([key, data]: [string, any]) => renderField(key, data));
};

const FieldMemo = memo((props: FieldProps) => {
    switch (props.fieldType) {
        case 'input':
        case 'output':
            return <HandleField {...props} />;
        case 'number':
        case 'slider':
            return <NumberField {...props} />;
        case 'checkbox':
        case 'switch':
            return <ToggleField {...props} />;
        case 'autocomplete':
            return <AutocompleteField {...props} />;
        case 'select':
            return <SelectField {...props} />;
        case 'textarea':
            return <TextareaField {...props} />;
        case 'icontoggle':
            return <IconToggleField {...props} />;
        case 'range':
            return <RangeField {...props} />;
        case 'tags':
            return <TagsField {...props} />;
        case 'custom':
            return <CustomField {...props} />;
        case 'filebrowser':
            return <FileBrowserField {...props} />;
        case 'ui_image':
            return <UIImageField {...props} />;
        case 'ui_dropdownicon':
            return <UIDropdownIcon {...props} />;
        case 'ui_3d':
            return <UIThreeField {...props} />;
        case 'ui_text':
            return <UITextField {...props} />;
        default:
            return <TextField {...props} />;
    }
}, (prevProps, nextProps) => {
    return (
        deepEqual(prevProps.value, nextProps.value) &&
        prevProps.disabled === nextProps.disabled &&
        prevProps.hidden === nextProps.hidden
    );
});

const getFieldType = (displayData: string, dataType: string, data: any) => {
    if (displayData === 'input' || displayData === 'output') {
        return displayData;
    }

    if (dataType === 'boolean' || dataType === 'bool') {
        return displayData === 'checkbox' || displayData === 'icontoggle' ? displayData : 'switch';
    }

    if (displayData === 'ui') {
        if (dataType === 'image') {
            return 'ui_image';
        } else if (dataType.toLowerCase() === 'dropdownicon') {
            return 'ui_dropdownicon';
        } else if (dataType.toLowerCase() === '3d') {
            return 'ui_3d';
        } else if (dataType.toLowerCase() === 'text') {
            return 'ui_text';
        }
    }

    if (displayData) {
        return displayData;
    }

    if (data.options && typeof data.options === 'object') {
        return 'select';
    }

    if (dataType === 'int' || dataType === 'integer' || dataType === 'float' || dataType === 'number' ) {
        return displayData === 'slider' ? 'slider' : 'number';
    }

    return 'text';
};

export default NodeContent;

================================================================================
FILE: client/src/components/ToolBar.tsx
================================================================================

import { useMemo, useState } from 'react'

import Box from '@mui/material/Box'
import List from '@mui/material/List'
import ListItem from '@mui/material/ListItem'
//import ListItemButton from '@mui/material/ListItemButton'
import ListItemText from '@mui/material/ListItemText'
import Tabs from '@mui/material/Tabs'
import Tab from '@mui/material/Tab'
import AccordionDetails from '@mui/material/AccordionDetails'
import AccordionSummary from '@mui/material/AccordionSummary'

//import ToggleButton from '@mui/material/ToggleButton'
//import ToggleButtonGroup from '@mui/material/ToggleButtonGroup'
//import Stack from '@mui/material/Stack'
import { useTheme } from '@mui/material/styles'

import { shallow } from 'zustand/shallow';
import { NodeRegistryState, useNodeRegistryState } from '../stores/nodeRegistryStore';

import OutlinedInput from '@mui/material/OutlinedInput'
import SearchIcon from '@mui/icons-material/Search'
import Accordion from '@mui/material/Accordion'
import ExpandMoreIcon from '@mui/icons-material/ExpandMore'

const sidebarWidth = 260

const selectNodeRegistryState = (state: NodeRegistryState) => ({
  nodeRegistry: state.nodeRegistry,
});

const groupBy = (field: string, nodeRegistry: any) => {
  const grouped = Object.entries(nodeRegistry).reduce((acc: any, [key, node]: [string, any]) => {
    const fieldValue = node[field] || 'default';
    if (!acc[fieldValue]) {
      acc[fieldValue] = [];
    }
    acc[fieldValue].push({ key, ...node });
    return acc;
  }, {});

  if (field !== 'module') {
    // Sort nodes within each module alphabetically by label
    Object.keys(grouped).forEach(module => {
      grouped[module].sort((a: any, b: any) => 
        (a.label || a.key).localeCompare(b.label || b.key)
      );
    });
  }

  // Return as sorted object with sorted module names
  return Object.fromEntries(
    Object.entries(grouped).sort(([a], [b]) => a.localeCompare(b))
  );
};

export default function LeftSidebar() {
  const theme = useTheme()
  const { nodeRegistry } = useNodeRegistryState(selectNodeRegistryState, shallow);

  // Local node search state, the code will hide the nodes that don't match the search term instead of removing them from the DOM
  const [searchTerm, setSearchTerm] = useState('')
  const filteredNodes = useMemo(() => {
    const searchTerms = searchTerm.toLowerCase().split(/\s+/).filter(term => term.length > 0);
    if (searchTerms.length === 0) return null;

    return Object.keys(nodeRegistry).filter((key) => {
      const label = nodeRegistry[key].label.toLowerCase();
      return searchTerms.every(term => label.includes(term));
    })
  }, [nodeRegistry, searchTerm])

  // Drag and drop functionality
  const onDragStart = (event: React.DragEvent<HTMLLIElement>, key: string) => {
    event.dataTransfer.setData('text/plain', key);
    event.dataTransfer.effectAllowed = 'move';
  }

  // Tab state
  const [tabValue, setTabValue] = useState(0);
  const handleTabChange = (_: any, newValue: number) => {
    setTabValue(newValue);
  };

  const groupedNodes = useMemo(() => {
    // First get the base grouped nodes
    const grouped = tabValue === 0 ? groupBy('module', nodeRegistry) : groupBy('category', nodeRegistry);

    // If there's a search filter, only include nodes that match
    if (filteredNodes) {
      return Object.fromEntries(
        Object.entries(grouped).map(([module, nodes]: [string, any]) => [
          module,
          nodes.filter((node: any) => filteredNodes.includes(node.key))
        ]).filter(([_, nodes]) => nodes.length > 0)
      );
    }

    return grouped;
  }, [nodeRegistry, filteredNodes, tabValue]);

  return (
    <Box
      className="left-sidebar"
      textAlign="center"
      sx={{
        width: sidebarWidth,
        height: '100%',
        display: 'flex',
        flexDirection: 'column',
        backgroundColor: theme.palette.background.paper,
        borderRight: `1px solid ${theme.palette.divider}`,
      }}
    >
      <Box sx={{ p: 1.5, borderBottom: `1px solid ${theme.palette.divider}` }}>
        <OutlinedInput
          startAdornment={<SearchIcon fontSize="small" sx={{ marginRight: 1 }} />}
          id="main-module-search"
          placeholder="Search"
          size="small"
          value={searchTerm}
          onChange={(e) => setSearchTerm(e.target.value)}
          sx={{ width: '100%', fontSize: '14px' }}
        />
      </Box>
      <Box sx={{ width: '100%' }}>
        <Tabs
          value={tabValue}
          onChange={handleTabChange}
          variant="fullWidth"
          sx={{
            lineHeight: '16px',
            minHeight: 0,
            borderBottom: `1px solid ${theme.palette.divider}`,
            '.MuiButtonBase-root': { textTransform: 'none', lineHeight: '16px', minHeight: 0 }
          }}
        >
          <Tab label="Modules" />
          <Tab label="Categories" />
        </Tabs>
      </Box>
      <Box sx={{
        flex: 1,
        overflowY: 'auto',
        p: 0, m: 0,
      }}>
        <Box sx={{ p: 0, pb: 0, m: 0 }}>
          {Object.entries(groupedNodes).map(([module, nodes]: [string, any]) => (
            <Accordion disableGutters key={module} sx={{
              borderBottom: `1px solid ${theme.palette.divider}`,
              boxShadow: 'none',
              backgroundColor: '#1a1a1a',
              fontSize: 12,
              p: 0, m: 0,
              '&:before': {
                backgroundColor: 'transparent',
              },
              '.MuiAccordionSummary-root': {
                backgroundColor: '#1a1a1a',
                '&:hover': {
                  backgroundColor: 'rgba(255, 255, 255, 0.1)',
                },
              },
              '.MuiAccordionDetails-root': {
                backgroundColor: '#1a1a1a',
                padding: '8px 4px',
              },
            }}>
              <AccordionSummary expandIcon={<ExpandMoreIcon />}>{module.replace(/[_-]/g, ' ').replace(/\b\w/g, char => char.toUpperCase())}</AccordionSummary>
              <AccordionDetails>
                <List dense={true} sx={{ p: 1.5, pt: 0, pb: 0, m: 0 }}>
                  {nodes.map((node: any) => (
                    <ListItem
                      key={node.key}
                      draggable
                      className={`${node.key} category-${node.category} module-${node.module}`}
                      onDragStart={(event) => onDragStart(event, node.key)}
                      sx={{
                        outline: `1px solid ${theme.palette.divider}`,
                        borderRadius: 1,
                        boxShadow: 3,
                        m: 0, mb: 1,
                        p: 0.5, pl: 1,
                        borderLeftWidth: '8px',
                        borderLeftStyle: 'solid',
                        cursor: 'grab',
                        display: !filteredNodes || filteredNodes.includes(node.key) ? 'flex' : 'none',
                      }}
                    >
                      <ListItemText primary={node.label || node.key} sx={{ '& .MuiTypography-root': { fontSize: 12 } }} />
                    </ListItem>
                  ))}
                </List>
              </AccordionDetails>
            </Accordion>
          ))}
        </Box>
      </Box>
    </Box>
  )
}


================================================================================
FILE: client/src/components/WebsocketContext.tsx
================================================================================

import React, { createContext, useContext } from 'react';
import { WebsocketState, useWebsocketState } from '../stores/websocketStore';

const WebSocketContext = createContext<WebsocketState | null>(null);

export function WebSocketProvider({ children }: { children: React.ReactNode }) {
    const store = useWebsocketState();
    return (
        <WebSocketContext.Provider value={store}>
            {children}
        </WebSocketContext.Provider>
    );
}

export function useWebSocket() {
    const context = useContext(WebSocketContext);
    if (!context) {
        throw new Error('useWebSocket must be used within a WebSocketProvider');
    }
    return context;
}

================================================================================
FILE: client/src/components/utils/deepEqual.ts
================================================================================


export const deepEqual = (a: any, b: any): boolean => {
    if (a === b) return true;
    if (a == null || b == null) return false;

    const bothAreObjects = a && b && typeof a === "object" && typeof b === "object";
    return bothAreObjects &&
        Object.keys(a).length === Object.keys(b).length &&
        Object.keys(a).every(key => deepEqual(a[key], b[key]));
};


================================================================================
FILE: client/src/components/utils/getDecimalPlaces.ts
================================================================================


const getDecimalPlaces = (value: number | undefined) => {
    if (!value) return 1;
    const str = value.toString();
    
    // Handle scientific notation (e.g., 1.23e-4)
    if (str.includes('e-')) {
        const [mantissa, exponent] = str.split('e-');
        const mantissaDecimals = mantissa.includes('.') ? mantissa.split('.')[1].length : 0;
        return mantissaDecimals + Number(exponent);
    }
    
    // Handle regular decimals (e.g., 0.001)
    const decimals = str.split('.')[1];
    return decimals ? decimals.length : 0;
};

export default getDecimalPlaces;

================================================================================
FILE: client/src/components/utils/groupParams.ts
================================================================================

import type { NodeParams, GroupParams } from '../../stores/nodeStore';

interface GroupedParam {
    display: 'group' | 'collapse';
    label: string | null;
    hidden: boolean;
    disabled: boolean;
    open: boolean;
    direction: 'row' | 'column';
    params: Record<string, NodeParams>;
}

const createGroupConfig = (group: GroupParams): GroupParams => {
    if (typeof group === 'string') {
        return { key: `${group}_group`, display: 'group' };
    }
    
    return {
        key: `${group.key || 'untitled'}_group`,
        display: group.display || 'group',
        label: group.label || null,
        hidden: group.hidden || false,
        disabled: group.disabled || false,
        open: group.open || false,
        direction: group.direction || 'row',
    };
};

const createGroupedParam = (config: GroupParams): GroupedParam => ({
    display: config.display || 'group',
    label: config.label || null,
    hidden: config.hidden || false,
    disabled: config.disabled || false,
    open: config.open || false,
    direction: config.direction || 'row',
    params: {},
});

/*
    Group fields by data.params.group.

    Convert group from:
    'seed': { ... }, 'width': { ... group: 'dimensions' }, 'height': { ... group: 'dimensions' }

    To:
    'seed': { ... }, 'dimensions_group': { ... , 'params': { 'width': { ... }, 'height': { ... } } }

    This complication is to keep all fields on the same level and avoid nested objects
*/
export const groupParams = (params: Record<string, NodeParams>): Record<string, NodeParams | GroupedParam> => {
    return Object.entries(params).reduce<Record<string, NodeParams | GroupedParam>>(
        (acc, [key, data]) => {
            if (!data.group) {
                acc[key] = data;
                return acc;
            }

            const groupConfig = createGroupConfig(data.group);

            if (!acc[groupConfig.key]) {
                acc[groupConfig.key] = createGroupedParam(groupConfig);
            }
            
            (acc[groupConfig.key] as GroupedParam).params[key] = data;
            return acc;
        }, 
        {}
    );
};

export type { GroupParams };


================================================================================
FILE: client/src/components/fields/AccordionField.tsx
================================================================================

import { styled } from "@mui/material/styles"
import Accordion from "@mui/material/Accordion";
import AccordionSummary from "@mui/material/AccordionSummary";
import AccordionDetails from "@mui/material/AccordionDetails";
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';

import NodeContent from "../NodeContent";

import { GroupProps } from "../NodeContent";

const PlainAccordion = styled(Accordion)(({ theme }) => ({
    boxShadow: 'none',
    border: 0,
    padding: 0,
    margin: 0,
    background: 'transparent',
    borderBottom: `1px solid ${theme.palette.divider}`,
    '&:before': { background: 'transparent' },
    '.MuiAccordionSummary-root': { padding: '0 4px', margin: 0, background: 'transparent', color: theme.palette.text.secondary, minHeight: '0', border: 'none' },
    '.MuiAccordionDetails-root': { padding: 0, margin: 0, border: 'none' },
    '.MuiAccordionSummary-root:hover, .MuiAccordionSummary-root:hover .MuiAccordionSummary-expandIconWrapper': { color: theme.palette.primary.main },
}));

const AccordionField = (
    { fieldKey, label, open, disabled, hidden, style, fields, updateStore }: GroupProps
) => {
    return (
        <PlainAccordion
            data-key={fieldKey}
            disableGutters={true}
            square={true}
            className={`nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            expanded={open}
            onChange={(_, expanded) => {
                updateStore(fieldKey, { open: expanded }, 'group');
            }}
            sx={{ ...style }}
        >
            <AccordionSummary expandIcon={<ExpandMoreIcon />}>
                {label || fieldKey}
            </AccordionSummary>
            <AccordionDetails>
                <NodeContent
                    fields={fields}
                    updateStore={updateStore}
                    parentDisabled={disabled}
                />
            </AccordionDetails>
        </PlainAccordion>
    )
}

export default AccordionField;

================================================================================
FILE: client/src/components/fields/AutocompleteField.tsx
================================================================================

import Box from "@mui/material/Box";
import Autocomplete from "@mui/material/Autocomplete";
import TextField from "@mui/material/TextField";

import { FieldProps } from "../NodeContent";

const AutocompleteField = ({ fieldKey, value, style, disabled, hidden, label, no_validation, options, updateStore }: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ minWidth: '320px', ...style }}
            className={`nodrag nowheel ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Autocomplete
                disablePortal
                freeSolo={no_validation}
                options={options}
                renderInput={(params: any) => <TextField {...params} label={label} />}
                onChange={(_, value) => updateStore?.(fieldKey, value)}
                value={value}
                size="small"
                sx={{ '& + .MuiAutocomplete-popper .MuiAutocomplete-option': { fontSize: '12px' } }}
            />
        </Box>
    );
}

export default AutocompleteField;

================================================================================
FILE: client/src/components/fields/CustomField.tsx
================================================================================

import React from "react";
import Box from "@mui/material/Box";
import { useEffect, useState } from "react";
import { FieldProps } from "../NodeContent";
import config from "../../../config";
import { useTheme } from "@mui/material/styles";

const DynamicComponent = ({ component, props }: { component: string | undefined, props: any }) => {
    const [Comp, setComp] = useState<React.ComponentType<any> | null>(null);
    const w = window as any;
    const componentId = component?.split('/').pop();
    if (!component || !componentId) {
        console.error('The component must be in the format of `module/component`');
        return <Box>Error loading component</Box>;
    }

    useEffect(() => {
        // expose React to the custom component
        if (w.React === undefined) {
            w.React = React;
        }

        // Track script instances globally
        if (w.mellonCustomScripts === undefined) {
            w.mellonCustomScripts = new Map();
        }

        const loadComponent = async () => {
            try {
                // check if the script is already loaded
                const existingScript = w.mellonCustomScripts.get(component);
                if (existingScript) {
                    await existingScript;
                } else {
                    const loadPromise = new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = `http://${config.serverAddress}/custom_component/${component}`;
                        script.async = true;
                        script.onload = resolve;
                        script.onerror = reject;
                        script.id = componentId;
                        document.body.appendChild(script);
                    });

                    // Wait for script to load
                    w.mellonCustomScripts.set(component, loadPromise);
                    await loadPromise;
                }

                const LoadedComponent = w[componentId];
                if (!LoadedComponent) {
                    throw new Error(`Component ${componentId} failed to load properly`);
                }

                setComp(() => LoadedComponent);
            } catch (error) {
                console.error('Error loading component:', error);
                w.mellonCustomScripts.delete(component);
            }
        };

        // if the componentId is already in the window, use it
        const existingComponent = w[componentId];
        if (existingComponent) {
            setComp(() => existingComponent);
        } else {
            loadComponent();
        }

        // Cleanup
        return () => {
            const script = document.getElementById(componentId);
            if (script && !document.querySelector(`[data-component="${componentId}"]`)) {
                document.body.removeChild(script);
                w.mellonCustomScripts.delete(component);
            }
            // if mellonCustomScripts is empty we can also remove React from the window
            if (w.mellonCustomScripts.size === 0) {
                delete w.mellonCustomScripts;
                delete w.React;
            }
        };
    }, [component, componentId]);

    if (!Comp) {
        return <Box>Loading...</Box>;
    }

    return (
        <Box data-component={componentId}>
            <Comp {...props} />
        </Box>
    );
};


const CustomField = ({ fieldKey, value, style, disabled, hidden, label, updateStore, source }: FieldProps) => {
    const setValue = (v: any) => updateStore?.(fieldKey, v);
    const theme = useTheme();

    return (
        <Box
            data-key={fieldKey}
            className={`nodrag nowheel ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ ...style }}
        >
            <DynamicComponent
                component={source}
                props={{
                    fieldKey,
                    value,
                    label,
                    setValue,
                    theme,
                }}
            />
        </Box>
    );
}

export default CustomField;

================================================================================
FILE: client/src/components/fields/FileBrowserField.tsx
================================================================================

import { FieldProps } from "../NodeContent";
import { useState } from "react";

import Box from "@mui/material/Box";
import MuiTextField from "@mui/material/TextField";
import Stack from "@mui/material/Stack";
import IconButton from "@mui/material/IconButton";
import FolderOpenOutlinedIcon from '@mui/icons-material/FolderOpenOutlined';
import Dialog from "@mui/material/Dialog";

const FileBrowserField = ({
    fieldKey,
    value,
    style,
    disabled,
    hidden,
    label,
    updateStore,
}: FieldProps) => {
    const [open, setOpen] = useState(false);

    const handleClickOpen = () => {
      setOpen(true);
    };
  
    const handleClose = () => {
      setOpen(false);
    };

    return (
        <Box
            data-key={fieldKey}
            sx={{ ...style }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Stack
                direction="row"
                spacing={1}
                sx={{
                    '& > .MuiBox-root': { flex: "1" },
                    '& > .flex-auto': { flex: "0 0 auto" },
                    justifyContent: "center",
                    alignItems: "stretch",
                }}
            >
                <MuiTextField
                    onChange={(e) => updateStore?.(fieldKey, e.target.value)}
                    variant="outlined"
                    type="text"
                    size="small"
                    fullWidth
                    label={label}
                    value={value}
                    className="nodrag"
                    autoComplete="off"
                />
                <IconButton onClick={handleClickOpen}>
                    <FolderOpenOutlinedIcon />
                </IconButton>
            </Stack>
            <Dialog
                open={open}
                onClose={handleClose}
                aria-labelledby="file-browser-dialog"
            >
                <Box>
                    Not yet implemented
                </Box>
            </Dialog>
        </Box>
    );
}

export default FileBrowserField;

================================================================================
FILE: client/src/components/fields/GroupField.tsx
================================================================================

import Stack from "@mui/material/Stack";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import NodeContent from "../NodeContent";

import { GroupProps } from "../NodeContent";
import { useTheme } from "@mui/material/styles";


const GroupField = (
    { fieldKey, label, direction, disabled, hidden, style, fields, updateStore }: GroupProps
) => {
    const alignItems = direction === 'column' ? 'stretch' : 'center';
    const spacing = direction === 'column' ? 0 : 1;

    const theme = useTheme();

    if (label) {
        return (
            <Box
                data-key={fieldKey}
                sx={{
                    borderBottom: `1px solid ${theme.palette.divider}`,
                    pt: 0.5, pb: 0,
                    ...style,
                }}
                className={`labelled-group ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            >
                <Typography sx={{ pb: 1, color: theme.palette.text.secondary, textOverflow: 'ellipsis', overflow: 'hidden', whiteSpace: 'nowrap' }}>
                    {label}
                </Typography>
                <Stack
                    direction={direction}
                    spacing={spacing}
                    sx={{
                        '& > .MuiBox-root': { flex: "1" },
                        '& > .flex-auto': { flex: "0 0 auto" },
                        justifyContent: "space-between",
                        alignItems: alignItems,
                    }}
                >
                    <NodeContent
                        fields={fields}
                        updateStore={updateStore}
                        parentDisabled={disabled}
                    />
                </Stack>
            </Box>
        )
    }

    return (
        <Stack
            data-key={fieldKey}
            direction={direction}
            spacing={spacing}
            sx={{
                '& > .MuiBox-root': { flex: "1" },
                '& > .flex-auto': { flex: "0 0 auto" },
                justifyContent: "space-between",
                alignItems: alignItems,
                ...style,
            }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <NodeContent
                fields={fields}
                updateStore={updateStore}
                parentDisabled={disabled}
            />
        </Stack>
    )
}

export default GroupField;


================================================================================
FILE: client/src/components/fields/HandleField.tsx
================================================================================

import { Handle, Position } from "@xyflow/react";
import Typography from "@mui/material/Typography";
import Box from "@mui/material/Box";
import { FieldProps } from "../NodeContent";

const InputHandle = ({ fieldKey, label, style, disabled, hidden, dataType }: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ position: 'relative', ...style }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Handle
                id={fieldKey}
                type="target"
                position={Position.Left}
                className={`${dataType}-handle`}
                style={{ marginTop: '-4px' }}
            />
            <Typography sx={{ pl: 1 }}>{label}</Typography>
        </Box>
    )
}

const OutputHandle = ({ fieldKey, label, style, disabled, hidden, dataType }: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ position: 'relative', ...style }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Handle
                id={fieldKey}
                type="source"
                position={Position.Right}
                className={`${dataType}-handle`}
                style={{ marginTop: '-4px' }}
            />
            <Typography sx={{ textAlign: 'right', pr: 1 }}>{label}</Typography>
        </Box>
    )
}

const HandleField = ({ fieldType, fieldKey, label, style, disabled, hidden, dataType }: FieldProps) => {
    const HandleElement = fieldType === 'input' ? InputHandle : OutputHandle;

    return (
        <HandleElement
            fieldKey={fieldKey}
            label={label}
            style={style}
            disabled={disabled}
            hidden={hidden}
            dataType={dataType}
        />
    );
}

export default HandleField;

================================================================================
FILE: client/src/components/fields/IconToggleField.tsx
================================================================================

import { useEffect } from "react";

import Box from "@mui/material/Box";
import Checkbox from "@mui/material/Checkbox";
import { FieldProps } from "../NodeContent";
import { useTheme } from "@mui/material/styles";

import AutoFixHighIcon from '@mui/icons-material/AutoFixHigh';

const IconToggleField = ({ fieldKey, value, style, disabled, hidden, label, icon, onChangeAction, updateStore }: FieldProps) => {
    const theme = useTheme();

    const iconsMap = {
        'random': <AutoFixHighIcon />,
    }

    const MuiIcons = {
        icon: iconsMap[icon as keyof typeof iconsMap],
        checkedIcon: iconsMap[icon as keyof typeof iconsMap],
    }

    const handleDisableAction = (value: boolean, target: any) => {
        const onTrueTargets = Array.isArray(target.true) ? target.true : [target.true];
        const onFalseTargets = Array.isArray(target.false) ? target.false : [target.false];

        onTrueTargets.forEach((field: string) => {
            updateStore?.(field, value, 'disabled');
        });
        onFalseTargets.forEach((field: string) => {
            updateStore?.(field, !value, 'disabled');
        });
    };

    useEffect(() => {
        if (onChangeAction && onChangeAction.action === 'disable') {
            handleDisableAction(value, onChangeAction.target);
        }
    }, [value]);

    return (
        <Box
            data-key={fieldKey}
            className={`flex-auto nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ ...style }}
        >
            <Checkbox
                size="small"
                {...MuiIcons}
                checked={value}
                title={label}
                onChange={(e) => updateStore?.(fieldKey, e.target.checked)}
                disableRipple
                sx={{
                    p: 1.1,
                    m: 0,
                    border: 1,
                    borderRadius: 1,
                    borderColor: "rgba(255,255,255,0.25)",
                    '&.Mui-checked': {
                        backgroundColor: theme.palette.secondary.main,
                        color: theme.palette.background.paper,
                        borderColor: theme.palette.secondary.main,
                    }
                }}
            />
        </Box>
    )
}

export default IconToggleField;

================================================================================
FILE: client/src/components/fields/NumberField.tsx
================================================================================

import Stack from "@mui/material/Stack";
import IconButton from "@mui/material/IconButton";
import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import InputBase from "@mui/material/InputBase";
import ChevronLeftIcon from "@mui/icons-material/ChevronLeft";
import ChevronRightIcon from "@mui/icons-material/ChevronRight";
import { FieldProps } from "../NodeContent";
import { useTheme } from '@mui/material/styles';
import { useEffect, useRef, useState } from "react";
import getDecimalPlaces from "../utils/getDecimalPlaces";
const NumberField = ({
    fieldKey,
    fieldType,
    dataType,
    value,
    style,
    disabled,
    hidden,
    label,
    min,
    max,
    step,
    updateStore,
}: FieldProps) => {
    const theme = useTheme();
    const inputRef = useRef<HTMLInputElement>();
    const dragStartRef = useRef({ x: 0, value: 0 });
    const isDraggingRef = useRef(false);
    const [isEditing, setIsEditing] = useState(false);

    const displaySlider = fieldType === 'slider' && min !== undefined && max !== undefined;
    const minValue = min !== undefined ? min : -Number.MAX_SAFE_INTEGER;
    const maxValue = max !== undefined ? max : Number.MAX_SAFE_INTEGER;
    const decimals = dataType === 'float' ? getDecimalPlaces(step) : 0;
    const increment = step !== undefined ? step : (dataType === 'float' ? 0.1 : 1);

    const formatValue = (value: number | string) => {
        if ( isEditing ) {
            return value;
        }

        const newValue = isNaN(Number(value)) ? 0 : Number(value);
        return Math.min(maxValue, Math.max(minValue, newValue)).toFixed(decimals)
    };

    const inputValue = formatValue(value || 0); // we use Zustand for the value and it's already memoized

    const getSliderStyle = () => {
        if (!displaySlider) return {};

        const sliderPercent = isNaN(Number(inputValue)) ? 0 : ((Number(inputValue) - minValue) / (maxValue - minValue) * 100);
        const baseColor = 'rgba(255,255,255,0.15)';
        const gradientStyle = `linear-gradient(to right, ${baseColor} ${sliderPercent}%, rgba(255,255,255,0.0) ${sliderPercent}%)`;

        return {
            background: gradientStyle,
        };
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();

        const delta = e.clientX - dragStartRef.current.x;

        // ignore small movements
        if (Math.abs(delta) < 2) return;

        if (!isDraggingRef.current) {
            isDraggingRef.current = true;
        }

        const inputElement = inputRef.current;

        // we are dragging, so we remove the focus from the input
        if (document.activeElement === inputElement) {
            inputElement?.blur();
            setIsEditing(false);
        }

        const range = maxValue - minValue;
        const steps = range / increment || 100;
        const valueRange = displaySlider ? steps / 250 * delta : delta;
        const newValue = dragStartRef.current.value + valueRange*increment;

        updateStore?.(fieldKey, formatValue(newValue));
    };

    const handleMouseUp = (e: React.MouseEvent) => {
        document.removeEventListener('mousemove', handleMouseMove as any);
        document.removeEventListener('mouseup', handleMouseUp as any);
        
        const currentTarget = (e.target as HTMLElement).closest('.numberField');
        const closestTarget = (e.target as HTMLElement).closest('button');

        if (currentTarget && displaySlider && !isDraggingRef.current && !closestTarget) {
            const rect = currentTarget.getBoundingClientRect();

            const x = e.clientX - rect.left;
            const relPos = Math.max(0, Math.min(1, x / rect.width));
            const newValue = formatValue(minValue + (maxValue - minValue) * relPos);
            updateStore?.(fieldKey, newValue);
        }
        
        isDraggingRef.current = false;
    };

    const handleMouseDown = (e: React.MouseEvent) => {
        e.preventDefault();
        e.stopPropagation();

        // Only handle left mouse button
        if (e.button !== 0) return;

        // if we are already editing, don't do anything
        if (isEditing) return;

        // blur any currently focused element
        (document.activeElement as HTMLElement)?.blur();

        dragStartRef.current = { x: e.clientX, value: Number(inputValue) };

        document.addEventListener('mousemove', handleMouseMove as any);
        document.addEventListener('mouseup', handleMouseUp as any);
    };

    const handleBlur = () => {
        const inputElement = inputRef.current;
        setIsEditing(false);

        if (!inputElement) return;

        if (Number(inputElement.value) !== Number(inputValue)) {
            updateStore?.(fieldKey, formatValue(inputElement.value));
        }

        // trick to force a re-render otherwise the style won't update on blur in some edge cases
        const currentValue = inputElement.value;
        updateStore?.(fieldKey, formatValue(' ' + currentValue));
        updateStore?.(fieldKey, formatValue(currentValue));

        inputElement.removeEventListener('keydown', handleKeyDown as any);
    };

    const handleKeyDown = (e: React.KeyboardEvent) => {
        const inputElement = inputRef.current;

        if (!inputElement) return;

        if (e.key === 'Enter' || e.key === 'Escape') {
            inputElement.removeEventListener('keydown', handleKeyDown as any);

            setIsEditing(false);
            updateStore?.(fieldKey, formatValue(inputElement.value || ''));
            inputElement.blur();
        } else if (e.key === 'ArrowUp') {
            e.preventDefault();
            const newValue = Math.min(maxValue, Math.max(minValue, Number(inputElement.value) + increment)).toFixed(decimals);
            inputElement.value = String(newValue);
            updateStore?.(fieldKey, newValue);
        } else if (e.key === 'ArrowDown') {
            e.preventDefault();
            const newValue = Math.min(maxValue, Math.max(minValue, Number(inputElement.value) - increment)).toFixed(decimals);
            inputElement.value = String(newValue);
            updateStore?.(fieldKey, newValue);
        }
    };

    const handleDoubleClick = (e: React.MouseEvent) => {
        // ignore double clicks on buttons
        if ((e.target as HTMLElement).closest('button')) return;

        const inputElement = inputRef.current;
        if (!inputElement) return;

        inputElement.focus();
        inputElement.select();
        setIsEditing(true);

        inputElement.addEventListener('keydown', handleKeyDown as any);
    };

    useEffect(() => {
        const inputElement = inputRef.current;
        if (inputElement === document.activeElement) {
            inputElement.focus();
            setIsEditing(true);
        } else {
            inputElement?.blur();
            setIsEditing(false);
        }

        return () => {
            document.removeEventListener('mousemove', handleMouseMove as any);
            document.removeEventListener('mouseup', handleMouseUp as any);

            const inputElement = inputRef.current;
            if (inputElement) {
                inputElement.removeEventListener('keydown', handleKeyDown as any);
            }
        };
    }, [isEditing, inputRef]);

    return (
        <Box className={`${hidden ? 'mellon-hidden' : ''} ${disabled ? 'mellon-disabled' : ''}`}>
            <Stack
                data-key={fieldKey}
                direction="row"
                spacing={0.5}
                className={`numberField nodrag`}
                onMouseDown={handleMouseDown}
                onDoubleClick={handleDoubleClick}
                sx={{
                    mb: 0,
                    p: 0.6,
                    width: '100%',
                    justifyContent: 'space-between',
                    alignItems: 'center',
                    borderRadius: 1,
                    overflow: 'hidden',
                    userSelect: 'none',
                    cursor: 'default',
                    outline: isEditing ? `2px solid ${theme.palette.primary.main}` : "1px solid #4f4f4f",
                    '&:hover': {
                        outline: isEditing ? `2px solid ${theme.palette.primary.main}` : `1px solid ${theme.palette.common.white}`,
                    },
                    ...getSliderStyle(),
                    ...style
                }}
            >
                <IconButton
                    size="small"
                    disableRipple // ripple effect is buggy
                    onClick={() => { inputRef.current?.blur(); updateStore?.(fieldKey, formatValue(Number(inputRef.current?.value) - increment)) }}
                    sx={{
                        p: 0.5,
                        borderRadius: 1,
                        opacity: Number(inputValue) <= minValue ? 0.4 : 1,
                        '&:hover': { background: Number(inputValue) <= minValue ? '' : 'rgba(255,255,255,0.15)' }
                    }}
                >
                    <ChevronLeftIcon fontSize="small" />
                </IconButton>
                <Box sx={{ maxWidth: '50%', pointerEvents: 'none' }}>
                    <Typography sx={{ fontSize: 13, color: theme.palette.text.secondary, textOverflow: 'ellipsis', overflow: 'hidden', whiteSpace: 'nowrap' }} title={label}>{label}</Typography>
                </Box>
                <InputBase
                    inputRef={inputRef}
                    value={inputValue}
                    size="small"
                    onChange={(e) => updateStore?.(fieldKey, formatValue(e.target.value))}
                    onBlur={handleBlur}
                    sx={{ flexGrow: 1, pointerEvents: 'none' }}
                    slotProps={{
                        input: {
                            sx: { textAlign: 'right', p: 0, cursor: 'default' },
                        },
                    }}
                />
                <IconButton
                    size="small"
                    disableRipple
                    onClick={() => { inputRef.current?.blur(); updateStore?.(fieldKey, formatValue(Number(inputRef.current?.value) + increment)) }}
                    sx={{
                        p: 0.5,
                        borderRadius: 1,
                        opacity: Number(inputValue) >= maxValue ? 0.4 : 1,
                        '&:hover': { background: Number(inputValue) >= maxValue ? '' : 'rgba(255,255,255,0.15)' }
                    }}
                >
                    <ChevronRightIcon fontSize="small" />
                </IconButton>
            </Stack>
        </Box>
    );
}

export default NumberField;


================================================================================
FILE: client/src/components/fields/RangeField.tsx
================================================================================

import Box from "@mui/material/Box"
import Slider from "@mui/material/Slider"
import Typography from "@mui/material/Typography"
import { FieldProps } from "../NodeContent"
import { useTheme } from "@mui/material/styles"

const RangeField = ({ fieldKey, value, style, disabled, hidden, label, min, max, step, updateStore }: FieldProps) => {
    const theme = useTheme();

    return (
        <Box
            key={fieldKey}
            data-key={fieldKey}
            sx={{ pt: 0, pb: 1, pl: 1, pr: 1, ...style }}
            className={`nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}>
            <Typography gutterBottom>{label}</Typography>
            <Slider
                value={value || [0, 1]}
                onChange={(_, newValue) => updateStore?.(fieldKey, newValue)}
                min={min || 0}
                max={max || 1}
                step={step || 0.01}
                valueLabelDisplay="auto"
                color="secondary"
                disableSwap
                sx={{
                    '& .MuiSlider-thumb': {
                        color: theme.palette.secondary.main,
                    },
                }}
            />
        </Box>
    )
}

export default RangeField;

================================================================================
FILE: client/src/components/fields/SelectField.tsx
================================================================================

import Box from "@mui/material/Box/Box";
import Select from "@mui/material/Select";
import FormControl from "@mui/material/FormControl";
import InputLabel from "@mui/material/InputLabel";
import { FieldProps } from "../NodeContent";
import { useEffect } from "react";

const SelectField = ({ fieldKey, value, style, disabled, hidden, label, options, updateStore, onChangeAction }: FieldProps) => {

    const handleShowAction = (value: string, optionsMap: object) => {
        Object.entries(optionsMap).forEach(([key, target]: any) => {
            const isHidden = key !== value;

            if (!target) return;

            if (!Array.isArray(target)) {
                target = [target];
            }

            target.forEach((t: string) => {
                if (t.endsWith('_group')) {
                    updateStore?.(t, { hidden: isHidden }, 'group');
                } else {
                    updateStore?.(t, isHidden, 'hidden');
                }
            });
        });
    };

    const menuItems = Array.isArray(options) ? (
        options.map((v: any, i: number) => (
            <option key={`${fieldKey}-${i}`} value={v}>{v}</option>
        ))
    ) : (
        Object.entries(options).map(([k, v]: any) => (
            <option key={`${fieldKey}-${k}`} value={k}>
                {typeof v === 'object' ? v.label : v}
            </option>
        ))
    );

    useEffect(() => {
        if (onChangeAction?.action === 'show') {
            handleShowAction(value, onChangeAction?.target);
        }
    }, [value]);

    return (
        <Box
            data-key={fieldKey}
            className={`nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ ...style }}
        >
            <FormControl fullWidth>
                <InputLabel>{label}</InputLabel>
                <Select
                    fullWidth
                    size="small"
                    label={label}
                    value={value || ''}
                    native
                    onChange={(e) => updateStore?.(fieldKey, e.target.value)}
                >
                    {menuItems}
                </Select>
            </FormControl>
        </Box>
    )
};

export default SelectField;


================================================================================
FILE: client/src/components/fields/TagsField.tsx
================================================================================

import Box from "@mui/material/Box";
import Autocomplete from "@mui/material/Autocomplete";
import TextField from "@mui/material/TextField";

import { FieldProps } from "../NodeContent";

const TagsField = ({ fieldKey, value, style, disabled, hidden, label, no_validation, options, updateStore }: FieldProps) => {
    const tags = typeof value === 'string' ? [value] : value || [];

    return (
        <Box
            data-key={fieldKey}
            sx={{ minWidth: '320px', ...style }}
            className={`nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Autocomplete
                multiple
                disablePortal
                filterSelectedOptions
                handleHomeEndKeys
                freeSolo={no_validation}
                options={options}
                renderInput={(params: any) => <TextField {...params} label={label} />}
                onChange={(_, v) => updateStore?.(fieldKey, v)}
                value={tags}
                size="small"
            />
        </Box>
    )
}

export default TagsField;

================================================================================
FILE: client/src/components/fields/TextField.tsx
================================================================================

import Box from "@mui/material/Box";
import MuiTextField from "@mui/material/TextField";
import { FieldProps } from "../NodeContent";

const TextField = ({
    fieldKey,
    value,
    dataType,
    style,
    disabled,
    hidden,
    label,
    updateStore,
}: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ ...style }}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <MuiTextField
                onChange={(e) => updateStore?.(fieldKey, e.target.value)}
                variant="outlined"
                type="text"
                size="small"
                fullWidth
                label={label}
                value={value}
                className="nodrag"
                autoComplete="off"
                sx={ (dataType === 'int' || dataType === 'integer' || dataType === 'float' || dataType === 'number') ? { '& input': { textAlign: 'right' } } : {} }
            />
        </Box>
    );
}

export default TextField;

================================================================================
FILE: client/src/components/fields/TextareaField.tsx
================================================================================

import Box from "@mui/material/Box";
import { FieldProps } from "../NodeContent";
import { TextField } from "@mui/material";

const TextareaField = ({ fieldKey, value, style, disabled, hidden, label, updateStore }: FieldProps) => {
    return (
        <Box
            key={fieldKey}
            data-key={fieldKey}
            className={`nodrag nowheel ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ minWidth: '320px', ...style }}
        >
            <TextField
                variant="outlined"
                type="text"
                size="small"
                fullWidth
                multiline
                minRows={3}
                maxRows={12}
                label={label}
                value={value}
                onChange={(e) => updateStore?.(fieldKey, e.target.value)}
            />
        </Box>
    );
}

export default TextareaField;

================================================================================
FILE: client/src/components/fields/ToggleField.tsx
================================================================================

import Box from "@mui/material/Box";
import Switch from "@mui/material/Switch";
import Checkbox from "@mui/material/Checkbox";
import FormControlLabel from "@mui/material/FormControlLabel";
import FormGroup from "@mui/material/FormGroup";
import { FieldProps } from "../NodeContent";
import { useEffect } from "react";

const ToggleField = ({ fieldType, fieldKey, label, style, disabled, hidden, value, updateStore, onChangeAction }: FieldProps) => {
    const MuiSwitch = fieldType === 'switch' ? Switch : Checkbox;

    const handleDisableAction = (value: boolean, target: any) => {
        const onTrueTargets = Array.isArray(target.true) ? target.true : [target.true];
        const onFalseTargets = Array.isArray(target.false) ? target.false : [target.false];

        onTrueTargets.forEach((field: string) => {
            if (field.endsWith('_group')) {
                updateStore?.(field, { disabled: value }, 'group');
            } else {
                updateStore?.(field, value, 'disabled');
            }
        });
        onFalseTargets.forEach((field: string) => {
            if (field.endsWith('_group')) {
                updateStore?.(field, { disabled: !value }, 'group');
            } else {
                updateStore?.(field, !value, 'disabled');
            }
        });
    };

    useEffect(() => {
        if (onChangeAction?.action === 'disable') {
            handleDisableAction(value, onChangeAction.target);
        }
    }, [value]);

    return (
        <Box
            data-key={fieldKey}
            className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            sx={{ ...style }}
        >
            <FormGroup>
                <FormControlLabel
                    sx={{ m: 0, p: 0 }}
                    control={<MuiSwitch
                        sx={{ mr: 0.5 }}
                        size="small"
                        color="secondary"
                        className="nodrag"
                        checked={value}
                        onChange={(e) => updateStore?.(fieldKey, e.target.checked)}
                    />}
                    label={label}
                />
            </FormGroup>
        </Box>
    );
};


export default ToggleField;


================================================================================
FILE: client/src/components/fields/UIDropdownIcon.tsx
================================================================================

import Box from "@mui/material/Box";
import IconButton from "@mui/material/IconButton";
import MoreVertIcon from '@mui/icons-material/MoreVert';
import Menu from "@mui/material/Menu";
import { useTheme } from "@mui/material/styles";

import { FieldProps } from "../NodeContent";
import { useState } from "react";
import Divider from "@mui/material/Divider";
import MenuItem from "@mui/material/MenuItem";

const UIDropdownIcon = ({ fieldKey, style, disabled, hidden, label, options, updateStore, onChangeAction }: FieldProps) => {
    const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
    const open = Boolean(anchorEl);
    const targetFields = Array.isArray(onChangeAction?.target) ? onChangeAction?.target : [onChangeAction?.target];

    const theme = useTheme();

    const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
        setAnchorEl(event.currentTarget);
    };
    const handleMenuItemClick = (i: number) => {
        setAnchorEl(null);
        if (i<0) return;

        const targetValue = Array.isArray(options[i].value) ? options[i].value : [options[i].value];

        targetFields.forEach((k: string, i: number) => {
            updateStore?.(k, targetValue[i]);
        });
    };

    return (
        <Box data-key={fieldKey} className={`flex-auto nodrag ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`} sx={{ ...style }}>
            <IconButton
                onClick={handleClick}
                title={label}
            >
                <MoreVertIcon />
            </IconButton>
            <Menu
                anchorEl={anchorEl}
                open={open}
                onClose={() => handleMenuItemClick(-1)}
                slotProps={{
                    paper: {
                        sx: {
                            maxHeight: '640px',
                            lineHeight: '0',
                            '& li:hover': {
                                backgroundColor: theme.palette.secondary.main,
                            },
                        },
                        elevation: 8,
                    },
                }}
            >
                {options.map((option: any, i: number) => (
                    option.label?.startsWith('---') ? (
                        <Divider key={i} sx={{ borderColor: 'rgba(255, 255, 255, 0.5)' }} />
                    ) : (
                        <MenuItem key={i} sx={{ lineHeight: '1.2', pl: 1, pr: 1 }} onClick={() => handleMenuItemClick(i)}>
                            {option.label}
                        </MenuItem>
                    )
                ))}
            </Menu>
        </Box>
    )
}

export default UIDropdownIcon;

================================================================================
FILE: client/src/components/fields/UIImageField.tsx
================================================================================

import { FieldProps } from "../NodeContent";
import config from '../../../config';
import Box from "@mui/material/Box";
import { KeyboardEventHandler, MouseEventHandler, useCallback, useEffect, memo, useRef, useState, WheelEventHandler } from "react";
import Modal from "@mui/material/Modal";
import IconButton from "@mui/material/IconButton";
import Slider from "@mui/material/Slider";
import ArrowBackIcon from '@mui/icons-material/ArrowBack';
import ArrowForwardIcon from '@mui/icons-material/ArrowForward';
import CloseIcon from '@mui/icons-material/Close';
import { useTheme } from '@mui/material/styles';
import { deepEqual } from '../utils/deepEqual';

const LightBox = memo(({ urls, index, label, onClose }: { urls: {url: string, width: number, height: number}[], index: number, label: string, onClose: () => void }) => {
    const theme = useTheme();

    const [currentIndex, setCurrentIndex] = useState(-1);
    const [zoom, setZoom] = useState(1);
    const [pan, setPan] = useState({ x: 0, y: 0 });

    const isDraggingRef = useRef(false);
    const dragStartRef = useRef({ x: 0, y: 0 });
    const timeRef = useRef(0);

    // Add mouse drag handlers for panning
    const handleMouseDown = (e: React.MouseEvent) => {
        if (zoom === 1) return;
        isDraggingRef.current = true;
        dragStartRef.current = {
            x: e.clientX - pan.x,
            y: e.clientY - pan.y
        };
    };

    const handleMouseMove = (e: React.MouseEvent) => {
        if (!isDraggingRef.current) return;
        const newX = e.clientX - dragStartRef.current.x;
        const newY = e.clientY - dragStartRef.current.y;
        
        // Calculate bounds to prevent panning outside image bounds
        const bounds = {
            x: Math.min(Math.max(newX, -(zoom - 1) * 500), (zoom - 1) * 500),
            y: Math.min(Math.max(newY, -(zoom - 1) * 500), (zoom - 1) * 500)
        };
        
        setPan(bounds);
    };

    const handleMouseUp = (_: React.MouseEvent) => {
        isDraggingRef.current = false;
    };

    // Reset pan when zoom changes or image changes
    useEffect(() => {
        setPan({ x: 0, y: 0 });
    }, [zoom, currentIndex]);

    useEffect(() => {
        timeRef.current = Date.now();
    }, [urls]);

    useEffect(() => {
        setZoom(1);
        setPan({ x: 0, y: 0 });
        setCurrentIndex(index);
    }, [index]);

    const handleKeyDown = useCallback<KeyboardEventHandler<HTMLDivElement>>((e) => {
        if (currentIndex === -1) return;

        if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
            e.preventDefault();
            e.stopPropagation();

            if (e.key === 'ArrowLeft' && currentIndex > 0) {
                setCurrentIndex(currentIndex - 1);
            }
            if (e.key === 'ArrowRight' && currentIndex < urls.length - 1) {
                setCurrentIndex(currentIndex + 1);
            }    
        }
    }, [currentIndex, urls.length]);

    const handleWheel = useCallback<WheelEventHandler<HTMLDivElement>>((e) => {
        if (currentIndex === -1) return;
        setZoom(prev => Math.min(Math.max(1, prev - e.deltaY * 0.005), 4));
    }, [currentIndex]);

    const currentUrl = () => {
        if (currentIndex === -1) return '';
        return `http://${config.serverAddress}${urls[currentIndex].url.split('?')[0].replace(/\/$/, '')}?t=${timeRef.current}`;
    };

    // Navigation handlers
    const handlePrevImage = useCallback<MouseEventHandler<HTMLButtonElement>>(() => currentIndex > 0 && setCurrentIndex(currentIndex - 1), [currentIndex]);
    const handleNextImage = useCallback<MouseEventHandler<HTMLButtonElement>>(() => currentIndex < urls.length - 1 && setCurrentIndex(currentIndex + 1), [currentIndex, urls.length]);

    return (
        <Modal
            open={currentIndex > -1}
            onClose={onClose}
            onKeyDown={handleKeyDown}
            onWheel={handleWheel}
            aria-labelledby="lightbox"
        >
            <Box
                sx={{
                    position: 'absolute',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    width: '100vw',
                    height: '100vh',
                    display: 'flex',
                    flexDirection: 'column',
                    justifyContent: 'center',
                    alignItems: 'center',
                }}
                onClick={onClose}
            >
                <Box
                    sx={{
                        display: 'flex',
                        alignItems: 'center',
                        p: 2,
                        backgroundColor: theme.palette.background.paper,
                        borderRadius: 1,
                        mb: 1, mt: 2,
                        //border: `1px solid ${theme.palette.divider}`,
                    }}
                    onClick={(e) => { e.stopPropagation(); e.preventDefault(); }}
                >
                    <IconButton 
                        onClick={handlePrevImage}
                        disabled={currentIndex === 0}
                        size="small"
                    >
                        <ArrowBackIcon />
                    </IconButton>
                    <IconButton
                        onClick={handleNextImage}
                        disabled={currentIndex === urls.length - 1}
                        size="small"
                    >
                        <ArrowForwardIcon />
                    </IconButton>
                    <Slider
                        value={zoom}
                        onChange={(_, newValue) => setZoom(newValue as number)}
                        min={1}
                        max={4}
                        step={0.1}
                        sx={{ mx: 2, width: 200 }}
                    />
                    <Box sx={{ flexGrow: 1 }} />
                    <IconButton onClick={onClose} size="small">
                        <CloseIcon />
                    </IconButton>
                </Box>
                <Box
                    sx={{
                        flexGrow: 1,
                        overflow: 'hidden',
                        display: 'flex',
                        justifyContent: 'center',
                        alignItems: 'center',
                        cursor: zoom > 1 ? 'grab' : 'default',
                        '&:active': {
                            cursor: zoom > 1 ? 'grabbing' : 'default',
                        },
                        '& img': {
                            maxWidth: '100%',
                            maxHeight: '100%',
                            objectFit: 'contain',
                            p: 0, m: 0,
                            transform: `scale(${zoom}) translate(${pan.x / zoom}px, ${pan.y / zoom}px)`,
                            transition: isDraggingRef.current ? 'none' : 'transform 0.2s',
                            pointerEvents: 'none',
                            imageRendering: 'pixelated'
                        }
                    }}
                    onMouseDown={handleMouseDown}
                    onMouseMove={handleMouseMove}
                    onMouseUp={handleMouseUp}
                    onMouseLeave={handleMouseUp}
                    onClick={(e) => { e.stopPropagation(); e.preventDefault(); }}
                >
                {currentIndex > -1 && (
                    <img
                        src={currentUrl()}
                        alt={`${label} ${currentIndex}`}
                        width={`${urls[currentIndex].width}`}
                        height={`${urls[currentIndex].height}`}
                    />
                )}
                </Box>
            </Box>
        </Modal>
    )
}, (prevProps, nextProps) => {
    if (prevProps.index !== nextProps.index) { 
        return false;
    }

    if (!deepEqual(prevProps.urls, nextProps.urls)) {
        return false;
    }

    return true;
});

const UIImageField = ({ fieldKey, value, style, disabled, hidden, label }: FieldProps) => {
    if (typeof value === 'string') {
        value = [{url: value, width: 0, height: 0}];
    }

    //const imgWidth = value.length > 1 ? '50%' : '100%';
    const containerWidth = value.length > 1 ? '1288px' : 'auto';
    const maxHeight = value.length > 4 ? '1360px' : 'auto';

    const imageWidth = (width: number, height: number) => {
        if (value.length === 1) {
            return '100%';
        }
        const aspectRatio = width / height;
        if (aspectRatio > 1.6) {
            return '100%';
        }
        return '50%';
    }

    const [modalIndex, setModalIndex] = useState(-1);

    const handleModalOpen = (index: number) => {
        setModalIndex(index);
    };

    return (
        <>
        <Box
            data-key={fieldKey}
            sx={{
                width: containerWidth,
                height: 'auto',
                maxWidth: '2048px',
                maxHeight: maxHeight,
                overflow: value.length > 4 ? 'auto' : 'hidden',
                mb: 2,
                ...style,
            }}
            className={`${value.length > 4 ? 'nowheel' : ''} ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            {value.map(({url, width, height}: {url: string, width: number, height: number}, index: number) => (
                <Box
                    key={`${fieldKey}-${index}`}
                    sx={{
                        width: imageWidth(Number(width), Number(height)),
                        height: 'auto',
                        display: 'block',
                        float: 'left',
                        '& img': {
                            width: '100%',
                            height: 'auto',
                            display: 'block',
                            p: 0.25,
                            cursor: 'pointer'
                        }
                    }}
                >
                    <img src={`http://${config.serverAddress}${url}`} alt={`${label} ${index}`} onClick={() => handleModalOpen(index)} />
                </Box>
            ))}
        </Box>

        <LightBox
            urls={value}
            index={modalIndex}
            label={label || ''}
            onClose={() => setModalIndex(-1)}
        />
        </>
    );
};

export default UIImageField;

================================================================================
FILE: client/src/components/fields/UITextField.tsx
================================================================================

import Box from "@mui/material/Box";
import Typography from "@mui/material/Typography";
import { FieldProps } from "../NodeContent";
import { useTheme } from "@mui/material/styles";

const UITextField = ({
    fieldKey,
    value,
    style,
    disabled,
    hidden,
    label,
}: FieldProps) => {
    const theme = useTheme();
    // const dataUrl = value.url; // not used, but this endpoint can be used to display the text field value
    const dataValue = value.value;

    return (
        <Box>
            <Typography sx={{ fontSize: 13, color: theme.palette.text.secondary, fontWeight: 'bold' }}>{label}</Typography>
            <Box
                component="pre"
                data-key={fieldKey}
                sx={{ color: theme.palette.text.secondary, backgroundColor: '#111', border: `1px solid ${theme.palette.divider}`, borderRadius: 1, padding: 1, m: 0, mb: 1, ...style }}
                className={`${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
            >
                <Typography>{dataValue}</Typography>
            </Box>
        </Box>
    );
}

export default UITextField;

================================================================================
FILE: client/src/components/fields/UIThreeField.tsx
================================================================================

import { lazy, Suspense } from "react";
const ThreePreview = lazy(() => import('./UIThreePreview'));

import { FieldProps } from "../NodeContent";
import Box from "@mui/material/Box";
import CircularProgress from "@mui/material/CircularProgress";

const UIThreeFields = ({ fieldKey, value, style, disabled, hidden }: FieldProps) => {
    return (
        <Box
            data-key={fieldKey}
            sx={{ p: 0, m: 0, mt: 1, mb: 1, ...style }}
            className={`nodrag nowheel ${disabled ? 'mellon-disabled' : ''} ${hidden ? 'mellon-hidden' : ''}`}
        >
            <Suspense fallback={
                <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', width: '768px', height: '768px' }}>
                    <CircularProgress />
                </Box>
            }>
                <ThreePreview value={value} />
            </Suspense>
        </Box>
    );
};

export default UIThreeFields;

================================================================================
FILE: client/src/components/fields/UIThreePreview.tsx
================================================================================

import { Canvas } from '@react-three/fiber';
import { Environment, OrbitControls, useGLTF, Center } from '@react-three/drei';
import config from '../../../config';
import { useEffect, useState } from 'react';
import { useStore } from '@xyflow/react';

import Button from '@mui/material/Button';
import Select from '@mui/material/Select';
import Stack from '@mui/material/Stack';

import * as THREE from 'three';

function getMaterial(materialType: string, wireframe: boolean, shaded: boolean, originalMaterial: THREE.Material | null) {
    let material;
    switch(materialType) {
        case 'phong':
            material = new THREE.MeshPhongMaterial({
            color: 0xffffff,
            wireframe,
            flatShading: !shaded,
            shininess: 100,
            specular: 0x444444,
            side: THREE.DoubleSide
        });
        break;
    case 'lambert':
        material = new THREE.MeshLambertMaterial({
            color: 0xffffff,
            wireframe,
            flatShading: !shaded,
            side: THREE.DoubleSide
        });
        break;
    case 'normal':
        material = new THREE.MeshNormalMaterial({
            wireframe,
            flatShading: !shaded,
            side: THREE.DoubleSide
        });
        break;
    case 'toon':
        material = new THREE.MeshToonMaterial({
            color: 0xffffff,
            wireframe,
            side: THREE.DoubleSide,
            map: originalMaterial instanceof THREE.MeshStandardMaterial ? originalMaterial.map : null,
            normalMap: originalMaterial instanceof THREE.MeshStandardMaterial ? originalMaterial.normalMap : null,
        });
        break;
    case 'metal':
        material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 1.0,
            roughness: 0.1,
            wireframe,
            flatShading: !shaded,
            side: THREE.DoubleSide,
            envMapIntensity: 1.5
        });
        break;
    default: // 'standard'
        material = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            wireframe,
            flatShading: !shaded,
            roughness: 0.5,
            metalness: 0.1,
            side: THREE.DoubleSide
        });
    }

    return material;
}

function Model({ url, wireframe, shaded, materialType }: { url: string, wireframe: boolean, shaded: boolean, materialType: string }) {
    const [error, setError] = useState<Error | null>(null);
    const { scene } = useGLTF(url, undefined, undefined, (err: any) => {
        if (err instanceof Error) {
            console.log("Error loading 3d model", err.message)
            setError(err);
        }
    });

    if (error || !scene) {
        return null;
    }

    useEffect(() => {
        console.log("scene", scene)
        scene.traverse((child: any) => {
            if (child.isMesh) {
                console.log("mesh", child)
                child.userData.originalMaterial = child.material;
                console.log("child material", child.material)
            }
        });
    }, [scene]);

    useEffect(() => {
        scene.traverse((child: any) => {
            if (child.isMesh) {
                if (child.material) {
                    if (materialType === 'original') {
                        child.material = child.userData.originalMaterial;
                        child.material.flatShading = !shaded;
                        child.material.wireframe = wireframe;
                        //child.material.emissive = new THREE.Color(0x111111);
                        //child.material.emissiveIntensity = 1.5;
                    } else {
                        child.material = getMaterial(materialType, wireframe, shaded, child.userData.originalMaterial);
                    }
                    child.material.needsUpdate = true;
                    
                    // Force geometry normal updates
                    if (child.geometry) {
                        child.geometry.computeVertexNormals();
                        child.geometry.attributes.normal.needsUpdate = true;
                    }
                }
            }
        });
    }, [wireframe, shaded, materialType]);

    return (
        <Center>
            <primitive object={scene} />
        </Center>
    );
}

export default function ThreePreview({ value, ...props }: { value: any, [key: string]: any }) {
    const zoomLevel = useStore((state: any) => state.transform[2]);
    const [wireframe, setWireframe] = useState(false);
    const [shaded, setShaded] = useState(false);
    const [materialType, setMaterialType] = useState('original');

    const containerSize = 768;
    const scaledSize = containerSize * zoomLevel;

    const url = value[0]?.url;
    return (
        <div
            style={{
                position: 'relative',
                width: '768px',
                height: '768px',
                overflow: 'hidden',
            }}
            {...props}
        >
            <div style={{
                position: 'absolute',
                top: 0,
                left: 0,
                transform: `scale(${1/zoomLevel})`,
                transformOrigin: 'top left',
                width: `${scaledSize}px`,
                height: `${scaledSize}px`,
            }}>
                <Canvas
                    style={{ background: '#333333', width: '100%', height: '100%' }}
                    resize={{ scroll: false, debounce: { scroll: 50, resize: 0 } }}
                    camera={{ position: [0, 0, 5] }}
                    dpr={2}
                >
                    <ambientLight intensity={0.25} />
                    <directionalLight position={[5, 5, 5]} intensity={1} />
                    <directionalLight position={[-5, 0, -5]} intensity={0.25} />
                    {url && <Model
                        url={`http://${config.serverAddress}${url}`}
                        wireframe={wireframe}
                        shaded={shaded}
                        materialType={materialType}
                    />}
                    <OrbitControls
                        enableDamping
                        target={[0, 0, 0]}
                        dampingFactor={0.05}
                    />
                    <Environment preset="warehouse" background={false} />
                </Canvas>
            </div>

            <Stack 
                direction="row" 
                spacing={1} 
                sx={{ 
                    position: 'absolute', 
                    top: 10, 
                    left: 10, 
                    zIndex: 1 
                }}
            >
                <Button 
                    variant={wireframe ? "contained" : "outlined"}
                    color="secondary"
                    size="small"
                    onClick={() => setWireframe(!wireframe)}
                    sx={{
                        fontSize: '11px',
                        '&.MuiButton-outlined': {
                            color: '#999999',
                        }
                    }}
                >
                    Wireframe
                </Button>
                <Button 
                    variant={shaded ? "contained" : "outlined"}
                    color="secondary"
                    size="small"
                    onClick={() => setShaded(!shaded)}
                    sx={{
                        fontSize: '11px',
                        '&.MuiButton-outlined': {
                            color: '#999999',
                        }
                    }}
                >
                    Smooth shading
                </Button>
                <Select
                    value={materialType}
                    onChange={(e) => setMaterialType(e.target.value)}
                    size="small"
                    native={true}
                    sx={{
                        fontSize: '12px',
                        width: '120px',
                        backgroundColor: 'rgba(0, 0, 0, 0.2)',
                    }}
                >
                    <option value="original">Original</option>
                    <option value="standard">Standard</option>
                    <option value="phong">Phong</option>
                    <option value="lambert">Lambert</option>
                    <option value="normal">Normal</option>
                    <option value="toon">Toon</option>
                    <option value="metal">Metal</option>
                </Select>
            </Stack>
        </div>
    );
}
